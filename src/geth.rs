/*
*****************************************************************************
	*
	* Copyright (C) 2024 Infineon Technologies AG. All rights reserved.
	*
	* Infineon Technologies AG (Infineon) is supplying this software for use with
	* Infineon's microcontrollers. This file can be freely distributed within
	* development tools that are supporting such microcontrollers.
	*
	* THIS SOFTWARE IS PROVIDED "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED
	* OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
	* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
	* INFINEON SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL,
	* OR CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
	*
	******************************************************************************
*/
#![allow(clippy::identity_op)]
#![allow(clippy::module_inception)]
#![allow(clippy::derivable_impls)]
#[allow(unused_imports)]
use crate::common::sealed;
#[allow(unused_imports)]
use crate::common::*;
#[doc = r"GETH"]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Geth(pub(super) *mut u8);
unsafe impl core::marker::Send for Geth {}
unsafe impl core::marker::Sync for Geth {}
impl Geth {
    #[doc = "Access Enable Register 0\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn accen0(&self) -> crate::common::Reg<self::Accen0_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8204usize)) }
    }

    #[doc = "Clock Control Register\n resetvalue={Application Reset:0x3}"]
    #[inline(always)]
    pub const fn clc(&self) -> crate::common::Reg<self::Clc_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8192usize)) }
    }

    #[doc = "DMA Debug Status 0 Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_debug_status0(
        &self,
    ) -> crate::common::Reg<self::DmaDebugStatus0_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(4108usize)) }
    }

    #[doc = "DMA Debug Status 1 Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_debug_status1(
        &self,
    ) -> crate::common::Reg<self::DmaDebugStatus1_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(4112usize)) }
    }

    #[doc = "DMA Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_interrupt_status(
        &self,
    ) -> crate::common::Reg<self::DmaInterruptStatus_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(4104usize)) }
    }

    #[doc = "DMA Bus Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_mode(&self) -> crate::common::Reg<self::DmaMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(4096usize)) }
    }

    #[doc = "DMA System Bus Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_sysbus_mode(
        &self,
    ) -> crate::common::Reg<self::DmaSysbusMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(4100usize)) }
    }

    #[doc = "General Purpose Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn gpctl(&self) -> crate::common::Reg<self::Gpctl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8200usize)) }
    }

    #[doc = "Module Identification Register\n resetvalue={Application Reset:0x0E9C000}"]
    #[inline(always)]
    pub const fn id(&self) -> crate::common::Reg<self::Id_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8196usize)) }
    }

    #[doc = "Kernel Reset Register 0\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn krst0(&self) -> crate::common::Reg<self::Krst0_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8212usize)) }
    }

    #[doc = "Kernel Reset Register 1\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn krst1(&self) -> crate::common::Reg<self::Krst1_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8216usize)) }
    }

    #[doc = "Kernel Reset Status Clear Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn krstclr(&self) -> crate::common::Reg<self::Krstclr_SPEC, crate::common::W> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8220usize)) }
    }

    #[doc = "MAC One Microsecond Tic Counter Register\n resetvalue={Application Reset:0x63}"]
    #[inline(always)]
    pub const fn mac_1us_tic_counter(
        &self,
    ) -> crate::common::Reg<self::Mac1UsTicCounter_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(220usize)) }
    }

    #[doc = "MAC Address 0 High Register\n resetvalue={Application Reset:0x08000FFFF}"]
    #[inline(always)]
    pub const fn mac_address0_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress0High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(768usize)) }
    }

    #[doc = "MAC Address 0 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address0_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress0Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(772usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address10_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress10High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(848usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address10_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress10Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(852usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address11_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress11High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(856usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address11_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress11Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(860usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address12_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress12High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(864usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address12_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress12Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(868usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address13_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress13High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(872usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address13_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress13Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(876usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address14_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress14High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(880usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address14_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress14Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(884usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address15_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress15High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(888usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address15_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress15Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(892usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address16_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress16High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(896usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address16_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress16Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(900usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address17_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress17High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(904usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address17_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress17Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(908usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address18_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress18High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(912usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address18_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress18Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(916usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address19_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress19High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(920usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address19_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress19Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(924usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address1_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress1High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(776usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address1_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress1Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(780usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address20_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress20High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(928usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address20_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress20Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(932usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address21_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress21High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(936usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address21_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress21Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(940usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address22_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress22High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(944usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address22_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress22Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(948usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address23_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress23High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(952usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address23_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress23Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(956usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address24_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress24High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(960usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address24_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress24Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(964usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address25_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress25High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(968usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address25_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress25Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(972usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address26_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress26High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(976usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address26_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress26Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(980usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address27_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress27High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(984usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address27_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress27Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(988usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address28_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress28High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(992usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address28_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress28Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(996usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address29_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress29High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1000usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address29_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress29Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1004usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address2_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress2High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(784usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address2_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress2Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(788usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address30_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress30High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1008usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address30_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress30Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1012usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address31_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress31High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1016usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address31_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress31Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1020usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address3_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress3High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(792usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address3_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress3Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(796usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address4_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress4High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(800usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address4_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress4Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(804usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address5_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress5High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(808usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address5_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress5Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(812usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address6_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress6High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(816usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address6_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress6Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(820usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address7_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress7High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(824usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address7_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress7Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(828usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address8_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress8High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(832usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address8_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress8Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(836usize)) }
    }

    #[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
    #[inline(always)]
    pub const fn mac_address9_high(
        &self,
    ) -> crate::common::Reg<self::MacAddress9High_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(840usize)) }
    }

    #[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn mac_address9_low(
        &self,
    ) -> crate::common::Reg<self::MacAddress9Low_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(844usize)) }
    }

    #[doc = "MAC Configuration Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_configuration(
        &self,
    ) -> crate::common::Reg<self::MacConfiguration_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(0usize)) }
    }

    #[doc = "MAC CSR Software Controls Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_csr_sw_ctrl(
        &self,
    ) -> crate::common::Reg<self::MacCsrSwCtrl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(560usize)) }
    }

    #[doc = "MAC Debug Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_debug(&self) -> crate::common::Reg<self::MacDebug_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(276usize)) }
    }

    #[doc = "MAC Extended Configuration Register 1\n resetvalue={Application Reset:0x2}"]
    #[inline(always)]
    pub const fn mac_ext_cfg1(
        &self,
    ) -> crate::common::Reg<self::MacExtCfg1_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(568usize)) }
    }

    #[doc = "MAC Extended Configuration Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_ext_configuration(
        &self,
    ) -> crate::common::Reg<self::MacExtConfiguration_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(4usize)) }
    }

    #[doc = "MAC Hardware Feature Register 0\n resetvalue={Application Reset:0x0A7D71F7}"]
    #[inline(always)]
    pub const fn mac_hw_feature0(
        &self,
    ) -> crate::common::Reg<self::MacHwFeature0_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(284usize)) }
    }

    #[doc = "MAC Hardware Feature Register 1\n resetvalue={Application Reset:0x0922966}"]
    #[inline(always)]
    pub const fn mac_hw_feature1(
        &self,
    ) -> crate::common::Reg<self::MacHwFeature1_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(288usize)) }
    }

    #[doc = "MAC Hardware Feature Register 2\n resetvalue={Application Reset:0x10C30C3}"]
    #[inline(always)]
    pub const fn mac_hw_feature2(
        &self,
    ) -> crate::common::Reg<self::MacHwFeature2_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(292usize)) }
    }

    #[doc = "MAC Hardware Feature Register 3\n resetvalue={Application Reset:0x320032}"]
    #[inline(always)]
    pub const fn mac_hw_feature3(
        &self,
    ) -> crate::common::Reg<self::MacHwFeature3_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(296usize)) }
    }

    #[doc = "MAC Inner VLAN Tag Inclusion or Replacement Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_inner_vlan_incl_i(
        &self,
    ) -> crate::common::Reg<self::MacInnerVlanInclI_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(100usize)) }
    }

    #[doc = "MAC Interrupt Enable Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_interrupt_enable(
        &self,
    ) -> crate::common::Reg<self::MacInterruptEnable_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(180usize)) }
    }

    #[doc = "MAC Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_interrupt_status(
        &self,
    ) -> crate::common::Reg<self::MacInterruptStatus_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(176usize)) }
    }

    #[doc = "MAC LPI Control and Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_lpi_control_status(
        &self,
    ) -> crate::common::Reg<self::MacLpiControlStatus_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(208usize)) }
    }

    #[doc = "MAC LPI Entry Timer Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_lpi_entry_timer(
        &self,
    ) -> crate::common::Reg<self::MacLpiEntryTimer_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(216usize)) }
    }

    #[doc = "MAC LPI Timers Control Register\n resetvalue={Application Reset:0x3E80000}"]
    #[inline(always)]
    pub const fn mac_lpi_timers_control(
        &self,
    ) -> crate::common::Reg<self::MacLpiTimersControl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(212usize)) }
    }

    #[doc = "MAC MDIO Address Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_mdio_address(
        &self,
    ) -> crate::common::Reg<self::MacMdioAddress_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(512usize)) }
    }

    #[doc = "MAC MDIO Data Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_mdio_data(
        &self,
    ) -> crate::common::Reg<self::MacMdioData_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(516usize)) }
    }

    #[doc = "MAC Packet Filter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_packet_filter(
        &self,
    ) -> crate::common::Reg<self::MacPacketFilter_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8usize)) }
    }

    #[doc = "MAC PHY Interface Control and Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_phyif_control_status(
        &self,
    ) -> crate::common::Reg<self::MacPhyifControlStatus_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(248usize)) }
    }

    #[doc = "MAC PMT Control and Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_pmt_control_status(
        &self,
    ) -> crate::common::Reg<self::MacPmtControlStatus_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(192usize)) }
    }

    #[doc = "MAC PPS 0 Interval Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_pps0_interval(
        &self,
    ) -> crate::common::Reg<self::MacPps0Interval_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2952usize)) }
    }

    #[doc = "MAC PPS 0 Target Time Nanoeconds Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_pps0_target_time_nanoseconds(
        &self,
    ) -> crate::common::Reg<self::MacPps0TargetTimeNanoseconds_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2948usize)) }
    }

    #[doc = "MAC PPS 0 Target Time Seconds Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_pps0_target_time_seconds(
        &self,
    ) -> crate::common::Reg<self::MacPps0TargetTimeSeconds_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2944usize)) }
    }

    #[doc = "MAC PPS 0 Width Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_pps0_width(
        &self,
    ) -> crate::common::Reg<self::MacPps0Width_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2956usize)) }
    }

    #[doc = "MAC PPS Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_pps_control(
        &self,
    ) -> crate::common::Reg<self::MacPpsControl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2928usize)) }
    }

    #[doc = "MAC Queue 0 TX Flow Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_q0_tx_flow_ctrl(
        &self,
    ) -> crate::common::Reg<self::MacQ0TxFlowCtrl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(112usize)) }
    }

    #[doc = "MAC Wake up Packet Filter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_rwk_packet_filter(
        &self,
    ) -> crate::common::Reg<self::MacRwkPacketFilter_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(196usize)) }
    }

    #[doc = "MAC Receive Queue Control 0 Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_rxq_ctrl0(
        &self,
    ) -> crate::common::Reg<self::MacRxqCtrl0_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(160usize)) }
    }

    #[doc = "MAC Receive Queue Control 1 Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_rxq_ctrl1(
        &self,
    ) -> crate::common::Reg<self::MacRxqCtrl1_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(164usize)) }
    }

    #[doc = "MAC Receive Queue Control 2 Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_rxq_ctrl2(
        &self,
    ) -> crate::common::Reg<self::MacRxqCtrl2_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(168usize)) }
    }

    #[doc = "MAC Receive Queue Control 4 register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_rxq_ctrl4(
        &self,
    ) -> crate::common::Reg<self::MacRxqCtrl4_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(148usize)) }
    }

    #[doc = "MAC Receive Flow Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_rx_flow_ctrl(
        &self,
    ) -> crate::common::Reg<self::MacRxFlowCtrl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(144usize)) }
    }

    #[doc = "MAC Receive Transmit Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_rx_tx_status(
        &self,
    ) -> crate::common::Reg<self::MacRxTxStatus_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(184usize)) }
    }

    #[doc = "MAC Sub Second Increment Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_sub_second_increment(
        &self,
    ) -> crate::common::Reg<self::MacSubSecondIncrement_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2820usize)) }
    }

    #[doc = "MAC System Time Higher Word Seconds Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_system_time_higher_word_seconds(
        &self,
    ) -> crate::common::Reg<self::MacSystemTimeHigherWordSeconds_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2844usize)) }
    }

    #[doc = "MAC System Time Nanoseconds Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_system_time_nanoseconds(
        &self,
    ) -> crate::common::Reg<self::MacSystemTimeNanoseconds_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2828usize)) }
    }

    #[doc = "MAC System Time Nanoseconds Update Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_system_time_nanoseconds_update(
        &self,
    ) -> crate::common::Reg<self::MacSystemTimeNanosecondsUpdate_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2836usize)) }
    }

    #[doc = "MAC System Time Seconds Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_system_time_seconds(
        &self,
    ) -> crate::common::Reg<self::MacSystemTimeSeconds_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2824usize)) }
    }

    #[doc = "MAC System Time Seconds Update Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_system_time_seconds_update(
        &self,
    ) -> crate::common::Reg<self::MacSystemTimeSecondsUpdate_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2832usize)) }
    }

    #[doc = "MAC Timestamp Addend Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_timestamp_addend(
        &self,
    ) -> crate::common::Reg<self::MacTimestampAddend_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2840usize)) }
    }

    #[doc = "MAC Timestamp Control Register\n resetvalue={Application Reset:0x2000}"]
    #[inline(always)]
    pub const fn mac_timestamp_control(
        &self,
    ) -> crate::common::Reg<self::MacTimestampControl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2816usize)) }
    }

    #[doc = "MAC Timestamp Egress Asymmetry Correction Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_timestamp_egress_asym_corr(
        &self,
    ) -> crate::common::Reg<self::MacTimestampEgressAsymCorr_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2900usize)) }
    }

    #[doc = "MAC Timestamp Egress Correction Nanoseconds Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_timestamp_egress_corr_nanosecond(
        &self,
    ) -> crate::common::Reg<self::MacTimestampEgressCorrNanosecond_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2908usize)) }
    }

    #[doc = "MAC Timestamp Egress Correction Subnanoseconds Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_timestamp_egress_corr_subnanosec(
        &self,
    ) -> crate::common::Reg<self::MacTimestampEgressCorrSubnanosec_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2916usize)) }
    }

    #[doc = "MAC Timestamp Ingress Asymmetry Correction Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_timestamp_ingress_asym_corr(
        &self,
    ) -> crate::common::Reg<self::MacTimestampIngressAsymCorr_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2896usize)) }
    }

    #[doc = "MAC Timestamp Ingress Correction Nanoseconds Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_timestamp_ingress_corr_nanosecond(
        &self,
    ) -> crate::common::Reg<self::MacTimestampIngressCorrNanosecond_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2904usize)) }
    }

    #[doc = "MAC Timestamp Ingress Correction Subnanoseconds Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_timestamp_ingress_corr_subnanosec(
        &self,
    ) -> crate::common::Reg<self::MacTimestampIngressCorrSubnanosec_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2912usize)) }
    }

    #[doc = "MAC Timestamp Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_timestamp_status(
        &self,
    ) -> crate::common::Reg<self::MacTimestampStatus_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2848usize)) }
    }

    #[doc = "MAC Transmit Timestamp Nanoseconds Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_tx_timestamp_status_nanoseconds(
        &self,
    ) -> crate::common::Reg<self::MacTxTimestampStatusNanoseconds_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2864usize)) }
    }

    #[doc = "MAC Transmit Timestamp Seconds Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_tx_timestamp_status_seconds(
        &self,
    ) -> crate::common::Reg<self::MacTxTimestampStatusSeconds_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2868usize)) }
    }

    #[doc = "MAC Version Register\n resetvalue={Application Reset:0x1042,Application Reset:0x1050}"]
    #[inline(always)]
    pub const fn mac_version(&self) -> crate::common::Reg<self::MacVersion_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(272usize)) }
    }

    #[doc = "MAC VLAN Hash Table Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_vlan_hash_table(
        &self,
    ) -> crate::common::Reg<self::MacVlanHashTable_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(88usize)) }
    }

    #[doc = "MAC VLAN Tag Inclusion or Replacement Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_vlan_incl(
        &self,
    ) -> crate::common::Reg<self::MacVlanIncl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(96usize)) }
    }

    #[doc = "MAC VLAN Tag Inclusion or Replacement Register per Queue\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_vlan_incl_q_i(
        &self,
    ) -> crate::common::Reg<self::MacVlanInclQI_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(96usize)) }
    }

    #[doc = "MAC VLAN Tag Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_vlan_tag_ctrl(
        &self,
    ) -> crate::common::Reg<self::MacVlanTagCtrl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(80usize)) }
    }

    #[doc = "MAC VLAN Tag Data Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_vlan_tag_data(
        &self,
    ) -> crate::common::Reg<self::MacVlanTagData_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(84usize)) }
    }

    #[doc = "MAC VLAN Tag Filter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_vlan_tag_filter_i(
        &self,
    ) -> crate::common::Reg<self::MacVlanTagFilterI_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(84usize)) }
    }

    #[doc = "MAC Watchdog Timeout Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mac_watchdog_timeout(
        &self,
    ) -> crate::common::Reg<self::MacWatchdogTimeout_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(12usize)) }
    }

    #[doc = "MMC Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mmc_control(
        &self,
    ) -> crate::common::Reg<self::MmcControl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1792usize)) }
    }

    #[doc = "MMC IPC Receive Interrupts Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mmc_ipc_rx_interrupt(
        &self,
    ) -> crate::common::Reg<self::MmcIpcRxInterrupt_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2056usize)) }
    }

    #[doc = "MMC IPC Receive Interrupts Mask Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mmc_ipc_rx_interrupt_mask(
        &self,
    ) -> crate::common::Reg<self::MmcIpcRxInterruptMask_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2048usize)) }
    }

    #[doc = "MMC Receive Interrupts Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mmc_rx_interrupt(
        &self,
    ) -> crate::common::Reg<self::MmcRxInterrupt_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1796usize)) }
    }

    #[doc = "MMC Receive Interrupts Mask Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mmc_rx_interrupt_mask(
        &self,
    ) -> crate::common::Reg<self::MmcRxInterruptMask_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1804usize)) }
    }

    #[doc = "MMC Transmit Interrupts Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mmc_tx_interrupt(
        &self,
    ) -> crate::common::Reg<self::MmcTxInterrupt_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1800usize)) }
    }

    #[doc = "MMC Transmit Interrupts Mask Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mmc_tx_interrupt_mask(
        &self,
    ) -> crate::common::Reg<self::MmcTxInterruptMask_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1808usize)) }
    }

    #[doc = "MTL Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_interrupt_status(
        &self,
    ) -> crate::common::Reg<self::MtlInterruptStatus_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3104usize)) }
    }

    #[doc = "MTL Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_operation_mode(
        &self,
    ) -> crate::common::Reg<self::MtlOperationMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3072usize)) }
    }

    #[doc = "MTL Queue 3 Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_q1_interrupt_control_status(
        &self,
    ) -> crate::common::Reg<self::MtlQ1InterruptControlStatus_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3436usize)) }
    }

    #[doc = "MTL Queue 3 Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_q2_interrupt_control_status(
        &self,
    ) -> crate::common::Reg<self::MtlQ2InterruptControlStatus_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3500usize)) }
    }

    #[doc = "MTL Queue 3 Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_q3_interrupt_control_status(
        &self,
    ) -> crate::common::Reg<self::MtlQ3InterruptControlStatus_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3564usize)) }
    }

    #[doc = "MTL Queue 3 Receive Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq1_control(
        &self,
    ) -> crate::common::Reg<self::MtlRxq1Control_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3452usize)) }
    }

    #[doc = "MTL Queue 3 Receive Debug Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq1_debug(
        &self,
    ) -> crate::common::Reg<self::MtlRxq1Debug_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3448usize)) }
    }

    #[doc = "MTL Queue 3 Receive Missed Packet and Overflow Counter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq1_missed_packet_overflow_cnt(
        &self,
    ) -> crate::common::Reg<self::MtlRxq1MissedPacketOverflowCnt_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3444usize)) }
    }

    #[doc = "MTL Queue 3 Receive Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq1_operation_mode(
        &self,
    ) -> crate::common::Reg<self::MtlRxq1OperationMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3440usize)) }
    }

    #[doc = "MTL Queue 3 Receive Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq2_control(
        &self,
    ) -> crate::common::Reg<self::MtlRxq2Control_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3516usize)) }
    }

    #[doc = "MTL Queue 3 Receive Debug Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq2_debug(
        &self,
    ) -> crate::common::Reg<self::MtlRxq2Debug_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3512usize)) }
    }

    #[doc = "MTL Queue 3 Receive Missed Packet and Overflow Counter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq2_missed_packet_overflow_cnt(
        &self,
    ) -> crate::common::Reg<self::MtlRxq2MissedPacketOverflowCnt_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3508usize)) }
    }

    #[doc = "MTL Queue 3 Receive Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq2_operation_mode(
        &self,
    ) -> crate::common::Reg<self::MtlRxq2OperationMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3504usize)) }
    }

    #[doc = "MTL Queue 3 Receive Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq3_control(
        &self,
    ) -> crate::common::Reg<self::MtlRxq3Control_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3580usize)) }
    }

    #[doc = "MTL Queue 3 Receive Debug Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq3_debug(
        &self,
    ) -> crate::common::Reg<self::MtlRxq3Debug_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3576usize)) }
    }

    #[doc = "MTL Queue 3 Receive Missed Packet and Overflow Counter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq3_missed_packet_overflow_cnt(
        &self,
    ) -> crate::common::Reg<self::MtlRxq3MissedPacketOverflowCnt_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3572usize)) }
    }

    #[doc = "MTL Queue 3 Receive Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq3_operation_mode(
        &self,
    ) -> crate::common::Reg<self::MtlRxq3OperationMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3568usize)) }
    }

    #[doc = "MTL Receive Queue and DMA Channel Mapping 0 Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq_dma_map0(
        &self,
    ) -> crate::common::Reg<self::MtlRxqDmaMap0_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3120usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Debug Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq1_debug(
        &self,
    ) -> crate::common::Reg<self::MtlTxq1Debug_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3400usize)) }
    }

    #[doc = "MTL Queue 3 Transmit ETS Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq1_ets_control(
        &self,
    ) -> crate::common::Reg<self::MtlTxq1EtsControl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3408usize)) }
    }

    #[doc = "MTL Queue 3 Transmit ETS Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq1_ets_status(
        &self,
    ) -> crate::common::Reg<self::MtlTxq1EtsStatus_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3412usize)) }
    }

    #[doc = "MTL Queue 3 Transmit HiCredit Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq1_hicredit(
        &self,
    ) -> crate::common::Reg<self::MtlTxq1Hicredit_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3424usize)) }
    }

    #[doc = "MTL Queue 3 Transmit LoCredit Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq1_locredit(
        &self,
    ) -> crate::common::Reg<self::MtlTxq1Locredit_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3428usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq1_operation_mode(
        &self,
    ) -> crate::common::Reg<self::MtlTxq1OperationMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3392usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Quantum or Weights Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq1_quantum_weight(
        &self,
    ) -> crate::common::Reg<self::MtlTxq1QuantumWeight_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3416usize)) }
    }

    #[doc = "MTL Queue 3 Transmit SendSlopeCredit Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq1_sendslopecredit(
        &self,
    ) -> crate::common::Reg<self::MtlTxq1Sendslopecredit_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3420usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Underflow Counter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq1_underflow(
        &self,
    ) -> crate::common::Reg<self::MtlTxq1Underflow_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3396usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Debug Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq2_debug(
        &self,
    ) -> crate::common::Reg<self::MtlTxq2Debug_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3464usize)) }
    }

    #[doc = "MTL Queue 3 Transmit ETS Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq2_ets_control(
        &self,
    ) -> crate::common::Reg<self::MtlTxq2EtsControl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3472usize)) }
    }

    #[doc = "MTL Queue 3 Transmit ETS Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq2_ets_status(
        &self,
    ) -> crate::common::Reg<self::MtlTxq2EtsStatus_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3476usize)) }
    }

    #[doc = "MTL Queue 3 Transmit HiCredit Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq2_hicredit(
        &self,
    ) -> crate::common::Reg<self::MtlTxq2Hicredit_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3488usize)) }
    }

    #[doc = "MTL Queue 3 Transmit LoCredit Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq2_locredit(
        &self,
    ) -> crate::common::Reg<self::MtlTxq2Locredit_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3492usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq2_operation_mode(
        &self,
    ) -> crate::common::Reg<self::MtlTxq2OperationMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3456usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Quantum or Weights Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq2_quantum_weight(
        &self,
    ) -> crate::common::Reg<self::MtlTxq2QuantumWeight_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3480usize)) }
    }

    #[doc = "MTL Queue 3 Transmit SendSlopeCredit Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq2_sendslopecredit(
        &self,
    ) -> crate::common::Reg<self::MtlTxq2Sendslopecredit_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3484usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Underflow Counter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq2_underflow(
        &self,
    ) -> crate::common::Reg<self::MtlTxq2Underflow_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3460usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Debug Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq3_debug(
        &self,
    ) -> crate::common::Reg<self::MtlTxq3Debug_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3528usize)) }
    }

    #[doc = "MTL Queue 3 Transmit ETS Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq3_ets_control(
        &self,
    ) -> crate::common::Reg<self::MtlTxq3EtsControl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3536usize)) }
    }

    #[doc = "MTL Queue 3 Transmit ETS Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq3_ets_status(
        &self,
    ) -> crate::common::Reg<self::MtlTxq3EtsStatus_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3540usize)) }
    }

    #[doc = "MTL Queue 3 Transmit HiCredit Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq3_hicredit(
        &self,
    ) -> crate::common::Reg<self::MtlTxq3Hicredit_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3552usize)) }
    }

    #[doc = "MTL Queue 3 Transmit LoCredit Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq3_locredit(
        &self,
    ) -> crate::common::Reg<self::MtlTxq3Locredit_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3556usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq3_operation_mode(
        &self,
    ) -> crate::common::Reg<self::MtlTxq3OperationMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3520usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Quantum or Weights Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq3_quantum_weight(
        &self,
    ) -> crate::common::Reg<self::MtlTxq3QuantumWeight_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3544usize)) }
    }

    #[doc = "MTL Queue 3 Transmit SendSlopeCredit Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq3_sendslopecredit(
        &self,
    ) -> crate::common::Reg<self::MtlTxq3Sendslopecredit_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3548usize)) }
    }

    #[doc = "MTL Queue 3 Transmit Underflow Counter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq3_underflow(
        &self,
    ) -> crate::common::Reg<self::MtlTxq3Underflow_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(3524usize)) }
    }

    #[doc = "MAC Wake up Filter Byte Mask register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rwk_filter_byte_mask_i(
        &self,
    ) -> crate::common::Reg<self::RwkFilterByteMaskI_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(196usize)) }
    }

    #[doc = "MAC Wake up Filter Command 0 Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rwk_filter_command_0(
        &self,
    ) -> crate::common::Reg<self::RwkFilterCommand0_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(196usize)) }
    }

    #[doc = "MAC Wake up Filter CRC Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rwk_filter_crc_i(
        &self,
    ) -> crate::common::Reg<self::RwkFilterCrcI_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(196usize)) }
    }

    #[doc = "MAC Wake up Filter Offset 0 Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rwk_filter_offset_0(
        &self,
    ) -> crate::common::Reg<self::RwkFilterOffset0_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(196usize)) }
    }

    #[doc = "Received ICMP Error Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxicmp_error_octets(
        &self,
    ) -> crate::common::Reg<self::RxicmpErrorOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2180usize)) }
    }

    #[doc = "Received ICMP Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxicmp_error_packets(
        &self,
    ) -> crate::common::Reg<self::RxicmpErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2116usize)) }
    }

    #[doc = "Good Received ICMP Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxicmp_good_octets(
        &self,
    ) -> crate::common::Reg<self::RxicmpGoodOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2176usize)) }
    }

    #[doc = "Good Received ICMP Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxicmp_good_packets(
        &self,
    ) -> crate::common::Reg<self::RxicmpGoodPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2112usize)) }
    }

    #[doc = "Received IPV4 Fragmented Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv4_fragmented_octets(
        &self,
    ) -> crate::common::Reg<self::Rxipv4FragmentedOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2140usize)) }
    }

    #[doc = "Received IPv4 Fragmented Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv4_fragmented_packets(
        &self,
    ) -> crate::common::Reg<self::Rxipv4FragmentedPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2076usize)) }
    }

    #[doc = "Good Received IPV4 Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv4_good_octets(
        &self,
    ) -> crate::common::Reg<self::Rxipv4GoodOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2128usize)) }
    }

    #[doc = "Good Received RxIPv4 Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv4_good_packets(
        &self,
    ) -> crate::common::Reg<self::Rxipv4GoodPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2064usize)) }
    }

    #[doc = "Received IPV4 Header Error Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv4_header_error_octets(
        &self,
    ) -> crate::common::Reg<self::Rxipv4HeaderErrorOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2132usize)) }
    }

    #[doc = "Received IPv4 Header Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv4_header_error_packets(
        &self,
    ) -> crate::common::Reg<self::Rxipv4HeaderErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2068usize)) }
    }

    #[doc = "Received IPV4 No Payload Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv4_no_payload_octets(
        &self,
    ) -> crate::common::Reg<self::Rxipv4NoPayloadOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2136usize)) }
    }

    #[doc = "Received IPv4 No Payload Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv4_no_payload_packets(
        &self,
    ) -> crate::common::Reg<self::Rxipv4NoPayloadPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2072usize)) }
    }

    #[doc = "Received IPv4 UPD Checksum Disabled Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv4_udp_checksum_disabled_packets(
        &self,
    ) -> crate::common::Reg<self::Rxipv4UdpChecksumDisabledPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2080usize)) }
    }

    #[doc = "Received IPV4 UPD Checksum Disabled Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv4_udp_checksum_disable_octets(
        &self,
    ) -> crate::common::Reg<self::Rxipv4UdpChecksumDisableOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2144usize)) }
    }

    #[doc = "Good Received IPV6 Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv6_good_octets(
        &self,
    ) -> crate::common::Reg<self::Rxipv6GoodOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2148usize)) }
    }

    #[doc = "Good Received RxIPv6 Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv6_good_packets(
        &self,
    ) -> crate::common::Reg<self::Rxipv6GoodPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2084usize)) }
    }

    #[doc = "Received IPV6 Header Error Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv6_header_error_octets(
        &self,
    ) -> crate::common::Reg<self::Rxipv6HeaderErrorOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2152usize)) }
    }

    #[doc = "Received IPv6 Header Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv6_header_error_packets(
        &self,
    ) -> crate::common::Reg<self::Rxipv6HeaderErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2088usize)) }
    }

    #[doc = "Received IPV6 No Payload Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv6_no_payload_octets(
        &self,
    ) -> crate::common::Reg<self::Rxipv6NoPayloadOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2156usize)) }
    }

    #[doc = "Received IPv6 No Payload Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxipv6_no_payload_packets(
        &self,
    ) -> crate::common::Reg<self::Rxipv6NoPayloadPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2092usize)) }
    }

    #[doc = "Received TCP Error Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxtcp_error_octets(
        &self,
    ) -> crate::common::Reg<self::RxtcpErrorOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2172usize)) }
    }

    #[doc = "Received TCP Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxtcp_error_packets(
        &self,
    ) -> crate::common::Reg<self::RxtcpErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2108usize)) }
    }

    #[doc = "Good Received TCP Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxtcp_good_octets(
        &self,
    ) -> crate::common::Reg<self::RxtcpGoodOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2168usize)) }
    }

    #[doc = "Good Received TCP Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxtcp_good_packets(
        &self,
    ) -> crate::common::Reg<self::RxtcpGoodPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2104usize)) }
    }

    #[doc = "Received UDP Error Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxudp_error_octets(
        &self,
    ) -> crate::common::Reg<self::RxudpErrorOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2164usize)) }
    }

    #[doc = "Received UDP Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxudp_error_packets(
        &self,
    ) -> crate::common::Reg<self::RxudpErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2100usize)) }
    }

    #[doc = "Good Received UDP Octets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxudp_good_octets(
        &self,
    ) -> crate::common::Reg<self::RxudpGoodOctets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2160usize)) }
    }

    #[doc = "Good Received UDP Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rxudp_good_packets(
        &self,
    ) -> crate::common::Reg<self::RxudpGoodPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2096usize)) }
    }

    #[doc = "Good And Bad 1024toMax Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_1024tomaxoctets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Rx1024TomaxoctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1984usize)) }
    }

    #[doc = "Good And Bad 128to255 Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_128to255octets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Rx128To255OctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1972usize)) }
    }

    #[doc = "Good And Bad 256to511 Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_256to511octets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Rx256To511OctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1976usize)) }
    }

    #[doc = "Good And Bad 512to1023 Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_512to1023octets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Rx512To1023OctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1980usize)) }
    }

    #[doc = "Good And Bad 64 Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_64octets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Rx64OctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1964usize)) }
    }

    #[doc = "Good And Bad 65to127 Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_65to127octets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Rx65To127OctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1968usize)) }
    }

    #[doc = "Received Alignment Error Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_alignment_error_packets(
        &self,
    ) -> crate::common::Reg<self::RxAlignmentErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1944usize)) }
    }

    #[doc = "Good Received Broadcast Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_broadcast_packets_good(
        &self,
    ) -> crate::common::Reg<self::RxBroadcastPacketsGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1932usize)) }
    }

    #[doc = "Good Received Control Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_control_packets_good(
        &self,
    ) -> crate::common::Reg<self::RxControlPacketsGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2020usize)) }
    }

    #[doc = "Received CRC Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_crc_error_packets(
        &self,
    ) -> crate::common::Reg<self::RxCrcErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1940usize)) }
    }

    #[doc = "Received FIFO Overflow Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_fifo_overflow_packets(
        &self,
    ) -> crate::common::Reg<self::RxFifoOverflowPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2004usize)) }
    }

    #[doc = "Received Jabber Error Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_jabber_error_packets(
        &self,
    ) -> crate::common::Reg<self::RxJabberErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1952usize)) }
    }

    #[doc = "Received Length Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_length_error_packets(
        &self,
    ) -> crate::common::Reg<self::RxLengthErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1992usize)) }
    }

    #[doc = "Received LPI Transition Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_lpi_tran_cntr(
        &self,
    ) -> crate::common::Reg<self::RxLpiTranCntr_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2040usize)) }
    }

    #[doc = "Received Microseconds LPI Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_lpi_usec_cntr(
        &self,
    ) -> crate::common::Reg<self::RxLpiUsecCntr_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2036usize)) }
    }

    #[doc = "Good Received Multicast Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_multicast_packets_good(
        &self,
    ) -> crate::common::Reg<self::RxMulticastPacketsGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1936usize)) }
    }

    #[doc = "Good Received Octet Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_octet_count_good(
        &self,
    ) -> crate::common::Reg<self::RxOctetCountGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1928usize)) }
    }

    #[doc = "Good And Bad Received Octet Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_octet_count_good_bad(
        &self,
    ) -> crate::common::Reg<self::RxOctetCountGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1924usize)) }
    }

    #[doc = "Received Out Of Range Type Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_out_of_range_type_packets(
        &self,
    ) -> crate::common::Reg<self::RxOutOfRangeTypePackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1996usize)) }
    }

    #[doc = "Good Received Oversized Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_oversize_packets_good(
        &self,
    ) -> crate::common::Reg<self::RxOversizePacketsGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1960usize)) }
    }

    #[doc = "Good And Bad Received Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_packets_count_good_bad(
        &self,
    ) -> crate::common::Reg<self::RxPacketsCountGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1920usize)) }
    }

    #[doc = "Received Pause Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_pause_packets(
        &self,
    ) -> crate::common::Reg<self::RxPausePackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2000usize)) }
    }

    #[doc = "Received Receive Error Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_receive_error_packets(
        &self,
    ) -> crate::common::Reg<self::RxReceiveErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2016usize)) }
    }

    #[doc = "Received Runtime Error Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_runt_error_packets(
        &self,
    ) -> crate::common::Reg<self::RxRuntErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1948usize)) }
    }

    #[doc = "Good Received Undersized Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_undersize_packets_good(
        &self,
    ) -> crate::common::Reg<self::RxUndersizePacketsGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1956usize)) }
    }

    #[doc = "Good Received Unicat Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_unicast_packets_good(
        &self,
    ) -> crate::common::Reg<self::RxUnicastPacketsGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1988usize)) }
    }

    #[doc = "Good And Bad Received VLAN Packets Count Registerv\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_vlan_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::RxVlanPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2008usize)) }
    }

    #[doc = "Received Watchdog Error Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn rx_watchdog_error_packets(
        &self,
    ) -> crate::common::Reg<self::RxWatchdogErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2012usize)) }
    }

    #[doc = "Skew Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn skewctl(&self) -> crate::common::Reg<self::Skewctl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8256usize)) }
    }

    #[doc = "Good And Bad 1024toMax Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_1024tomaxoctets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Tx1024TomaxoctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1848usize)) }
    }

    #[doc = "Good And Bad 128to255 Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_128to255octets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Tx128To255OctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1836usize)) }
    }

    #[doc = "Good And Bad 256to511 Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_256to511octets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Tx256To511OctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1840usize)) }
    }

    #[doc = "Good And Bad 512to1023 Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_512to1023octets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Tx512To1023OctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1844usize)) }
    }

    #[doc = "Good And Bad 64 Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_64octets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Tx64OctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1828usize)) }
    }

    #[doc = "Good And Bad 65to127 Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_65to127octets_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::Tx65To127OctetsPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1832usize)) }
    }

    #[doc = "Good Transmitted Broadcast Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_broadcast_packets_good(
        &self,
    ) -> crate::common::Reg<self::TxBroadcastPacketsGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1820usize)) }
    }

    #[doc = "Good And Bad Transmitted Broadcast Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_broadcast_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::TxBroadcastPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1860usize)) }
    }

    #[doc = "Transmitted Carrier Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_carrier_error_packets(
        &self,
    ) -> crate::common::Reg<self::TxCarrierErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1888usize)) }
    }

    #[doc = "Transmitted Deferred Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_deferred_packets(
        &self,
    ) -> crate::common::Reg<self::TxDeferredPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1876usize)) }
    }

    #[doc = "Transmitted Excessive Collision Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_excessive_collision_packets(
        &self,
    ) -> crate::common::Reg<self::TxExcessiveCollisionPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1884usize)) }
    }

    #[doc = "Transmitted Excessive Deferral Error Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_excessive_deferral_error(
        &self,
    ) -> crate::common::Reg<self::TxExcessiveDeferralError_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1900usize)) }
    }

    #[doc = "Transmitted Late Collision Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_late_collision_packets(
        &self,
    ) -> crate::common::Reg<self::TxLateCollisionPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1880usize)) }
    }

    #[doc = "Transmitted LPI Transition Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_lpi_tran_cntr(
        &self,
    ) -> crate::common::Reg<self::TxLpiTranCntr_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2032usize)) }
    }

    #[doc = "Transmitted LPI Microseconds Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_lpi_usec_cntr(
        &self,
    ) -> crate::common::Reg<self::TxLpiUsecCntr_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(2028usize)) }
    }

    #[doc = "Good Transmitted Multicast Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_multicast_packets_good(
        &self,
    ) -> crate::common::Reg<self::TxMulticastPacketsGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1824usize)) }
    }

    #[doc = "Good And Bad Transmitted Multicast Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_multicast_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::TxMulticastPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1856usize)) }
    }

    #[doc = "Transmitted Multiple Collision Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_multiple_collision_good_packets(
        &self,
    ) -> crate::common::Reg<self::TxMultipleCollisionGoodPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1872usize)) }
    }

    #[doc = "Good Transmitted Octet Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_octet_count_good(
        &self,
    ) -> crate::common::Reg<self::TxOctetCountGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1892usize)) }
    }

    #[doc = "Good And Bad Transmitted Octet Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_octet_count_good_bad(
        &self,
    ) -> crate::common::Reg<self::TxOctetCountGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1812usize)) }
    }

    #[doc = "Good Transmitted Osize Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_osize_packets_good(
        &self,
    ) -> crate::common::Reg<self::TxOsizePacketsGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1912usize)) }
    }

    #[doc = "Good Transmitted Packet Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_packet_count_good(
        &self,
    ) -> crate::common::Reg<self::TxPacketCountGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1896usize)) }
    }

    #[doc = "Good And Bad Transmitted Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_packet_count_good_bad(
        &self,
    ) -> crate::common::Reg<self::TxPacketCountGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1816usize)) }
    }

    #[doc = "Transmitted Pause Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_pause_packets(
        &self,
    ) -> crate::common::Reg<self::TxPausePackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1904usize)) }
    }

    #[doc = "Good Transmitted Single Collision Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_single_collision_good_packets(
        &self,
    ) -> crate::common::Reg<self::TxSingleCollisionGoodPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1868usize)) }
    }

    #[doc = "Transmitted Underflow Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_underflow_error_packets(
        &self,
    ) -> crate::common::Reg<self::TxUnderflowErrorPackets_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1864usize)) }
    }

    #[doc = "Good Transmitted Unicat Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_unicast_packets_good_bad(
        &self,
    ) -> crate::common::Reg<self::TxUnicastPacketsGoodBad_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1852usize)) }
    }

    #[doc = "Good Transmitted VLAN Packets Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn tx_vlan_packets_good(
        &self,
    ) -> crate::common::Reg<self::TxVlanPacketsGood_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(1908usize)) }
    }
    #[doc = "ACCEND"]
    #[inline(always)]
    pub fn accend(self) -> [self::Accend; 4] {
        unsafe {
            [
                self::Accend(self.0.add(0x2020usize + 0x0usize)),
                self::Accend(self.0.add(0x2020usize + 0x8usize)),
                self::Accend(self.0.add(0x2020usize + 0x10usize)),
                self::Accend(self.0.add(0x2020usize + 0x18usize)),
            ]
        }
    }
    #[doc = "DMA CH"]
    #[inline(always)]
    pub fn dma_ch(self) -> [self::DmaCh; 4] {
        unsafe {
            [
                self::DmaCh(self.0.add(0x1100usize + 0x0usize)),
                self::DmaCh(self.0.add(0x1100usize + 0x80usize)),
                self::DmaCh(self.0.add(0x1100usize + 0x100usize)),
                self::DmaCh(self.0.add(0x1100usize + 0x180usize)),
            ]
        }
    }
    #[doc = "MTL Q0"]
    #[inline(always)]
    pub fn mtl_q0(self) -> self::MtlQ0 {
        unsafe { self::MtlQ0(self.0.add(3372usize)) }
    }
    #[doc = "MTL RXQ0"]
    #[inline(always)]
    pub fn mtl_rxq0(self) -> self::MtlRxq0 {
        unsafe { self::MtlRxq0(self.0.add(3376usize)) }
    }
    #[doc = "MTL TXQ0"]
    #[inline(always)]
    pub fn mtl_txq0(self) -> self::MtlTxq0 {
        unsafe { self::MtlTxq0(self.0.add(3328usize)) }
    }
}
#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Accen0_SPEC;
impl crate::sealed::RegSpec for Accen0_SPEC {
    type DataType = u32;
}
#[doc = "Access Enable Register 0\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type Accen0 = crate::RegValueT<Accen0_SPEC>;

impl Accen0 {
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en0(self) -> crate::common::RegisterFieldBool<0, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en1(self) -> crate::common::RegisterFieldBool<1, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en2(self) -> crate::common::RegisterFieldBool<2, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<2, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en3(self) -> crate::common::RegisterFieldBool<3, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en4(self) -> crate::common::RegisterFieldBool<4, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<4, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en5(self) -> crate::common::RegisterFieldBool<5, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<5, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en6(self) -> crate::common::RegisterFieldBool<6, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<6, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en7(self) -> crate::common::RegisterFieldBool<7, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<7, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en8(self) -> crate::common::RegisterFieldBool<8, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<8, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en9(self) -> crate::common::RegisterFieldBool<9, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<9, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en10(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<10, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en11(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<11, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en12(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<12, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en13(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<13, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en14(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<14, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en15(
        self,
    ) -> crate::common::RegisterFieldBool<15, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<15, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en16(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<16, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en17(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<17, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en18(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<18, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en19(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<19, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en20(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<20, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en21(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<21, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en22(
        self,
    ) -> crate::common::RegisterFieldBool<22, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<22, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en23(
        self,
    ) -> crate::common::RegisterFieldBool<23, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<23, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en24(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<24, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en25(
        self,
    ) -> crate::common::RegisterFieldBool<25, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<25, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en26(
        self,
    ) -> crate::common::RegisterFieldBool<26, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<26, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en27(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<27, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en28(
        self,
    ) -> crate::common::RegisterFieldBool<28, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<28, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en29(
        self,
    ) -> crate::common::RegisterFieldBool<29, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<29, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en30(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n"]
    #[inline(always)]
    pub fn en31(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, Accen0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31, 1, 0, Accen0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
}
impl core::default::Default for Accen0 {
    #[inline(always)]
    fn default() -> Accen0 {
        <crate::RegValueT<Accen0_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Clc_SPEC;
impl crate::sealed::RegSpec for Clc_SPEC {
    type DataType = u32;
}
#[doc = "Clock Control Register\n resetvalue={Application Reset:0x3}"]
pub type Clc = crate::RegValueT<Clc_SPEC>;

impl Clc {
    #[doc = "Module Disable Request Bit   DISR. Used for enable disable control of the module.  The disable request is delayed internally until all pending transactions on the master  SRI  and slave  SPB  interface are completed."]
    #[inline(always)]
    pub fn disr(self) -> crate::common::RegisterFieldBool<0, 1, 0, Clc_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0, 1, 0, Clc_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Module Disable Status Bit   DISS. Bit indicates the current status of the module."]
    #[inline(always)]
    pub fn diss(self) -> crate::common::RegisterFieldBool<1, 1, 0, Clc_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1, 1, 0, Clc_SPEC, crate::common::R>::from_register(
            self, 0,
        )
    }
}
impl core::default::Default for Clc {
    #[inline(always)]
    fn default() -> Clc {
        <crate::RegValueT<Clc_SPEC> as RegisterValue<_>>::new(3)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DmaDebugStatus0_SPEC;
impl crate::sealed::RegSpec for DmaDebugStatus0_SPEC {
    type DataType = u32;
}
#[doc = "DMA Debug Status 0 Register\n resetvalue={Application Reset:0x0}"]
pub type DmaDebugStatus0 = crate::RegValueT<DmaDebugStatus0_SPEC>;

impl DmaDebugStatus0 {
    #[doc = "AHB Master Status   AXWHSTS. When high  this bit indicates that the AHB master FSMs are in the non idle state. Value After Reset  0x0"]
    #[inline(always)]
    pub fn axwhsts(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, DmaDebugStatus0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,DmaDebugStatus0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Channel 0 Receive Process State   RPS0. This field indicates the Rx DMA FSM state for Channel 0  The MSB of this field always returns 0. This field does not generate an interrupt. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rps0(
        self,
    ) -> crate::common::RegisterField<8, 0xf, 1, 0, u8, DmaDebugStatus0_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<8,0xf,1,0,u8, DmaDebugStatus0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Channel 0 Transmit Process State   TPS0. This field indicates the Tx DMA FSM state for Channel 0  The MSB of this field always returns 0. This field does not generate an interrupt. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tps0(
        self,
    ) -> crate::common::RegisterField<12, 0xf, 1, 0, u8, DmaDebugStatus0_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<12,0xf,1,0,u8, DmaDebugStatus0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Channel 1 Receive Process State   RPS1. This field indicates the Rx DMA FSM state for Channel 1. This field is similar to the RPS0 field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rps1(
        self,
    ) -> crate::common::RegisterField<16, 0xf, 1, 0, u8, DmaDebugStatus0_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<16,0xf,1,0,u8, DmaDebugStatus0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Channel 1 Transmit Process State   TPS1. This field indicates the Tx DMA FSM state for Channel 1. This field is similar to the TPS0 field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tps1(
        self,
    ) -> crate::common::RegisterField<20, 0xf, 1, 0, u8, DmaDebugStatus0_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<20,0xf,1,0,u8, DmaDebugStatus0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Channel 2 Receive Process State   RPS2. This field indicates the Rx DMA FSM state for Channel 2. This field is similar to the RPS0 field Value After Reset  0x0"]
    #[inline(always)]
    pub fn rps2(
        self,
    ) -> crate::common::RegisterField<24, 0xf, 1, 0, u8, DmaDebugStatus0_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<24,0xf,1,0,u8, DmaDebugStatus0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Channel 2 Transmit Process State   TPS2. This field indicates the Tx DMA FSM state for Channel 2. This field is similar to the TPS0 field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tps2(
        self,
    ) -> crate::common::RegisterField<28, 0xf, 1, 0, u8, DmaDebugStatus0_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<28,0xf,1,0,u8, DmaDebugStatus0_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for DmaDebugStatus0 {
    #[inline(always)]
    fn default() -> DmaDebugStatus0 {
        <crate::RegValueT<DmaDebugStatus0_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DmaDebugStatus1_SPEC;
impl crate::sealed::RegSpec for DmaDebugStatus1_SPEC {
    type DataType = u32;
}
#[doc = "DMA Debug Status 1 Register\n resetvalue={Application Reset:0x0}"]
pub type DmaDebugStatus1 = crate::RegValueT<DmaDebugStatus1_SPEC>;

impl DmaDebugStatus1 {
    #[doc = "DMA Channel 3 Receive Process State   RPS3. This field indicates the Rx DMA FSM state for Channel 3. This field is similar to the RPS6 field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rps3(
        self,
    ) -> crate::common::RegisterField<0, 0xf, 1, 0, u8, DmaDebugStatus1_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xf,1,0,u8, DmaDebugStatus1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Channel 3 Transmit Process State   TPS3. This field indicates the Tx DMA FSM state for Channel 3. This field is similar to the TPS6 field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tps3(
        self,
    ) -> crate::common::RegisterField<4, 0xf, 1, 0, u8, DmaDebugStatus1_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<4,0xf,1,0,u8, DmaDebugStatus1_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for DmaDebugStatus1 {
    #[inline(always)]
    fn default() -> DmaDebugStatus1 {
        <crate::RegValueT<DmaDebugStatus1_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DmaInterruptStatus_SPEC;
impl crate::sealed::RegSpec for DmaInterruptStatus_SPEC {
    type DataType = u32;
}
#[doc = "DMA Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
pub type DmaInterruptStatus = crate::RegValueT<DmaInterruptStatus_SPEC>;

impl DmaInterruptStatus {
    #[doc = "DMA Channel 0 Interrupt Status   DC0IS. This bit indicates an interrupt event in DMA Channel 0. To reset this bit to 1 b0  the software must read the corresponding register in DMA Channel 0 to get the exact cause of the interrupt and clear its source. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dc0is(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, DmaInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,DmaInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Channel 1 Interrupt Status   DC1IS. This bit indicates an interrupt event in DMA Channel 1. To reset this bit to 1 b0  the software must read the corresponding register in DMA Channel 1 to get the exact cause of the interrupt and clear its source. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dc1is(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, DmaInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1,1,0,DmaInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Channel 2 Interrupt Status   DC2IS. This bit indicates an interrupt event in DMA Channel 2. To reset this bit to 1 b0  the software must read the corresponding register in DMA Channel 2 to get the exact cause of the interrupt and clear its source. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dc2is(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, DmaInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<2,1,0,DmaInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Channel 3 Interrupt Status   DC3IS. This bit indicates an interrupt event in DMA Channel 3. To reset this bit to 1 b0  the software must read the corresponding register in DMA Channel 3 to get the exact cause of the interrupt and clear its source. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dc3is(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, DmaInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,DmaInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Interrupt Status   MTLIS. This bit indicates an interrupt event in the MTL. To reset this bit to 1 b0  the software must read the corresponding register in the MTL to get the exact cause of the interrupt and clear its source. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mtlis(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, DmaInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<16,1,0,DmaInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MAC Interrupt Status   MACIS. This bit indicates an interrupt event in the MAC. To reset this bit to 1 b0  the software must read the corresponding register in the MAC to get the exact cause of the interrupt and clear its source. Value After Reset  0x0"]
    #[inline(always)]
    pub fn macis(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, DmaInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<17,1,0,DmaInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for DmaInterruptStatus {
    #[inline(always)]
    fn default() -> DmaInterruptStatus {
        <crate::RegValueT<DmaInterruptStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DmaMode_SPEC;
impl crate::sealed::RegSpec for DmaMode_SPEC {
    type DataType = u32;
}
#[doc = "DMA Bus Mode Register\n resetvalue={Application Reset:0x0}"]
pub type DmaMode = crate::RegValueT<DmaMode_SPEC>;

impl DmaMode {
    #[doc = "Software Reset   SWR. When this bit is set  the MAC and the DMA controller reset the logic and        all internal registers of the DMA  MTL  and MAC. This bit is        automatically cleared after the reset operation is complete in all        DWC ether qos clock domains. Before reprogramming any DWC ether qos        register  a value of zero should be read in this bit. This bit must be        read at least 4 CSR clock cycles after it is written to 1. Note   The reset operation is complete only        when all resets in all active clock domains are de asserted. Therefore         it is essential that all PHY inputs clocks  applicable for the selected        PHY interface  are present for software reset completion. The time to        complete the software reset operation depends on the frequency of the        slowest active clock. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has        no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn swr(self) -> crate::common::RegisterFieldBool<0, 1, 0, DmaMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0, 1, 0, DmaMode_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "DMA Tx or Rx Arbitration Scheme   DA. This bit specifies the arbitration scheme between the Transmit and Receive paths of all channels  The priority between the paths is according to the priority specified in Bits 14 12  and the priority weight is specified in the TXPR bit. The Tx path has priority over the Rx path when the TXPR bit is set. Otherwise  the Rx path has priority over the Tx path. Value After Reset  0x0"]
    #[inline(always)]
    pub fn da(self) -> crate::common::RegisterFieldBool<1, 1, 0, DmaMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1, 1, 0, DmaMode_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Transmit Arbitration Algorithm   TAA. This field is used to select the arbitration algorithm for the Transmit        side when multiple Tx DMAs are selected. 011   111 Reserved Value After Reset  0x0"]
    #[inline(always)]
    pub fn taa(
        self,
    ) -> crate::common::RegisterField<2, 0x7, 1, 0, u8, DmaMode_SPEC, crate::common::RW> {
        crate::common::RegisterField::<2,0x7,1,0,u8, DmaMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Arbitration Control   ARBC. When this bit is reset to 0  the DMA arbitrates as soon as the current burst transaction is completed. So  in this mode  the arbiter will miss the next subsequent request from the same DMA since there are inherent delays between the completion of 1 transfer request and the next transaction request generated from the same DMA. Consequently  the WRR ratio becomes 1 1 irrespective of the programmed ratio. When this bit is set to 1  the DMA arbitration is delayed for a few clock cycles after the completion of current transaction so that the next request from the same DMA can be considered. This allows the arbiter to maintain WRR ratio as programmed."]
    #[inline(always)]
    pub fn arbc(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, DmaMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<9, 1, 0, DmaMode_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Transmit Priority   TXPR. When set  this bit indicates that the Tx DMA has higher priority than        the Rx DMA during arbitration for the system side bus. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txpr(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, DmaMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<11, 1, 0, DmaMode_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Priority Ratio   PR. These bits control the priority ratio in weighted round robin arbitration between the Rx DMA and Tx DMA. These bits are valid only when the DA bit is reset. The priority ratio is Rx Tx or Tx Rx depending on whether the TXPR bit is reset or set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn pr(
        self,
    ) -> crate::common::RegisterField<12, 0x7, 1, 0, u8, DmaMode_SPEC, crate::common::RW> {
        crate::common::RegisterField::<12,0x7,1,0,u8, DmaMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Interrupt Mode   INTM. This field defines the interrupt mode of DWC ether qos. The behavior of the following outputs changes depending on the following        settings  sbd perch tx intr o    Transmit Per Channel Interrupt  sbd perch rx intr o    Receive Per Channel Interrupt  sbd intr o  Common Interrupt  It also changes the behavior of the RI TI bits in the DMA CH0 Status.        For more details please refer Table  quot DWC ether qos Transfer Complete        Interrupt Behavior quot . Value After Reset  0x0"]
    #[inline(always)]
    pub fn intm(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, DmaMode_SPEC, crate::common::RW> {
        crate::common::RegisterField::<16,0x3,1,0,u8, DmaMode_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for DmaMode {
    #[inline(always)]
    fn default() -> DmaMode {
        <crate::RegValueT<DmaMode_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DmaSysbusMode_SPEC;
impl crate::sealed::RegSpec for DmaSysbusMode_SPEC {
    type DataType = u32;
}
#[doc = "DMA System Bus Mode Register\n resetvalue={Application Reset:0x0}"]
pub type DmaSysbusMode = crate::RegValueT<DmaSysbusMode_SPEC>;

impl DmaSysbusMode {
    #[doc = "Fixed Burst Length   FB. When this bit is set to 1  the AHB master  initiates burst transfers of specified length  INCRx or SINGLE . When this bit is set to 0  the AHB master initiates transfers of unspecified length  INCR  or SINGLE transfers. Value After Reset  0x0"]
    #[inline(always)]
    pub fn fb(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, DmaSysbusMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,DmaSysbusMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Aligned Beats   AAL. When this bit is set to 1  the EQOS AXI or EQOS AHB master performs address aligned burst transfers on Read and Write channels. Value After Reset  0x0"]
    #[inline(always)]
    pub fn aal(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, DmaSysbusMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<12,1,0,DmaSysbusMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mixed Burst   MB. When this bit is set high and the FB bit is low  the AHB master performs undefined bursts transfers  INCR  for burst length of 16 or more. For burst length of 16 or less  the AHB master performs fixed burst transfers  INCRx and SINGLE . Value After Reset  0x0"]
    #[inline(always)]
    pub fn mb(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, DmaSysbusMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<14,1,0,DmaSysbusMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Rebuild INCRx Burst   RB. When this bit is set high and the AHB master gets SPLIT  RETRY  or Early Burst Termination  EBT  response  the AHB master interface rebuilds the pending beats of any initiated burst transfer with INCRx and SINGLE transfers. By default  the AHB master interface rebuilds pending beats of an EBT with an unspecified  INCR  burst. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rb(
        self,
    ) -> crate::common::RegisterFieldBool<15, 1, 0, DmaSysbusMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<15,1,0,DmaSysbusMode_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for DmaSysbusMode {
    #[inline(always)]
    fn default() -> DmaSysbusMode {
        <crate::RegValueT<DmaSysbusMode_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Gpctl_SPEC;
impl crate::sealed::RegSpec for Gpctl_SPEC {
    type DataType = u32;
}
#[doc = "General Purpose Control Register\n resetvalue={Application Reset:0x0}"]
pub type Gpctl = crate::RegValueT<Gpctl_SPEC>;

impl Gpctl {
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti0(
        self,
    ) -> crate::common::RegisterField<0, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<0,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti1(
        self,
    ) -> crate::common::RegisterField<2, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<2,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti2(
        self,
    ) -> crate::common::RegisterField<4, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<4,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti3(
        self,
    ) -> crate::common::RegisterField<6, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<6,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti4(
        self,
    ) -> crate::common::RegisterField<8, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<8,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti5(
        self,
    ) -> crate::common::RegisterField<10, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<10,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti6(
        self,
    ) -> crate::common::RegisterField<12, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<12,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti7(
        self,
    ) -> crate::common::RegisterField<14, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<14,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti8(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<16,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti9(
        self,
    ) -> crate::common::RegisterField<18, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<18,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Alternate Input Select   ALTI10. Selects the alternate input for channel y. If no signal is connected to an alternate input  it is connected to GND. If for one product no signal is connected to an alternate input  it is connected to GND internally at module entity level. This allows to leave some signals unconnected in the application  i.e. RXER  CRS  COL  and save pins and external connection to GND. Map of signals demultiplexed by ALTI bit fields  ALTI0  MDIO ALTI1  RXCLK  REFCLK ALTI2  CRS ALTI3  COL ALTI4  RXDV  CRSDV  RCTL ALTI5  RXER ALTI6  RXD0 ALTI7  RXD1 ALTI8  RXD2 ALTI9  RXD3 ALTI10  TXCLK"]
    #[inline(always)]
    pub fn alti10(
        self,
    ) -> crate::common::RegisterField<20, 0x3, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<20,0x3,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "External Phy Interface RMII Mode Bit   EPR. Used to select the phy interface during module reset of MAC triggered by        setting SWR bit of DMA Mode  160 Register. Note that the status of this bit is latched in during module reset only. Drives eth phy rmii o   phy inff sel i 2 0 ."]
    #[inline(always)]
    pub fn epr(
        self,
    ) -> crate::common::RegisterField<22, 0x7, 1, 0, u8, Gpctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<22,0x7,1,0,u8, Gpctl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for Gpctl {
    #[inline(always)]
    fn default() -> Gpctl {
        <crate::RegValueT<Gpctl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Id_SPEC;
impl crate::sealed::RegSpec for Id_SPEC {
    type DataType = u32;
}
#[doc = "Module Identification Register\n resetvalue={Application Reset:0x0E9C000}"]
pub type Id = crate::RegValueT<Id_SPEC>;

impl Id {
    #[doc = "Module Revision Number   MODREV. This bit field defines the module revision number. The value of a module        revision starts with 01 H  first        revision . To be incremented eg. 2 for GMAC QoS"]
    #[inline(always)]
    pub fn modrev(
        self,
    ) -> crate::common::RegisterField<0, 0xff, 1, 0, u8, Id_SPEC, crate::common::R> {
        crate::common::RegisterField::<0, 0xff, 1, 0, u8, Id_SPEC, crate::common::R>::from_register(
            self, 0,
        )
    }
    #[doc = "Module Type   MODTYPE. This bit field defines the module as a 32 bit module  C0 H"]
    #[inline(always)]
    pub fn modtype(
        self,
    ) -> crate::common::RegisterField<8, 0xff, 1, 0, u8, Id_SPEC, crate::common::R> {
        crate::common::RegisterField::<8, 0xff, 1, 0, u8, Id_SPEC, crate::common::R>::from_register(
            self, 0,
        )
    }
    #[doc = "Module Number Value   MODNUM. This bit field defines the module identification number for the Mod Name   00E9 H"]
    #[inline(always)]
    pub fn modnum(
        self,
    ) -> crate::common::RegisterField<16, 0xffff, 1, 0, u16, Id_SPEC, crate::common::R> {
        crate::common::RegisterField::<16,0xffff,1,0,u16, Id_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for Id {
    #[inline(always)]
    fn default() -> Id {
        <crate::RegValueT<Id_SPEC> as RegisterValue<_>>::new(15319040)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Krst0_SPEC;
impl crate::sealed::RegSpec for Krst0_SPEC {
    type DataType = u32;
}
#[doc = "Kernel Reset Register 0\n resetvalue={Application Reset:0x0}"]
pub type Krst0 = crate::RegValueT<Krst0_SPEC>;

impl Krst0 {
    #[doc = "Kernel Reset   RST. This reset bit can be used to request for a kernel reset. The kernel        reset will be executed if the reset bits of both kernel registers are        set and both  master and slave interface are idle. The RST bit will be cleared  re set to   180 0  180   by the BPI FPI after the        kernel reset was executed."]
    #[inline(always)]
    pub fn rst(self) -> crate::common::RegisterFieldBool<0, 1, 0, Krst0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0, 1, 0, Krst0_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
    #[doc = "Kernel Reset Status   RSTSTAT. This bit indicates wether a kernel reset was executed or not. This bit        is set by the BPI FPI after the execution of a kernel reset in the same        clock cycle both reset bits. This bit can be cleared by writing with   180 1  180  to the CLR bit in the        related KRSTCLR register."]
    #[inline(always)]
    pub fn rststat(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, Krst0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1, 1, 0, Krst0_SPEC, crate::common::R>::from_register(
            self, 0,
        )
    }
}
impl core::default::Default for Krst0 {
    #[inline(always)]
    fn default() -> Krst0 {
        <crate::RegValueT<Krst0_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Krst1_SPEC;
impl crate::sealed::RegSpec for Krst1_SPEC {
    type DataType = u32;
}
#[doc = "Kernel Reset Register 1\n resetvalue={Application Reset:0x0}"]
pub type Krst1 = crate::RegValueT<Krst1_SPEC>;

impl Krst1 {
    #[doc = "Kernel Reset   RST. This reset bit can be used to request for a kernel reset. The kernel        reset will be executed if the reset bits of both kernel reset registers        is set and both  master and slave interface are idle. The RST bit will be cleared  re set to   180 0  180   by the BPI FPI after the        kernel reset was executed."]
    #[inline(always)]
    pub fn rst(self) -> crate::common::RegisterFieldBool<0, 1, 0, Krst1_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0, 1, 0, Krst1_SPEC, crate::common::RW>::from_register(
            self, 0,
        )
    }
}
impl core::default::Default for Krst1 {
    #[inline(always)]
    fn default() -> Krst1 {
        <crate::RegValueT<Krst1_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Krstclr_SPEC;
impl crate::sealed::RegSpec for Krstclr_SPEC {
    type DataType = u32;
}
#[doc = "Kernel Reset Status Clear Register\n resetvalue={Application Reset:0x0}"]
pub type Krstclr = crate::RegValueT<Krstclr_SPEC>;

impl Krstclr {
    #[doc = "Kernel Reset Status Clear   CLR. Read always as 0."]
    #[inline(always)]
    pub fn clr(self) -> crate::common::RegisterFieldBool<0, 1, 0, Krstclr_SPEC, crate::common::W> {
        crate::common::RegisterFieldBool::<0, 1, 0, Krstclr_SPEC, crate::common::W>::from_register(
            self, 0,
        )
    }
}
impl core::default::Default for Krstclr {
    #[inline(always)]
    fn default() -> Krstclr {
        <crate::RegValueT<Krstclr_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Mac1UsTicCounter_SPEC;
impl crate::sealed::RegSpec for Mac1UsTicCounter_SPEC {
    type DataType = u32;
}
#[doc = "MAC One Microsecond Tic Counter Register\n resetvalue={Application Reset:0x63}"]
pub type Mac1UsTicCounter = crate::RegValueT<Mac1UsTicCounter_SPEC>;

impl Mac1UsTicCounter {
    #[doc = "1US TIC Counter   TIC 1US CNTR. The application must program this counter so that the number of clock        cycles of CSR clock is 1us.  Subtract 1 from the value before        programming . For example if the CSR clock is 100MHz then this field        needs to be programmed to value 100   1   99  which is 0x63 . This is        required to generate the 1US events that are used to update some of the        EEE related counters. Value After Reset  0x63"]
    #[inline(always)]
    pub fn tic_1us_cntr(
        self,
    ) -> crate::common::RegisterField<0, 0xfff, 1, 0, u16, Mac1UsTicCounter_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xfff,1,0,u16, Mac1UsTicCounter_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for Mac1UsTicCounter {
    #[inline(always)]
    fn default() -> Mac1UsTicCounter {
        <crate::RegValueT<Mac1UsTicCounter_SPEC> as RegisterValue<_>>::new(99)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress0High_SPEC;
impl crate::sealed::RegSpec for MacAddress0High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 0 High Register\n resetvalue={Application Reset:0x08000FFFF}"]
pub type MacAddress0High = crate::RegValueT<MacAddress0High_SPEC>;

impl MacAddress0High {
    #[doc = "MAC Address0 47 32    ADDRHI. This field contains the upper 16 bits  47 32  of the first 6 byte MAC address. The MAC uses this field for filtering the received packets and inserting the MAC address in the Transmit Flow Control  Pause  Packets. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress0High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress0High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress0High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress0High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. This bit is always set to 1. Value After Reset  0x1"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress0High_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress0High_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress0High {
    #[inline(always)]
    fn default() -> MacAddress0High {
        <crate::RegValueT<MacAddress0High_SPEC> as RegisterValue<_>>::new(2147549183)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress0Low_SPEC;
impl crate::sealed::RegSpec for MacAddress0Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 0 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress0Low = crate::RegValueT<MacAddress0Low_SPEC>;

impl MacAddress0Low {
    #[doc = "MAC Address0 31 0    ADDRLO. This field contains the lower 32 bits of the first 6 byte MAC address.        The MAC uses this field for filtering the received packets and inserting        the MAC address in the Transmit Flow Control  Pause  Packets. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress0Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress0Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress0Low {
    #[inline(always)]
    fn default() -> MacAddress0Low {
        <crate::RegValueT<MacAddress0Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress10High_SPEC;
impl crate::sealed::RegSpec for MacAddress10High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress10High = crate::RegValueT<MacAddress10High_SPEC>;

impl MacAddress10High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress10High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress10High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress10High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress10High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress10High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress10High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress10High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress10High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress10High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress10High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress10High {
    #[inline(always)]
    fn default() -> MacAddress10High {
        <crate::RegValueT<MacAddress10High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress10Low_SPEC;
impl crate::sealed::RegSpec for MacAddress10Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress10Low = crate::RegValueT<MacAddress10Low_SPEC>;

impl MacAddress10Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress10Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress10Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress10Low {
    #[inline(always)]
    fn default() -> MacAddress10Low {
        <crate::RegValueT<MacAddress10Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress11High_SPEC;
impl crate::sealed::RegSpec for MacAddress11High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress11High = crate::RegValueT<MacAddress11High_SPEC>;

impl MacAddress11High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress11High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress11High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress11High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress11High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress11High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress11High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress11High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress11High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress11High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress11High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress11High {
    #[inline(always)]
    fn default() -> MacAddress11High {
        <crate::RegValueT<MacAddress11High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress11Low_SPEC;
impl crate::sealed::RegSpec for MacAddress11Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress11Low = crate::RegValueT<MacAddress11Low_SPEC>;

impl MacAddress11Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress11Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress11Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress11Low {
    #[inline(always)]
    fn default() -> MacAddress11Low {
        <crate::RegValueT<MacAddress11Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress12High_SPEC;
impl crate::sealed::RegSpec for MacAddress12High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress12High = crate::RegValueT<MacAddress12High_SPEC>;

impl MacAddress12High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress12High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress12High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress12High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress12High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress12High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress12High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress12High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress12High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress12High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress12High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress12High {
    #[inline(always)]
    fn default() -> MacAddress12High {
        <crate::RegValueT<MacAddress12High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress12Low_SPEC;
impl crate::sealed::RegSpec for MacAddress12Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress12Low = crate::RegValueT<MacAddress12Low_SPEC>;

impl MacAddress12Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress12Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress12Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress12Low {
    #[inline(always)]
    fn default() -> MacAddress12Low {
        <crate::RegValueT<MacAddress12Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress13High_SPEC;
impl crate::sealed::RegSpec for MacAddress13High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress13High = crate::RegValueT<MacAddress13High_SPEC>;

impl MacAddress13High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress13High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress13High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress13High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress13High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress13High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress13High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress13High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress13High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress13High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress13High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress13High {
    #[inline(always)]
    fn default() -> MacAddress13High {
        <crate::RegValueT<MacAddress13High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress13Low_SPEC;
impl crate::sealed::RegSpec for MacAddress13Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress13Low = crate::RegValueT<MacAddress13Low_SPEC>;

impl MacAddress13Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress13Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress13Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress13Low {
    #[inline(always)]
    fn default() -> MacAddress13Low {
        <crate::RegValueT<MacAddress13Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress14High_SPEC;
impl crate::sealed::RegSpec for MacAddress14High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress14High = crate::RegValueT<MacAddress14High_SPEC>;

impl MacAddress14High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress14High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress14High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress14High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress14High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress14High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress14High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress14High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress14High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress14High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress14High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress14High {
    #[inline(always)]
    fn default() -> MacAddress14High {
        <crate::RegValueT<MacAddress14High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress14Low_SPEC;
impl crate::sealed::RegSpec for MacAddress14Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress14Low = crate::RegValueT<MacAddress14Low_SPEC>;

impl MacAddress14Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress14Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress14Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress14Low {
    #[inline(always)]
    fn default() -> MacAddress14Low {
        <crate::RegValueT<MacAddress14Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress15High_SPEC;
impl crate::sealed::RegSpec for MacAddress15High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress15High = crate::RegValueT<MacAddress15High_SPEC>;

impl MacAddress15High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress15High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress15High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress15High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress15High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress15High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress15High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress15High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress15High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress15High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress15High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress15High {
    #[inline(always)]
    fn default() -> MacAddress15High {
        <crate::RegValueT<MacAddress15High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress15Low_SPEC;
impl crate::sealed::RegSpec for MacAddress15Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress15Low = crate::RegValueT<MacAddress15Low_SPEC>;

impl MacAddress15Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress15Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress15Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress15Low {
    #[inline(always)]
    fn default() -> MacAddress15Low {
        <crate::RegValueT<MacAddress15Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress16High_SPEC;
impl crate::sealed::RegSpec for MacAddress16High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress16High = crate::RegValueT<MacAddress16High_SPEC>;

impl MacAddress16High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress16High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress16High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress16High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress16High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress16High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress16High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress16High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress16High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress16High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress16High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress16High {
    #[inline(always)]
    fn default() -> MacAddress16High {
        <crate::RegValueT<MacAddress16High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress16Low_SPEC;
impl crate::sealed::RegSpec for MacAddress16Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress16Low = crate::RegValueT<MacAddress16Low_SPEC>;

impl MacAddress16Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress16Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress16Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress16Low {
    #[inline(always)]
    fn default() -> MacAddress16Low {
        <crate::RegValueT<MacAddress16Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress17High_SPEC;
impl crate::sealed::RegSpec for MacAddress17High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress17High = crate::RegValueT<MacAddress17High_SPEC>;

impl MacAddress17High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress17High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress17High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress17High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress17High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress17High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress17High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress17High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress17High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress17High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress17High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress17High {
    #[inline(always)]
    fn default() -> MacAddress17High {
        <crate::RegValueT<MacAddress17High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress17Low_SPEC;
impl crate::sealed::RegSpec for MacAddress17Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress17Low = crate::RegValueT<MacAddress17Low_SPEC>;

impl MacAddress17Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress17Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress17Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress17Low {
    #[inline(always)]
    fn default() -> MacAddress17Low {
        <crate::RegValueT<MacAddress17Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress18High_SPEC;
impl crate::sealed::RegSpec for MacAddress18High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress18High = crate::RegValueT<MacAddress18High_SPEC>;

impl MacAddress18High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress18High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress18High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress18High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress18High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress18High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress18High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress18High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress18High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress18High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress18High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress18High {
    #[inline(always)]
    fn default() -> MacAddress18High {
        <crate::RegValueT<MacAddress18High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress18Low_SPEC;
impl crate::sealed::RegSpec for MacAddress18Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress18Low = crate::RegValueT<MacAddress18Low_SPEC>;

impl MacAddress18Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress18Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress18Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress18Low {
    #[inline(always)]
    fn default() -> MacAddress18Low {
        <crate::RegValueT<MacAddress18Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress19High_SPEC;
impl crate::sealed::RegSpec for MacAddress19High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress19High = crate::RegValueT<MacAddress19High_SPEC>;

impl MacAddress19High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress19High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress19High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress19High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress19High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress19High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress19High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress19High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress19High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress19High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress19High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress19High {
    #[inline(always)]
    fn default() -> MacAddress19High {
        <crate::RegValueT<MacAddress19High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress19Low_SPEC;
impl crate::sealed::RegSpec for MacAddress19Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress19Low = crate::RegValueT<MacAddress19Low_SPEC>;

impl MacAddress19Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress19Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress19Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress19Low {
    #[inline(always)]
    fn default() -> MacAddress19Low {
        <crate::RegValueT<MacAddress19Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress1High_SPEC;
impl crate::sealed::RegSpec for MacAddress1High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress1High = crate::RegValueT<MacAddress1High_SPEC>;

impl MacAddress1High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress1High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress1High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress1High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress1High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress1High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress1High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress1High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress1High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress1High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress1High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress1High {
    #[inline(always)]
    fn default() -> MacAddress1High {
        <crate::RegValueT<MacAddress1High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress1Low_SPEC;
impl crate::sealed::RegSpec for MacAddress1Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress1Low = crate::RegValueT<MacAddress1Low_SPEC>;

impl MacAddress1Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress1Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress1Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress1Low {
    #[inline(always)]
    fn default() -> MacAddress1Low {
        <crate::RegValueT<MacAddress1Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress20High_SPEC;
impl crate::sealed::RegSpec for MacAddress20High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress20High = crate::RegValueT<MacAddress20High_SPEC>;

impl MacAddress20High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress20High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress20High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress20High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress20High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress20High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress20High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress20High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress20High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress20High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress20High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress20High {
    #[inline(always)]
    fn default() -> MacAddress20High {
        <crate::RegValueT<MacAddress20High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress20Low_SPEC;
impl crate::sealed::RegSpec for MacAddress20Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress20Low = crate::RegValueT<MacAddress20Low_SPEC>;

impl MacAddress20Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress20Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress20Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress20Low {
    #[inline(always)]
    fn default() -> MacAddress20Low {
        <crate::RegValueT<MacAddress20Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress21High_SPEC;
impl crate::sealed::RegSpec for MacAddress21High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress21High = crate::RegValueT<MacAddress21High_SPEC>;

impl MacAddress21High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress21High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress21High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress21High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress21High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress21High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress21High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress21High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress21High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress21High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress21High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress21High {
    #[inline(always)]
    fn default() -> MacAddress21High {
        <crate::RegValueT<MacAddress21High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress21Low_SPEC;
impl crate::sealed::RegSpec for MacAddress21Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress21Low = crate::RegValueT<MacAddress21Low_SPEC>;

impl MacAddress21Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress21Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress21Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress21Low {
    #[inline(always)]
    fn default() -> MacAddress21Low {
        <crate::RegValueT<MacAddress21Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress22High_SPEC;
impl crate::sealed::RegSpec for MacAddress22High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress22High = crate::RegValueT<MacAddress22High_SPEC>;

impl MacAddress22High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress22High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress22High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress22High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress22High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress22High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress22High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress22High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress22High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress22High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress22High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress22High {
    #[inline(always)]
    fn default() -> MacAddress22High {
        <crate::RegValueT<MacAddress22High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress22Low_SPEC;
impl crate::sealed::RegSpec for MacAddress22Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress22Low = crate::RegValueT<MacAddress22Low_SPEC>;

impl MacAddress22Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress22Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress22Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress22Low {
    #[inline(always)]
    fn default() -> MacAddress22Low {
        <crate::RegValueT<MacAddress22Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress23High_SPEC;
impl crate::sealed::RegSpec for MacAddress23High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress23High = crate::RegValueT<MacAddress23High_SPEC>;

impl MacAddress23High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress23High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress23High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress23High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress23High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress23High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress23High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress23High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress23High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress23High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress23High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress23High {
    #[inline(always)]
    fn default() -> MacAddress23High {
        <crate::RegValueT<MacAddress23High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress23Low_SPEC;
impl crate::sealed::RegSpec for MacAddress23Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress23Low = crate::RegValueT<MacAddress23Low_SPEC>;

impl MacAddress23Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress23Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress23Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress23Low {
    #[inline(always)]
    fn default() -> MacAddress23Low {
        <crate::RegValueT<MacAddress23Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress24High_SPEC;
impl crate::sealed::RegSpec for MacAddress24High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress24High = crate::RegValueT<MacAddress24High_SPEC>;

impl MacAddress24High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress24High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress24High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress24High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress24High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress24High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress24High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress24High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress24High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress24High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress24High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress24High {
    #[inline(always)]
    fn default() -> MacAddress24High {
        <crate::RegValueT<MacAddress24High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress24Low_SPEC;
impl crate::sealed::RegSpec for MacAddress24Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress24Low = crate::RegValueT<MacAddress24Low_SPEC>;

impl MacAddress24Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress24Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress24Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress24Low {
    #[inline(always)]
    fn default() -> MacAddress24Low {
        <crate::RegValueT<MacAddress24Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress25High_SPEC;
impl crate::sealed::RegSpec for MacAddress25High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress25High = crate::RegValueT<MacAddress25High_SPEC>;

impl MacAddress25High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress25High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress25High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress25High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress25High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress25High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress25High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress25High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress25High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress25High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress25High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress25High {
    #[inline(always)]
    fn default() -> MacAddress25High {
        <crate::RegValueT<MacAddress25High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress25Low_SPEC;
impl crate::sealed::RegSpec for MacAddress25Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress25Low = crate::RegValueT<MacAddress25Low_SPEC>;

impl MacAddress25Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress25Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress25Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress25Low {
    #[inline(always)]
    fn default() -> MacAddress25Low {
        <crate::RegValueT<MacAddress25Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress26High_SPEC;
impl crate::sealed::RegSpec for MacAddress26High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress26High = crate::RegValueT<MacAddress26High_SPEC>;

impl MacAddress26High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress26High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress26High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress26High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress26High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress26High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress26High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress26High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress26High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress26High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress26High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress26High {
    #[inline(always)]
    fn default() -> MacAddress26High {
        <crate::RegValueT<MacAddress26High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress26Low_SPEC;
impl crate::sealed::RegSpec for MacAddress26Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress26Low = crate::RegValueT<MacAddress26Low_SPEC>;

impl MacAddress26Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress26Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress26Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress26Low {
    #[inline(always)]
    fn default() -> MacAddress26Low {
        <crate::RegValueT<MacAddress26Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress27High_SPEC;
impl crate::sealed::RegSpec for MacAddress27High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress27High = crate::RegValueT<MacAddress27High_SPEC>;

impl MacAddress27High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress27High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress27High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress27High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress27High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress27High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress27High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress27High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress27High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress27High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress27High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress27High {
    #[inline(always)]
    fn default() -> MacAddress27High {
        <crate::RegValueT<MacAddress27High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress27Low_SPEC;
impl crate::sealed::RegSpec for MacAddress27Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress27Low = crate::RegValueT<MacAddress27Low_SPEC>;

impl MacAddress27Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress27Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress27Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress27Low {
    #[inline(always)]
    fn default() -> MacAddress27Low {
        <crate::RegValueT<MacAddress27Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress28High_SPEC;
impl crate::sealed::RegSpec for MacAddress28High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress28High = crate::RegValueT<MacAddress28High_SPEC>;

impl MacAddress28High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress28High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress28High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress28High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress28High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress28High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress28High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress28High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress28High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress28High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress28High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress28High {
    #[inline(always)]
    fn default() -> MacAddress28High {
        <crate::RegValueT<MacAddress28High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress28Low_SPEC;
impl crate::sealed::RegSpec for MacAddress28Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress28Low = crate::RegValueT<MacAddress28Low_SPEC>;

impl MacAddress28Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress28Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress28Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress28Low {
    #[inline(always)]
    fn default() -> MacAddress28Low {
        <crate::RegValueT<MacAddress28Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress29High_SPEC;
impl crate::sealed::RegSpec for MacAddress29High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress29High = crate::RegValueT<MacAddress29High_SPEC>;

impl MacAddress29High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress29High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress29High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress29High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress29High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress29High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress29High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress29High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress29High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress29High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress29High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress29High {
    #[inline(always)]
    fn default() -> MacAddress29High {
        <crate::RegValueT<MacAddress29High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress29Low_SPEC;
impl crate::sealed::RegSpec for MacAddress29Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress29Low = crate::RegValueT<MacAddress29Low_SPEC>;

impl MacAddress29Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress29Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress29Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress29Low {
    #[inline(always)]
    fn default() -> MacAddress29Low {
        <crate::RegValueT<MacAddress29Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress2High_SPEC;
impl crate::sealed::RegSpec for MacAddress2High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress2High = crate::RegValueT<MacAddress2High_SPEC>;

impl MacAddress2High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress2High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress2High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress2High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress2High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress2High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress2High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress2High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress2High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress2High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress2High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress2High {
    #[inline(always)]
    fn default() -> MacAddress2High {
        <crate::RegValueT<MacAddress2High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress2Low_SPEC;
impl crate::sealed::RegSpec for MacAddress2Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress2Low = crate::RegValueT<MacAddress2Low_SPEC>;

impl MacAddress2Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress2Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress2Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress2Low {
    #[inline(always)]
    fn default() -> MacAddress2Low {
        <crate::RegValueT<MacAddress2Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress30High_SPEC;
impl crate::sealed::RegSpec for MacAddress30High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress30High = crate::RegValueT<MacAddress30High_SPEC>;

impl MacAddress30High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress30High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress30High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress30High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress30High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress30High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress30High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress30High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress30High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress30High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress30High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress30High {
    #[inline(always)]
    fn default() -> MacAddress30High {
        <crate::RegValueT<MacAddress30High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress30Low_SPEC;
impl crate::sealed::RegSpec for MacAddress30Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress30Low = crate::RegValueT<MacAddress30Low_SPEC>;

impl MacAddress30Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress30Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress30Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress30Low {
    #[inline(always)]
    fn default() -> MacAddress30Low {
        <crate::RegValueT<MacAddress30Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress31High_SPEC;
impl crate::sealed::RegSpec for MacAddress31High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress31High = crate::RegValueT<MacAddress31High_SPEC>;

impl MacAddress31High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress31High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress31High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress31High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress31High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress31High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress31High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress31High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress31High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress31High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress31High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress31High {
    #[inline(always)]
    fn default() -> MacAddress31High {
        <crate::RegValueT<MacAddress31High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress31Low_SPEC;
impl crate::sealed::RegSpec for MacAddress31Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress31Low = crate::RegValueT<MacAddress31Low_SPEC>;

impl MacAddress31Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress31Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress31Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress31Low {
    #[inline(always)]
    fn default() -> MacAddress31Low {
        <crate::RegValueT<MacAddress31Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress3High_SPEC;
impl crate::sealed::RegSpec for MacAddress3High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress3High = crate::RegValueT<MacAddress3High_SPEC>;

impl MacAddress3High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress3High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress3High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress3High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress3High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress3High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress3High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress3High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress3High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress3High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress3High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress3High {
    #[inline(always)]
    fn default() -> MacAddress3High {
        <crate::RegValueT<MacAddress3High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress3Low_SPEC;
impl crate::sealed::RegSpec for MacAddress3Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress3Low = crate::RegValueT<MacAddress3Low_SPEC>;

impl MacAddress3Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress3Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress3Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress3Low {
    #[inline(always)]
    fn default() -> MacAddress3Low {
        <crate::RegValueT<MacAddress3Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress4High_SPEC;
impl crate::sealed::RegSpec for MacAddress4High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress4High = crate::RegValueT<MacAddress4High_SPEC>;

impl MacAddress4High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress4High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress4High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress4High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress4High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress4High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress4High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress4High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress4High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress4High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress4High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress4High {
    #[inline(always)]
    fn default() -> MacAddress4High {
        <crate::RegValueT<MacAddress4High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress4Low_SPEC;
impl crate::sealed::RegSpec for MacAddress4Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress4Low = crate::RegValueT<MacAddress4Low_SPEC>;

impl MacAddress4Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress4Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress4Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress4Low {
    #[inline(always)]
    fn default() -> MacAddress4Low {
        <crate::RegValueT<MacAddress4Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress5High_SPEC;
impl crate::sealed::RegSpec for MacAddress5High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress5High = crate::RegValueT<MacAddress5High_SPEC>;

impl MacAddress5High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress5High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress5High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress5High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress5High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress5High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress5High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress5High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress5High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress5High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress5High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress5High {
    #[inline(always)]
    fn default() -> MacAddress5High {
        <crate::RegValueT<MacAddress5High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress5Low_SPEC;
impl crate::sealed::RegSpec for MacAddress5Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress5Low = crate::RegValueT<MacAddress5Low_SPEC>;

impl MacAddress5Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress5Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress5Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress5Low {
    #[inline(always)]
    fn default() -> MacAddress5Low {
        <crate::RegValueT<MacAddress5Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress6High_SPEC;
impl crate::sealed::RegSpec for MacAddress6High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress6High = crate::RegValueT<MacAddress6High_SPEC>;

impl MacAddress6High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress6High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress6High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress6High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress6High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress6High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress6High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress6High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress6High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress6High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress6High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress6High {
    #[inline(always)]
    fn default() -> MacAddress6High {
        <crate::RegValueT<MacAddress6High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress6Low_SPEC;
impl crate::sealed::RegSpec for MacAddress6Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress6Low = crate::RegValueT<MacAddress6Low_SPEC>;

impl MacAddress6Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress6Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress6Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress6Low {
    #[inline(always)]
    fn default() -> MacAddress6Low {
        <crate::RegValueT<MacAddress6Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress7High_SPEC;
impl crate::sealed::RegSpec for MacAddress7High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress7High = crate::RegValueT<MacAddress7High_SPEC>;

impl MacAddress7High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress7High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress7High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress7High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress7High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress7High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress7High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress7High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress7High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress7High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress7High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress7High {
    #[inline(always)]
    fn default() -> MacAddress7High {
        <crate::RegValueT<MacAddress7High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress7Low_SPEC;
impl crate::sealed::RegSpec for MacAddress7Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress7Low = crate::RegValueT<MacAddress7Low_SPEC>;

impl MacAddress7Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress7Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress7Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress7Low {
    #[inline(always)]
    fn default() -> MacAddress7Low {
        <crate::RegValueT<MacAddress7Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress8High_SPEC;
impl crate::sealed::RegSpec for MacAddress8High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress8High = crate::RegValueT<MacAddress8High_SPEC>;

impl MacAddress8High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress8High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress8High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress8High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress8High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress8High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress8High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress8High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress8High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress8High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress8High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress8High {
    #[inline(always)]
    fn default() -> MacAddress8High {
        <crate::RegValueT<MacAddress8High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress8Low_SPEC;
impl crate::sealed::RegSpec for MacAddress8Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress8Low = crate::RegValueT<MacAddress8Low_SPEC>;

impl MacAddress8Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress8Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress8Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress8Low {
    #[inline(always)]
    fn default() -> MacAddress8Low {
        <crate::RegValueT<MacAddress8Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress9High_SPEC;
impl crate::sealed::RegSpec for MacAddress9High_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 High Register\n resetvalue={Application Reset:0x0FFFF}"]
pub type MacAddress9High = crate::RegValueT<MacAddress9High_SPEC>;

impl MacAddress9High {
    #[doc = "MAC Address1  47 32    ADDRHI. This field contains the upper 16 bits 47 32  of the second 6 byte MAC address. Value After Reset  0xffff"]
    #[inline(always)]
    pub fn addrhi(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacAddress9High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacAddress9High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Select   DCS. If the PDC bit of MAC Ext Configuration register is not set  This field contains the binary representation of the DMA Channel number to which an Rx packet whose DA matches the MAC Address0 content is routed. If the PDC bit of MAC Ext Configuration register is set  This field contains the one hot representation of one or more DMA Channel numbers to which an Rx packet whose DA matches the MAC Address0 content is routed."]
    #[inline(always)]
    pub fn dcs(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacAddress9High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacAddress9High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Mask Byte Control   MBC. These bits are mask control bits for comparing each of the MAC Address bytes. When set high  the MAC does not compare the corresponding byte of received DA or SA with the contents of MAC Address1 registers. Each bit controls the masking of the bytes as follows  Bit 29  Register 194 15 8  Bit 28  Register 194 7 0  Bit 27  Register 195 31 24    Bit 24  Register 195 7 0  You can filter a group of addresses  known as group address filtering  by masking one or more bytes of the address. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mbc(
        self,
    ) -> crate::common::RegisterField<24, 0x3f, 1, 0, u8, MacAddress9High_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3f,1,0,u8, MacAddress9High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address   SA. When this bit is set  the MAC Address1 47 0  is used to compare with the SA fields of the received packet. When this bit is reset  the MAC Address1 47 0  is used to compare with the DA fields of the received packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sa(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacAddress9High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacAddress9High_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address Enable   AE. When this bit is set  the address filter module uses the second MAC address for perfect filtering. When this bit is reset  the address filter module ignores the address for filtering. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ae(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacAddress9High_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacAddress9High_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacAddress9High {
    #[inline(always)]
    fn default() -> MacAddress9High {
        <crate::RegValueT<MacAddress9High_SPEC> as RegisterValue<_>>::new(65535)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacAddress9Low_SPEC;
impl crate::sealed::RegSpec for MacAddress9Low_SPEC {
    type DataType = u32;
}
#[doc = "MAC Address 31 Low Register\n resetvalue={Application Reset:0x0FFFFFFFF}"]
pub type MacAddress9Low = crate::RegValueT<MacAddress9Low_SPEC>;

impl MacAddress9Low {
    #[doc = "MAC Address1  31 0    ADDRLO. This field contains the lower 32 bits of second 6 byte MAC address. The        content of this field is undefined until loaded by the application after        the initialization process. Value After Reset  0xffffffff"]
    #[inline(always)]
    pub fn addrlo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacAddress9Low_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacAddress9Low_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacAddress9Low {
    #[inline(always)]
    fn default() -> MacAddress9Low {
        <crate::RegValueT<MacAddress9Low_SPEC> as RegisterValue<_>>::new(4294967295)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacConfiguration_SPEC;
impl crate::sealed::RegSpec for MacConfiguration_SPEC {
    type DataType = u32;
}
#[doc = "MAC Configuration Register\n resetvalue={Application Reset:0x0}"]
pub type MacConfiguration = crate::RegValueT<MacConfiguration_SPEC>;

impl MacConfiguration {
    #[doc = "Receiver Enable   RE. When this bit is set  the Rx state machine of the MAC is enabled for        receiving packets from the GMII or MII interface. When this bit is        reset  the MAC Rx state machine is disabled after it completes the        reception of the current packet. The Rx state machine does not receive        any more packets from the GMII or MII interface. Value After Reset  0x0"]
    #[inline(always)]
    pub fn re(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmitter Enable   TE. When this bit is set  the Tx state machine of the MAC is enabled for        transmission on the GMII or MII interface. When this bit is reset  the        MAC Tx state machine is disabled after it completes the transmission of        the current packet. The Tx state machine does not transmit any more        packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn te(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Preamble Length for Transmit packets   PRELEN. These bits control the number of preamble bytes that are added to the        beginning of every Tx packet. The preamble reduction occurs only when        the MAC is operating in the full duplex mode. Value After Reset  0x0"]
    #[inline(always)]
    pub fn prelen(
        self,
    ) -> crate::common::RegisterField<2, 0x3, 1, 0, u8, MacConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<2,0x3,1,0,u8, MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Deferral Check   DC. When this bit is set  the deferral check function is enabled in the MAC. The MAC issues a Packet Abort status  along with the excessive deferral error bit set in the Tx packet status  when the Tx state machine is deferred for more than 24 288 bit times in 10 or 100 Mbps mode. If the MAC is configured for 1000 2500 Mbps operation  the threshold for deferral is 155 680 bits times. Deferral begins when the transmitter is ready to transmit  but it is prevented because of an active carrier sense signal  CRS  on GMII or MII. The defer time is not cumulative. For example  if the transmitter defers for 10 000 bit times because the CRS signal is active and the CRS signal becomes inactive  the transmitter transmits and collision happens. Because of collision  the transmitter needs to back off and then defer again after back off completion. In such a scenario  the deferral timer is reset to 0  and it is restarted. When this bit is reset  the deferral check function is disabled and the MAC defers until the CRS signal goes inactive. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dc(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<4,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Back Off Limit   BL. The back off limit determines the random integer number  r  of slot time delays  4 096 bit times for 1000 2500 Mbps  512 bit times for 10 100 Mbps  for which the MAC waits before rescheduling a transmission attempt during retries after a collision. where n   retransmission attempt The random integer r takes the value in the range 0  lt   r  lt  2 k Value After Reset  0x0"]
    #[inline(always)]
    pub fn bl(
        self,
    ) -> crate::common::RegisterField<5, 0x3, 1, 0, u8, MacConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<5,0x3,1,0,u8, MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Disable Retry   DR. When this bit is set  the MAC attempts only one transmission. When a collision occurs on the GMII or MII interface  the MAC ignores the current packet transmission and reports a Packet Abort with excessive collision error in the Tx packet status. When this bit is reset  the MAC retries based on the settings of the BL field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dr(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<8,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Disable Carrier Sense During Transmission   DCRS. When this bit is set  the MAC transmitter ignores the  G MII CRS signal during packet transmission in the half duplex mode. As a result  no errors are generated because of Loss of Carrier or No Carrier during transmission. When this bit is reset  the MAC transmitter generates errors because of Carrier Sense. The MAC can even abort the transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dcrs(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<9,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Disable Receive Own   DO. When this bit is set  the MAC disables the reception of packets when the gmii txen o is asserted in the half duplex mode. When this bit is reset  the MAC receives all packets given by the PHY. Value After Reset  0x0"]
    #[inline(always)]
    pub fn r#do(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<10,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Carrier Sense Before Transmission in Full Duplex Mode   ECRSFD. When this bit is set  the MAC transmitter checks the CRS signal before        packet transmission in the full duplex mode. The MAC starts the        transmission only when the CRS signal is low. When this bit is reset  the MAC transmitter ignores the status of the        CRS signal. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ecrsfd(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<11,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Loopback Mode   LM. When this bit is set  the MAC operates in the loopback mode at GMII or        MII. The  G MII Rx clock input  clk rx i  is required for the loopback        to work properly. This is because the Tx clock is not internally looped        back. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lm(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<12,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Duplex Mode   DM. When this bit is set  the MAC operates in the full duplex mode in which        it can transmit and receive simultaneously. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dm(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<13,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Speed   FES. This bit selects the speed mode  The mac speed o 0  signal reflects the value of this bit. Value After Reset  0x0"]
    #[inline(always)]
    pub fn fes(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<14,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Port Select   PS. This bit selects the Ethernet line speed. This bit  along with Bit 14  selects the exact line speed. In the 10 100        Mbps only  always 1  or 1000 Mbps only  always 0  configurations  this        bit is read only  RO  with appropriate value. In default 10 100 1000        Mbps configurations  this bit is read write  R W . The mac speed o 1         signal reflects the value of this bit. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ps(
        self,
    ) -> crate::common::RegisterFieldBool<15, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<15,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Jumbo Packet Enable   JE. When this bit is set  the MAC allows jumbo packets of 9 018 bytes  9 022        bytes for VLAN tagged packets  without reporting a giant packet error in        the Rx packet status. Value After Reset  0x0"]
    #[inline(always)]
    pub fn je(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<16,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Jabber Disable   JD. When this bit is set  the MAC disables the jabber timer on the        transmitter. The MAC can transfer packets of up to 16 383 bytes. When this bit is reset  if the application sends more than 2 048 bytes        of data  10 240 if JE is set high  during transmission  the MAC does not        send rest of the bytes in that packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn jd(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<17,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Packet Burst Enable   BE. When this bit is set  the MAC allows packet bursting during transmission in the GMII half duplex mode. Value After Reset  0x0"]
    #[inline(always)]
    pub fn be(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<18,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Watchdog Disable   WD. When this bit is set  the MAC disables the watchdog timer on the        receiver. The MAC can receive packets of up to 16 383 bytes. When this bit is reset  the MAC does not allow more than 2 048 bytes         10 240 if JE is set high  of the packet being received. The MAC cuts        off any bytes received after 2 048 bytes. Value After Reset  0x0"]
    #[inline(always)]
    pub fn wd(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<19,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Automatic Pad or CRC Stripping   ACS. When this bit is set  the MAC strips the Pad or FCS field on the        incoming packets only if the value of the length field is less than        1 536 bytes. All received packets with length field greater than or        equal to 1 536 bytes are passed to the application without stripping the        Pad or FCS field. When this bit is reset  the MAC passes all incoming packets to the        application  without any modification. Note   For information about how the        settings of CST bit and this bit impact the packet length  see the        Table  Packet Length based on the CST and ACS Bit . Value After Reset  0x0"]
    #[inline(always)]
    pub fn acs(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<20,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "CRC stripping for Type packets   CST. When this bit is set  the last four bytes  FCS  of all packets of Ether        type  type field greater than 1 536  are stripped and dropped before        forwarding the packet to the application. Note   For information about how the        settings of the ACS bit and this bit impact the packet length  see the        Table  Packet Length based on the CST and ACS Bits. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cst(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<21,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "IEEE 802.3as Support for 2K Packets   S2KP. When this bit is set  the MAC considers all packets with up to 2 000        bytes length as normal packets. When the JE bit is not set  the MAC        considers all received packets of size more than 2K bytes as Giant        packets. When this bit is reset and the JE bit is not set  the MAC considers all        received packets of size more than 1 518 bytes  1 522 bytes for tagged         as giant packets. For more information about how the setting of this bit        and the JE bit impact the Giant packet status  see the table  Giant        Packet Status based on S2KP and JE Bits. Note   When the JE bit is set  setting this        bit has no effect on the giant packet status. Value After Reset  0x0"]
    #[inline(always)]
    pub fn s2kp(
        self,
    ) -> crate::common::RegisterFieldBool<22, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<22,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Giant Packet Size Limit Control Enable   GPSLCE. When this bit is set  the MAC considers the value in GPSL field in        MAC Ext Configuration register to declare a received packet as Giant        packet. This field must be programmed to more than 1 518 bytes.        Otherwise  the MAC considers 1 518 bytes as giant packet limit. When this bit is reset  the MAC considers a received packet as Giant        packet when its size is greater than 1 518 bytes  1522 bytes for tagged        packet . The watchdog timeout limit  Jumbo Packet Enable and 2K Packet Enable        have higher precedence over this bit  that is the MAC considers a        received packet as Giant packet when its size is greater than 9 018        bytes  9 022 bytes for tagged packet  with Jumbo Packet Enabled and        greater than 2 000 bytes with 2K Packet Enabled. The watchdog timeout         if enabled  terminates the received packet when watchdog limit is        reached. Therefore  the programmed giant packet limit should be less        than the watchdog limit to get the giant packet status. Value After Reset  0x0"]
    #[inline(always)]
    pub fn gpslce(
        self,
    ) -> crate::common::RegisterFieldBool<23, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<23,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Inter Packet Gap   IPG. These bits control the minimum IPG between packets during transmission. LOST SEQUENCE DEFINITION This range of minimum IPG is valid in full duplex mode. In the half duplex mode  the minimum IPG can be configured only for        64 bit times  IPG   100 . Lower values are not considered. When a JAM pattern is being transmitted because of backpressure        activation  the MAC does not consider the minimum IPG. The above function  IPG less than 96 bit times  is valid only when        EIPGEN bit in MAC Ext Configuration register is reset. When EIPGEN is        set  then the minimum IPG  greater than 96 bit times  is controlled as        per the description given in EIPG field in MAC Ext Configuration        register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ipg(
        self,
    ) -> crate::common::RegisterField<24, 0x7, 1, 0, u8, MacConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x7,1,0,u8, MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Checksum Offload   IPC. When set  this bit enables the IPv4 header checksum checking and IPv4 or IPv6 TCP  UDP  or ICMP payload checksum checking. When this bit is reset  the COE function in the receiver is disabled. The Layer 3 and Layer 4 Packet Filter and Enable Split Header features automatically selects the IPC Full Checksum Offload Engine on the Receive side. When any of these features are enabled  you must set the IPC bit. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ipc(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, MacConfiguration_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<27,1,0,MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address Insertion or Replacement Control   SARC. This field controls the source address insertion or replacement for all transmitted packets. Bit 30 specifies which MAC Address register  0 or 1  is used for source address insertion or replacement based on the values of Bits 29 28   Note   Changes to this field take effect only on the start of a packet. If you write to this register field when a packet is being transmitted  only the subsequent packet can use the updated value  that is  the current packet does not use the updated value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn sarc(
        self,
    ) -> crate::common::RegisterField<28, 0x7, 1, 0, u8, MacConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<28,0x7,1,0,u8, MacConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacConfiguration {
    #[inline(always)]
    fn default() -> MacConfiguration {
        <crate::RegValueT<MacConfiguration_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacCsrSwCtrl_SPEC;
impl crate::sealed::RegSpec for MacCsrSwCtrl_SPEC {
    type DataType = u32;
}
#[doc = "MAC CSR Software Controls Register\n resetvalue={Application Reset:0x0}"]
pub type MacCsrSwCtrl = crate::RegValueT<MacCsrSwCtrl_SPEC>;

impl MacCsrSwCtrl {
    #[doc = "Register Clear on Write 1 Enable   RCWE . When this bit is set  the access mode of some register fields changes to Clear on Write 1  the application needs to set that respective bit to 1 to clear it. When this bit is reset  the access mode of these register fields remain as Clear on Read. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rcwe(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacCsrSwCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MacCsrSwCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Slave Error Response Enable   SEEN. When this bit is set  the MAC responds with Slave Error for accesses to        reserved registers in CSR space. When this bit is reset  the MAC        responds with Okay response to any register accessed from CSR space. Value After Reset  0x0"]
    #[inline(always)]
    pub fn seen(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacCsrSwCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<8,1,0,MacCsrSwCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacCsrSwCtrl {
    #[inline(always)]
    fn default() -> MacCsrSwCtrl {
        <crate::RegValueT<MacCsrSwCtrl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacDebug_SPEC;
impl crate::sealed::RegSpec for MacDebug_SPEC {
    type DataType = u32;
}
#[doc = "MAC Debug Register\n resetvalue={Application Reset:0x0}"]
pub type MacDebug = crate::RegValueT<MacDebug_SPEC>;

impl MacDebug {
    #[doc = "MAC GMII or MII Receive Protocol Engine Status   RPESTS. When this bit is set  it indicates that the MAC GMII or MII receive protocol engine is actively receiving data  and it is not in the Idle state. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rpests(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacDebug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0, 1, 0, MacDebug_SPEC, crate::common::R>::from_register(
            self, 0,
        )
    }
    #[doc = "MAC Receive Packet Controller FIFO Status   RFCFCSTS. When this bit is set  this field indicates the active state of the small        FIFO Read and Write controllers of the MAC Receive Packet Controller        module. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rfcfcsts(
        self,
    ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, MacDebug_SPEC, crate::common::R> {
        crate::common::RegisterField::<1,0x3,1,0,u8, MacDebug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MAC GMII or MII Transmit Protocol Engine Status   TPESTS. When this bit is set  it indicates that the MAC GMII or MII transmit protocol engine is actively transmitting data  and it is not in the Idle state. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tpests(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacDebug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<16, 1, 0, MacDebug_SPEC, crate::common::R>::from_register(
            self, 0,
        )
    }
    #[doc = "MAC Transmit Packet Controller Status   TFCSTS. This field indicates the state of the MAC Transmit Packet Controller        module  Status of the previous packet OR IPG or backoff period to be over Value After Reset  0x0"]
    #[inline(always)]
    pub fn tfcsts(
        self,
    ) -> crate::common::RegisterField<17, 0x3, 1, 0, u8, MacDebug_SPEC, crate::common::R> {
        crate::common::RegisterField::<17,0x3,1,0,u8, MacDebug_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacDebug {
    #[inline(always)]
    fn default() -> MacDebug {
        <crate::RegValueT<MacDebug_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacExtCfg1_SPEC;
impl crate::sealed::RegSpec for MacExtCfg1_SPEC {
    type DataType = u32;
}
#[doc = "MAC Extended Configuration Register 1\n resetvalue={Application Reset:0x2}"]
pub type MacExtCfg1 = crate::RegValueT<MacExtCfg1_SPEC>;

impl MacExtCfg1 {
    #[doc = "Split Offset   SPLOFST. These bits indicate the value of offset from the beginning of Length Type field at which header              split should take place when the appropriate SPLM is selected. The reset value of this field is 2 bytes indicating a split              at L2 header. Value is in terms ofbytes."]
    #[inline(always)]
    pub fn splofst(
        self,
    ) -> crate::common::RegisterField<0, 0x7f, 1, 0, u8, MacExtCfg1_SPEC, crate::common::RW> {
        crate::common::RegisterField::<0,0x7f,1,0,u8, MacExtCfg1_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Split Mode   SPLM. These bits indicate the mode of splitting the incoming Rx packets. They are"]
    #[inline(always)]
    pub fn splm(
        self,
    ) -> crate::common::RegisterField<8, 0x3, 1, 0, u8, MacExtCfg1_SPEC, crate::common::RW> {
        crate::common::RegisterField::<8,0x3,1,0,u8, MacExtCfg1_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacExtCfg1 {
    #[inline(always)]
    fn default() -> MacExtCfg1 {
        <crate::RegValueT<MacExtCfg1_SPEC> as RegisterValue<_>>::new(2)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacExtConfiguration_SPEC;
impl crate::sealed::RegSpec for MacExtConfiguration_SPEC {
    type DataType = u32;
}
#[doc = "MAC Extended Configuration Register\n resetvalue={Application Reset:0x0}"]
pub type MacExtConfiguration = crate::RegValueT<MacExtConfiguration_SPEC>;

impl MacExtConfiguration {
    #[doc = "Giant Packet Size Limit   GPSL. If the received packet size is greater than the value programmed in this field in units of bytes  the MAC declares the received packet as Giant packet. The value programmed in this field must be greater than or equal to 1 518 bytes. Any other programmed value is considered as 1 518 bytes. For VLAN tagged packets  the MAC adds 4 bytes to the programmed value. When the Enable Double VLAN Processing option is selected  the MAC adds 8 bytes to the programmed value for double VLAN tagged packets. The value in this field is applicable when the GPSLCE bit is set in MAC Configuration register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn gpsl(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x3fff,
        1,
        0,
        u16,
        MacExtConfiguration_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x3fff,
            1,
            0,
            u16,
            MacExtConfiguration_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Disable CRC Checking for Received Packets   DCRCC. When this bit is set  the MAC receiver does not check the CRC field in the received packets. When this bit is reset  the MAC receiver always checks the CRC field in the received packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dcrcc(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacExtConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<16,1,0,MacExtConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Slow Protocol Detection Enable   SPEN. When this bit is set  MAC processes the Slow Protocol packets  Ether Type 0x8809  and provides the Rx status. The MAC discards the Slow Protocol packets with invalid sub types. When this bit is reset  the MAC forwards all error free Slow Protocol packets to the application. The MAC considers such packets as normal Type packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn spen(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MacExtConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<17,1,0,MacExtConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Unicast Slow Protocol Packet Detect   USP. When this bit is set  the MAC detects the Slow Protocol packets with unicast address of the station specified in the MAC Address0 High and MAC Address0 Low registers. The MAC also detects the Slow Protocol packets with the Slow Protocols multicast address  01 80 C2 00 00 02 . When this bit is reset  the MAC detects only Slow Protocol packets with the Slow Protocol multicast address specified in the IEEE 802.3 2008  Section 5. Value After Reset  0x0"]
    #[inline(always)]
    pub fn usp(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacExtConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<18,1,0,MacExtConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Maximum Size for Splitting the Header Data   HDSMS. These bits indicate the maximum header size allowed for splitting the header data in the received packet  101   111 Reserved If the Enable Split Header Structure option is not selected  these bits are reserved and read only  RO . Value After Reset  0x0"]
    #[inline(always)]
    pub fn hdsms(
        self,
    ) -> crate::common::RegisterField<20, 0x7, 1, 0, u8, MacExtConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<20,0x7,1,0,u8, MacExtConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Extended Inter Packet Gap Enable   EIPGEN. When this bit is set  the MAC interprets EIPG field and IPG field in MAC Configuration register together as minimum IPG greater than 96 bit times in steps of 8 bit times. When this bit is reset  the MAC ignores EIPG field and interprets IPG field in MAC Configuration register as minimum IPG less than or equal to 96 bit times in steps of 8 bit times. Note  The extended Inter Packet Gap feature must be enabled when operating in Full Duplex mode only. There may be undesirable effects on back pressure function and frame transmission if it is enabled in Half Duplex mode. Value After Reset  0x0"]
    #[inline(always)]
    pub fn eipgen(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MacExtConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<24,1,0,MacExtConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Extended Inter Packet Gap   EIPG. The value in this field is applicable when the EIPGEN bit is set. This field  as Most Significant bits   along with IPG field in MAC Configuration register  gives the minimum IPG greater than 96 bit times in steps of 8 bit times   EIPG  IPG  8 h00   104 bit times 8 h01   112 bit times 8 h02   120 bit times                         8 hFF   2144 bit times Value After Reset  0x0"]
    #[inline(always)]
    pub fn eipg(
        self,
    ) -> crate::common::RegisterField<25, 0x1f, 1, 0, u8, MacExtConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<
            25,
            0x1f,
            1,
            0,
            u8,
            MacExtConfiguration_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Flexible Header Enable. When this is set then it is expected that all the incoming packets from the Line to have 4B Flexible Header in the Rx path  except for the pause and PFC packets . Similarly  in the Tx path all the packets from application are expected to have 4B Flexible header. The position of the Flexible Header is always fixed at 12Bytes from the beginning of the packet  after MAC DA SA ."]
    #[inline(always)]
    pub fn fhe(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacExtConfiguration_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<31,1,0,MacExtConfiguration_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacExtConfiguration {
    #[inline(always)]
    fn default() -> MacExtConfiguration {
        <crate::RegValueT<MacExtConfiguration_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacHwFeature0_SPEC;
impl crate::sealed::RegSpec for MacHwFeature0_SPEC {
    type DataType = u32;
}
#[doc = "MAC Hardware Feature Register 0\n resetvalue={Application Reset:0x0A7D71F7}"]
pub type MacHwFeature0 = crate::RegValueT<MacHwFeature0_SPEC>;

impl MacHwFeature0 {
    #[doc = "10 or 100 Mbps Support   MIISEL. This bit is set to 1 when 10 100 Mbps is selected as the Mode of Operation Value After Reset  0x1"]
    #[inline(always)]
    pub fn miisel(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "1000 Mbps Support   GMIISEL. This bit is set to 1 when 1000 Mbps is selected as the Mode of Operation Value After Reset  0x1"]
    #[inline(always)]
    pub fn gmiisel(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Half duplex Support   HDSEL. This bit is set to 1 when the half duplex mode is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn hdsel(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<2,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "PCS Registers  TBI  SGMII  or RTBI PHY interface    PCSSEL. This bit is set to 1 when the TBI  SGMII  or RTBI PHY interface option is selected Value After Reset  0x0"]
    #[inline(always)]
    pub fn pcssel(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "VLAN Hash Filter Selected   VLHASH. This bit is set to 1 when the Enable VLAN Hash Table Based Filtering option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn vlhash(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "SMA  MDIO  Interface   SMASEL. This bit is set to 1 when the Enable Station Management  MDIO Interface  option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn smasel(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "PMT Remote Wake up Packet Enable   RWKSEL. This bit is set to 1 when the Enable Remote Wake Up Packet Detection option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn rwksel(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<6,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "PMT Magic Packet Enable   MGKSEL. This bit is set to 1 when the Enable Magic Packet Detection option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn mgksel(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<7,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "RMON Module Enable   MMCSEL. This bit is set to 1 when the Enable MAC Management Counters  MMC  option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn mmcsel(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<8,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "ARP Offload Enabled   ARPOFFSEL. This bit is set to 1 when the Enable IPv4 ARP Offload option is selected Value After Reset  0x0"]
    #[inline(always)]
    pub fn arpoffsel(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<9,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "IEEE 1588 2008 Timestamp Enabled   TSSEL. This bit is set to 1 when the Enable IEEE 1588 Timestamp Support option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn tssel(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<12,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Energy Efficient Ethernet Enabled   EEESEL. This bit is set to 1 when the Enable Energy Efficient Ethernet  EEE  option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn eeesel(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<13,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Transmit Checksum Offload Enabled   TXCOESEL. This bit is set to 1 when the Enable Transmit TCP IP Checksum Insertion option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn txcoesel(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<14,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Receive Checksum Offload Enabled   RXCOESEL. This bit is set to 1 when the Enable Receive TCP IP Checksum Check option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn rxcoesel(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<16,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MAC Addresses 1 31 Selected   ADDMACADRSEL. This bit is set to 1 when the Enable Additional 1 31 MAC Address Registers option is selected Value After Reset  0x1f"]
    #[inline(always)]
    pub fn addmacadrsel(
        self,
    ) -> crate::common::RegisterField<18, 0x1f, 1, 0, u8, MacHwFeature0_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<18,0x1f,1,0,u8, MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MAC Addresses 32 63 Selected   MACADR32SEL. This bit is set to 1 when the Enable Additional 32 MAC Address Registers  32 63  option is selected Value After Reset  0x0"]
    #[inline(always)]
    pub fn macadr32sel(
        self,
    ) -> crate::common::RegisterFieldBool<23, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<23,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MAC Addresses 64 127 Selected   MACADR64SEL. This bit is set to 1 when the Enable Additional 64 MAC Address Registers  64 127  option is selected Value After Reset  0x0"]
    #[inline(always)]
    pub fn macadr64sel(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<24,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Timestamp System Time Source   TSSTSSEL. This bit indicates the source of the Timestamp system time  This bit is set to 1 when the Enable IEEE 1588 Timestamp Support option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn tsstssel(
        self,
    ) -> crate::common::RegisterField<25, 0x3, 1, 0, u8, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterField::<25,0x3,1,0,u8, MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Source Address or VLAN Insertion Enable   SAVLANINS. This bit is set to 1 when the Enable SA and VLAN Insertion on Tx option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn savlanins(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<27,1,0,MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Active PHY Selected   ACTPHYSEL. When you have multiple PHY interfaces in your configuration  this field indicates the sampled value of phy intf sel i during reset de assertion  All Others  Reserved Value After Reset  0x0"]
    #[inline(always)]
    pub fn actphysel(
        self,
    ) -> crate::common::RegisterField<28, 0x7, 1, 0, u8, MacHwFeature0_SPEC, crate::common::R> {
        crate::common::RegisterField::<28,0x7,1,0,u8, MacHwFeature0_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacHwFeature0 {
    #[inline(always)]
    fn default() -> MacHwFeature0 {
        <crate::RegValueT<MacHwFeature0_SPEC> as RegisterValue<_>>::new(175993335)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacHwFeature1_SPEC;
impl crate::sealed::RegSpec for MacHwFeature1_SPEC {
    type DataType = u32;
}
#[doc = "MAC Hardware Feature Register 1\n resetvalue={Application Reset:0x0922966}"]
pub type MacHwFeature1 = crate::RegValueT<MacHwFeature1_SPEC>;

impl MacHwFeature1 {
    #[doc = "MTL Receive FIFO Size   RXFIFOSIZE. This field contains the configured value of MTL Rx FIFO in bytes expressed as Log to base 2 minus 7  that is  Log2 RXFIFO SIZE   7  01100   11111 Reserved Value After Reset  0x6"]
    #[inline(always)]
    pub fn rxfifosize(
        self,
    ) -> crate::common::RegisterField<0, 0x1f, 1, 0, u8, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterField::<0,0x1f,1,0,u8, MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Single Port RAM Enable   SPRAM. This bit is set to 1 when the Use single port RAM Feature is selected. Value After Reset  0x1"]
    #[inline(always)]
    pub fn spram(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Transmit FIFO Size   TXFIFOSIZE. This field contains the configured value of MTL Tx FIFO in bytes expressed as Log to base 2 minus 7  that is  Log2 TXFIFO SIZE   7  01011   11111 Reserved Value After Reset  0x5"]
    #[inline(always)]
    pub fn txfifosize(
        self,
    ) -> crate::common::RegisterField<6, 0x1f, 1, 0, u8, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterField::<6,0x1f,1,0,u8, MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "One Step Timestamping Enable   OSTEN. This bit is set to 1 when the Enable One Step Timestamp Feature is selected. Value After Reset  0x1"]
    #[inline(always)]
    pub fn osten(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<11,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "PTP Offload Enable   PTOEN. This bit is set to 1 when the Enable PTP Timestamp Offload Feature is selected. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ptoen(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<12,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "IEEE 1588 High Word Register Enable   ADVTHWORD. This bit is set to 1 when the Add IEEE 1588 Higher Word Register option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn advthword(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<13,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Address Width.   ADDR64. This field indicates the configured address width  Value After Reset  0x0"]
    #[inline(always)]
    pub fn addr64(
        self,
    ) -> crate::common::RegisterField<14, 0x3, 1, 0, u8, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterField::<14,0x3,1,0,u8, MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DCB Feature Enable   DCBEN. This bit is set to 1 when the Enable Data Center Bridging option is selected Value After Reset  0x0"]
    #[inline(always)]
    pub fn dcben(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<16,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Split Header Feature Enable   SPHEN. This bit is set to 1 when the Enable Split Header Structure option is selected Value After Reset  0x1"]
    #[inline(always)]
    pub fn sphen(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<17,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "TCP Segmentation Offload Enable   TSOEN. This bit is set to 1 when the Enable TCP Segmentation Offloading for TCP IP Packets option is selected Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsoen(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<18,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DMA Debug Registers Enable   DBGMEMA. This bit is set to 1 when the Debug Mode Enable option is selected Value After Reset  0x0"]
    #[inline(always)]
    pub fn dbgmema(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<19,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "AV Feature Enable   AVSEL. This bit is set to 1 when the Enable Audio Video Bridging option is selected. Value After Reset  0x1"]
    #[inline(always)]
    pub fn avsel(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<20,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Rx Side Only AV Feature Enable   RAVSEL. This bit is set to 1 when the Enable Audio Video Bridging option on Rx Side Only is selected. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ravsel(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<21,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "One Step for PTP over UDP IP Feature Enable   POUOST. This bit is set to 1 when the Enable One step timestamp for PTP over UDP IP feature is selected. Value After Reset  0x1"]
    #[inline(always)]
    pub fn pouost(
        self,
    ) -> crate::common::RegisterFieldBool<23, 1, 0, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<23,1,0,MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Hash Table Size   HASHTBLSZ. This field indicates the size of the hash table  Value After Reset  0x0"]
    #[inline(always)]
    pub fn hashtblsz(
        self,
    ) -> crate::common::RegisterField<24, 0x3, 1, 0, u8, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterField::<24,0x3,1,0,u8, MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Total number of L3 or L4 Filters   L3L4FNUM. This field indicates the total number of L3 or L4 filters  LOST SEQUENCE DEFINITION Value After Reset  0x0"]
    #[inline(always)]
    pub fn l3l4fnum(
        self,
    ) -> crate::common::RegisterField<27, 0xf, 1, 0, u8, MacHwFeature1_SPEC, crate::common::R> {
        crate::common::RegisterField::<27,0xf,1,0,u8, MacHwFeature1_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacHwFeature1 {
    #[inline(always)]
    fn default() -> MacHwFeature1 {
        <crate::RegValueT<MacHwFeature1_SPEC> as RegisterValue<_>>::new(9578854)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacHwFeature2_SPEC;
impl crate::sealed::RegSpec for MacHwFeature2_SPEC {
    type DataType = u32;
}
#[doc = "MAC Hardware Feature Register 2\n resetvalue={Application Reset:0x10C30C3}"]
pub type MacHwFeature2 = crate::RegValueT<MacHwFeature2_SPEC>;

impl MacHwFeature2 {
    #[doc = "Number of MTL Receive Queues   RXQCNT. This field indicates the number of MTL Receive queues  LOST SEQUENCE DEFINITION Value After Reset  0x3"]
    #[inline(always)]
    pub fn rxqcnt(
        self,
    ) -> crate::common::RegisterField<0, 0xf, 1, 0, u8, MacHwFeature2_SPEC, crate::common::R> {
        crate::common::RegisterField::<0,0xf,1,0,u8, MacHwFeature2_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of MTL Transmit Queues   TXQCNT. This field indicates the number of MTL Transmit queues  LOST SEQUENCE DEFINITION Value After Reset  0x3"]
    #[inline(always)]
    pub fn txqcnt(
        self,
    ) -> crate::common::RegisterField<6, 0xf, 1, 0, u8, MacHwFeature2_SPEC, crate::common::R> {
        crate::common::RegisterField::<6,0xf,1,0,u8, MacHwFeature2_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of DMA Receive Channels   RXCHCNT. This field indicates the number of DMA Receive channels  LOST SEQUENCE DEFINITION Value After Reset  0x3"]
    #[inline(always)]
    pub fn rxchcnt(
        self,
    ) -> crate::common::RegisterField<12, 0xf, 1, 0, u8, MacHwFeature2_SPEC, crate::common::R> {
        crate::common::RegisterField::<12,0xf,1,0,u8, MacHwFeature2_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of DMA Transmit Channels   TXCHCNT. This field indicates the number of DMA Transmit channels  LOST SEQUENCE DEFINITION Value After Reset  0x3"]
    #[inline(always)]
    pub fn txchcnt(
        self,
    ) -> crate::common::RegisterField<18, 0xf, 1, 0, u8, MacHwFeature2_SPEC, crate::common::R> {
        crate::common::RegisterField::<18,0xf,1,0,u8, MacHwFeature2_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of PPS Outputs   PPSOUTNUM. This field indicates the number of PPS outputs  101   111 Reserved Value After Reset  0x1"]
    #[inline(always)]
    pub fn ppsoutnum(
        self,
    ) -> crate::common::RegisterField<24, 0x7, 1, 0, u8, MacHwFeature2_SPEC, crate::common::R> {
        crate::common::RegisterField::<24,0x7,1,0,u8, MacHwFeature2_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of Auxiliary Snapshot Inputs   AUXSNAPNUM. This field indicates the number of auxiliary snapshot inputs  101   111 Reserved Value After Reset  0x0"]
    #[inline(always)]
    pub fn auxsnapnum(
        self,
    ) -> crate::common::RegisterField<28, 0x7, 1, 0, u8, MacHwFeature2_SPEC, crate::common::R> {
        crate::common::RegisterField::<28,0x7,1,0,u8, MacHwFeature2_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacHwFeature2 {
    #[inline(always)]
    fn default() -> MacHwFeature2 {
        <crate::RegValueT<MacHwFeature2_SPEC> as RegisterValue<_>>::new(17576131)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacHwFeature3_SPEC;
impl crate::sealed::RegSpec for MacHwFeature3_SPEC {
    type DataType = u32;
}
#[doc = "MAC Hardware Feature Register 3\n resetvalue={Application Reset:0x320032}"]
pub type MacHwFeature3 = crate::RegValueT<MacHwFeature3_SPEC>;

impl MacHwFeature3 {
    #[doc = "Number of Extended VLAN Tag Filters Enabled   NRVF. This field indicates the Number of Extended VLAN Tag Filters selected  110   111 Reserved Value After Reset  0x2"]
    #[inline(always)]
    pub fn nrvf(
        self,
    ) -> crate::common::RegisterField<0, 0x7, 1, 0, u8, MacHwFeature3_SPEC, crate::common::R> {
        crate::common::RegisterField::<0,0x7,1,0,u8, MacHwFeature3_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Queue Channel based VLAN tag insertion on Tx Enable   CBTISEL. This bit is set to 1 when the Enable Queue Channel based VLAN tag        insertion on Tx Feature is selected. Value After Reset  0x1"]
    #[inline(always)]
    pub fn cbtisel(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MacHwFeature3_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MacHwFeature3_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "DVLAN. Value After Reset  0x1"]
    #[inline(always)]
    pub fn dvlan(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MacHwFeature3_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MacHwFeature3_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacHwFeature3 {
    #[inline(always)]
    fn default() -> MacHwFeature3 {
        <crate::RegValueT<MacHwFeature3_SPEC> as RegisterValue<_>>::new(3276850)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacInnerVlanInclI_SPEC;
impl crate::sealed::RegSpec for MacInnerVlanInclI_SPEC {
    type DataType = u32;
}
#[doc = "MAC Inner VLAN Tag Inclusion or Replacement Register\n resetvalue={Application Reset:0x0}"]
pub type MacInnerVlanInclI = crate::RegValueT<MacInnerVlanInclI_SPEC>;

impl MacInnerVlanInclI {
    #[doc = "VLAN Tag for Transmit Packets   VLT. This field contains the value of the VLAN tag to be inserted or        replaced. The value must only be changed when the transmit lines are        inactive or during the initialization phase. Bits 15 13  are the User Priority field  Bit 12 is the CFI DEI field         and Bits 11 0  are the VID field in the VLAN tag. The following list describes the bits of this field  Bits 15 13   User Priority Bit 12  Canonical Format Indicator  CFI  or Drop Eligible Indicator           DEI  Bits 11 0   VLAN Identifier  VID  field of VLAN tag Value After Reset  0x0"]
    #[inline(always)]
    pub fn vlt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacInnerVlanInclI_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            MacInnerVlanInclI_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "VLAN Tag Control in Transmit Packets   VLC. The MAC removes the VLAN type  bytes 17 and 18  and VLAN tag  bytes 19 and 20  of all transmitted packets with VLAN tags. The MAC inserts VLT in bytes 19 and 20 of the packet after inserting the Type value  0x8100 or 0x88a8  in bytes 17 and 18. This operation is performed on all transmitted packets  irrespective of whether they already have a VLAN tag. The MAC replaces VLT in bytes 19 and 20 of all VLAN type transmitted packets  Bytes 17 and 18 are 0x8100 or 0x88a8 . Note   Changes to this field take effect only on the start of a packet. If you write this register field when a packet is being transmitted  only the subsequent packet can use the updated value  that is  the current packet does not use the updated value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vlc(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacInnerVlanInclI_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacInnerVlanInclI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Priority Control   VLP. When this bit is set  the VLC field is used for VLAN deletion  insertion  or replacement. When this bit is reset  the mti vlan ctrl i control input is used and the VLC field is ignored. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vlp(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacInnerVlanInclI_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<18,1,0,MacInnerVlanInclI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "C VLAN or S VLAN   CSVL. When this bit is set  S VLAN type  0x88A8  is inserted or replaced in the 13th and 14th bytes of transmitted packets. When this bit is reset  C VLAN type  0x8100  is inserted or replaced in the 13th and 14th bytes of transmitted packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn csvl(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MacInnerVlanInclI_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<19,1,0,MacInnerVlanInclI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Tag Input   VLTI. When this bit is set  it indicates that the VLAN tag to be inserted or replaced in Tx packet should be taken from  The Tx descriptor Value After Reset  0x0"]
    #[inline(always)]
    pub fn vlti(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MacInnerVlanInclI_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<20,1,0,MacInnerVlanInclI_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacInnerVlanInclI {
    #[inline(always)]
    fn default() -> MacInnerVlanInclI {
        <crate::RegValueT<MacInnerVlanInclI_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacInterruptEnable_SPEC;
impl crate::sealed::RegSpec for MacInterruptEnable_SPEC {
    type DataType = u32;
}
#[doc = "MAC Interrupt Enable Register\n resetvalue={Application Reset:0x0}"]
pub type MacInterruptEnable = crate::RegValueT<MacInterruptEnable_SPEC>;

impl MacInterruptEnable {
    #[doc = "RGMII or SMII Interrupt Enable   RGSMIIIE. When this bit is set  it enables the assertion of the interrupt signal because of the setting of RGSMIIIS bit in MAC Interrupt Status register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rgsmiiie(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacInterruptEnable_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MacInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "PHY Interrupt Enable   PHYIE. When this bit is set  it enables the assertion of the interrupt signal because of the setting of PHYIS bit in MAC Interrupt Status register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn phyie(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MacInterruptEnable_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MacInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "PMT Interrupt Enable   PMTIE. When this bit is set  it enables the assertion of the interrupt signal        because of the setting of PMTIS bit in MAC Interrupt Status register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn pmtie(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MacInterruptEnable_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<4,1,0,MacInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "LPI Interrupt Enable   LPIIE. When this bit is set  it enables the assertion of the interrupt signal because of the setting of LPIIS bit in MAC Interrupt Status register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lpiie(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MacInterruptEnable_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<5,1,0,MacInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Timestamp Interrupt Enable   TSIE. When this bit is set  it enables the assertion of the interrupt signal because of the setting of TSIS bit in MAC Interrupt Status register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsie(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MacInterruptEnable_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<12,1,0,MacInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Status Interrupt Enable   TXSTSIE. When this bit is set  it enables the assertion of the interrupt signal because of the setting of TXSTSIS bit in the MAC Interrupt Status register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txstsie(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MacInterruptEnable_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<13,1,0,MacInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Status Interrupt Enable   RXSTSIE. When this bit is set  it enables the assertion of the interrupt signal        because of the setting of RXSTSIS bit in the MAC Interrupt Status        register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxstsie(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, MacInterruptEnable_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<14,1,0,MacInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MDIO Interrupt Enable   MDIOIE. MDIO Interrupt Enable  When this bit is set  it enables the assertion of        the interrupt when MDIOIS field is set in the MAC Interrupt Status        register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mdioie(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacInterruptEnable_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<18,1,0,MacInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacInterruptEnable {
    #[inline(always)]
    fn default() -> MacInterruptEnable {
        <crate::RegValueT<MacInterruptEnable_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacInterruptStatus_SPEC;
impl crate::sealed::RegSpec for MacInterruptStatus_SPEC {
    type DataType = u32;
}
#[doc = "MAC Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
pub type MacInterruptStatus = crate::RegValueT<MacInterruptStatus_SPEC>;

impl MacInterruptStatus {
    #[doc = "RGMII or SMII Interrupt Status   RGSMIIIS. This bit is set because of any change in value of the Link Status of        RGMII or SMII interface  LNKSTS bit in MAC PHYIF Control Status        register . This bit is cleared when the MAC PHYIF Control Status        register is read  or LNKSTS bit of MAC PHYIF Control Status register is        written to 1 when RCWE bit of MAC CSR SW Ctrl register is set . Value After Reset  0x0"]
    #[inline(always)]
    pub fn rgsmiiis(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "PHY Interrupt   PHYIS. This bit is set when rising edge is detected on the phy intr i input.        This bit is cleared when this register is read  or this bit is written to 1 when RCWE bit of MAC CSR SW Ctrl register is set . Value After Reset  0x0"]
    #[inline(always)]
    pub fn phyis(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "PMT Interrupt Status   PMTIS. This bit is set when a Magic packet or Wake on LAN packet is received in        the powerdown mode  RWKPRCVD and MGKPRCVD bits in MAC PMT Control Status        register . This bit is cleared when corresponding interrupt source bit        are cleared because of a Read operation to the MAC PMT Control Status        register  or corresponding interrupt source bit of        MAC PMT Control Status register is written to 1 when RCWE bit of        MAC CSR SW Ctrl register is set . Value After Reset  0x0"]
    #[inline(always)]
    pub fn pmtis(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "LPI Interrupt Status   LPIIS. When the Energy Efficient Ethernet feature is enabled  this bit is set        for any LPI state entry or exit in the MAC Transmitter or Receiver. This        bit is cleared when the corresponding interrupt source bit of        MAC LPI Control Status register is read  or corresponding interrupt        source bit of MAC LPI Control Status register is written to 1 when RCWE        bit of MAC CSR SW Ctrl register is set . Value After Reset  0x0"]
    #[inline(always)]
    pub fn lpiis(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Interrupt Status   MMCIS. This bit is set high when Bit 11  Bit 10  or Bit 9 is set high. This bit is cleared only when all these bits are low. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mmcis(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<8,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Interrupt Status   MMCRXIS. This bit is set high when an interrupt is generated in the MMC Receive Interrupt Register. This bit is cleared when all bits in this interrupt register are cleared. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mmcrxis(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<9,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Interrupt Status   MMCTXIS. This bit is set high when an interrupt is generated in the MMC Transmit Interrupt Register. This bit is cleared when all bits in this interrupt register are cleared. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mmctxis(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<10,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Checksum Offload Interrupt Status   MMCRXIPIS. This bit is set high when an interrupt is generated in the MMC Receive Checksum Offload Interrupt Register. This bit is cleared when all bits in this interrupt register are cleared. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mmcrxipis(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<11,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Timestamp Interrupt Status   TSIS. If the Timestamp feature is enabled  this bit is set when any of the        following conditions is true  The system time value is equal to or exceeds the value specified in          the Target Time High and Low registers. There is an overflow in the Seconds register. The Target Time Error occurred  that is  programmed target time          already elapsed. In configurations other than EQOS CORE  when drop transmit status is        enabled in MTL  this bit is set when the captured transmit timestamp is        updated in the MAC Tx Timestamp Status Nanoseconds and        Mac TxTimestamp Status Seconds registers. This bit is cleared when the corresponding interrupt source bit is read         or corresponding interrupt source bit is written to 1 when RCWE bit of        MAC CSR SW Ctrl register is set  in the MAC Timestamp Status register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsis(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<12,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Transmit Status Interrupt   TXSTSIS. This bit indicates the status of transmitted packets. This bit is set        when any of the following bits is set in the MAC Rx Tx Status register  Excessive Collision  EXCOL  Late Collision  LCOL  Excessive Deferral  EXDEF  Loss of Carrier  LCARR  No Carrier  NCARR  Jabber Timeout  TJT  This bit is cleared when the corresponding interrupt source bit is read         or corresponding interrupt source bit is written to 1 when RCWE bit of        MAC CSR SW Ctrl register is set  in the MAC Rx Tx Status register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txstsis(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<13,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Receive Status Interrupt   RXSTSIS. This bit indicates the status of received packets. This bit is set when        the RWT bit is set in the MAC Rx Tx Status register. This bit is cleared        when the corresponding interrupt source bit is read  or corresponding        interrupt source bit is written to 1 when RCWE bit of MAC CSR SW Ctrl        register is set  in the MAC Rx Tx Status register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxstsis(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<14,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MDIO Interrupt Status   MDIOIS. This bit indicates an interrupt event after the completion of MDIO operation. To reset this bit         the application has to read this bit Write 1 to this bit when RCWE bit of MAC CSR SW Ctrl register is set.       Access restriction applies. Clears on read  or write of 1 when RCWE bit in MAC CSR SW Ctrl register is set .        Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mdiois(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<18,1,0,MacInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacInterruptStatus {
    #[inline(always)]
    fn default() -> MacInterruptStatus {
        <crate::RegValueT<MacInterruptStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacLpiControlStatus_SPEC;
impl crate::sealed::RegSpec for MacLpiControlStatus_SPEC {
    type DataType = u32;
}
#[doc = "MAC LPI Control and Status Register\n resetvalue={Application Reset:0x0}"]
pub type MacLpiControlStatus = crate::RegValueT<MacLpiControlStatus_SPEC>;

impl MacLpiControlStatus {
    #[doc = "Transmit LPI Entry   TLPIEN. When this bit is set  it indicates that the MAC Transmitter has entered        the LPI state because of the setting of the LPIEN bit. This bit is        cleared by a read into this register  or this bit is written to 1 when        RCWE bit in MAC CSR SW Ctrl register is set . Value After Reset  0x0"]
    #[inline(always)]
    pub fn tlpien(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacLpiControlStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MacLpiControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Transmit LPI Exit   TLPIEX. When this bit is set  it indicates that the MAC transmitter exited the        LPI state after the application cleared the LPIEN bit and the LPI TW        Timer has expired. This bit is cleared by a read into this register  or        this bit is written to 1 when RCWE bit in MAC CSR SW Ctrl register is        set . Value After Reset  0x0"]
    #[inline(always)]
    pub fn tlpiex(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacLpiControlStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1,1,0,MacLpiControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Receive LPI Entry   RLPIEN. When this bit is set  it indicates that the MAC Receiver has received an        LPI pattern and entered the LPI state. This bit is cleared by a read        into this register  or this bit is written to 1 when RCWE bit in        MAC CSR SW Ctrl register is set . Note   This bit may not be set if the MAC        stops receiving the LPI pattern for a very short duration  such as  less        than three clock cycles of CSR clock. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rlpien(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MacLpiControlStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<2,1,0,MacLpiControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Receive LPI Exit   RLPIEX. When this bit is set  it indicates that the MAC Receiver has stopped receiving the LPI pattern on the GMII or MII interface  exited the LPI state  and resumed the normal reception. This bit is cleared by a read into this register  or this bit is written to 1 when RCWE bit in MAC CSR SW Ctrl register is set . Note   This bit may not be set if the MAC stops receiving the LPI pattern for a very short duration  such as  less than three clock cycles of CSR clock. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rlpiex(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MacLpiControlStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MacLpiControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Transmit LPI State   TLPIST. When this bit is set  it indicates that the MAC is transmitting the LPI pattern on the GMII or MII interface. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tlpist(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacLpiControlStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<8,1,0,MacLpiControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Receive LPI State   RLPIST. When this bit is set  it indicates that the MAC is receiving the LPI pattern on the GMII or MII interface. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rlpist(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MacLpiControlStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<9,1,0,MacLpiControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "LPI Enable   LPIEN. When this bit is set  it instructs the MAC Transmitter to enter the LPI state. When this bit is reset  it instructs the MAC to exit the LPI state and resume normal transmission. This bit is cleared when the LPITXA bit is set and the MAC exits the LPI state because of the arrival of a new packet for transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lpien(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacLpiControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<16,1,0,MacLpiControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "PHY Link Status   PLS. This bit indicates the link status of the PHY. The MAC Transmitter asserts the LPI pattern only when the link status is up  OKAY  at least for the time indicated by the LPI LS TIMER. When this bit is set  the link is considered to be okay  UP  and when this bit is reset  the link is considered to be down. Value After Reset  0x0"]
    #[inline(always)]
    pub fn pls(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MacLpiControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<17,1,0,MacLpiControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "PHY Link Status Enable   PLSEN. This bit enables the link status received on the RGMII  SGMII  or SMII Receive paths to be used for activating the LPI LS TIMER. When this bit is set  the MAC uses the link status bits of the MAC PHYIF Control Status register and the PLS bit for the LPI LS Timer trigger. When this bit is reset  the MAC ignores the link status bits of the MAC PHYIF Control Status register and takes only the PLS bit. Value After Reset  0x0"]
    #[inline(always)]
    pub fn plsen(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacLpiControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<18,1,0,MacLpiControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "LPI Tx Automate   LPITXA. This bit controls the behavior of the MAC when it is entering or coming out of the LPI mode on the Transmit side. This bit is not functional in the EQOS CORE configurations in which the Tx clock gating is done during the LPI mode. If the LPITXA and LPIEN bits are set to 1  the MAC enters the LPI mode only after all outstanding packets  in the core  and pending packets  in the application interface  have been transmitted. The MAC comes out of the LPI mode when the application sends any packet for transmission or the application issues a Tx FIFO Flush command. In addition  the MAC automatically clears the LPIEN bit when it exits the LPI state. If Tx FIFO Flush is set in the FTQ bit of MTL TxQ0 Operation Mode register  when the MAC is in the LPI mode  it exits the LPI mode. When this bit is 0  the LPIEN bit directly controls behavior of the MAC when it is entering or coming out of the LPI mode. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lpitxa(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MacLpiControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<19,1,0,MacLpiControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "LPI Timer Enable   LPIATE. This bit controls the automatic entry of the MAC Transmitter into and        exit out of the LPI state. When LPIATE  LPITXA and LPIEN bits are set         the MAC Transmitter enters LPI state only when the complete MAC TX data        path is IDLE for a period indicated by the MAC LPI Entry Timer register.        After entering LPI state  if the data path becomes non IDLE  due to a        new packet being accepted for transmission   the Transmitter exits LPI        state but does not clear LPIEN bit. This enables the re entry into LPI        state when it is IDLE again. When LPIATE is 0  the LPI Auto timer is        disabled and MAC Transmitter enters LPI state based on the settings of        LPITXA and LPIEN bit descriptions. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lpiate(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MacLpiControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<20,1,0,MacLpiControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "LPI Tx Clock Stop Enable   LPITCSE. When this bit is set  the MAC asserts sbd tx clk gating ctrl o signal high after it enters Tx LPI mode to indicate that the Tx clock to MAC can be stopped. When this bit is reset  the MAC does not assert sbd tx clk gating ctrl o signal high after it enters Tx LPI mode. If RGMII Interface is selected  the Tx clock is required for transmitting the LPI pattern. The Tx Clock cannot be gated and so the LPITCSE bit cannot be programmed. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lpitcse(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MacLpiControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<21,1,0,MacLpiControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacLpiControlStatus {
    #[inline(always)]
    fn default() -> MacLpiControlStatus {
        <crate::RegValueT<MacLpiControlStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacLpiEntryTimer_SPEC;
impl crate::sealed::RegSpec for MacLpiEntryTimer_SPEC {
    type DataType = u32;
}
#[doc = "MAC LPI Entry Timer Register\n resetvalue={Application Reset:0x0}"]
pub type MacLpiEntryTimer = crate::RegValueT<MacLpiEntryTimer_SPEC>;

impl MacLpiEntryTimer {
    #[doc = "LPI Entry Timer   LPIET. This field specifies the time in microseconds the MAC waits to enter LPI mode  after it has transmitted all the frames. This field is valid and used only when LPITE and LPITXA are set to 1. Bits  2 0  are read only so that the granularity of this timer is in steps of 8 micro seconds. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lpiet(
        self,
    ) -> crate::common::RegisterField<3, 0x1ffff, 1, 0, u32, MacLpiEntryTimer_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<
            3,
            0x1ffff,
            1,
            0,
            u32,
            MacLpiEntryTimer_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacLpiEntryTimer {
    #[inline(always)]
    fn default() -> MacLpiEntryTimer {
        <crate::RegValueT<MacLpiEntryTimer_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacLpiTimersControl_SPEC;
impl crate::sealed::RegSpec for MacLpiTimersControl_SPEC {
    type DataType = u32;
}
#[doc = "MAC LPI Timers Control Register\n resetvalue={Application Reset:0x3E80000}"]
pub type MacLpiTimersControl = crate::RegValueT<MacLpiTimersControl_SPEC>;

impl MacLpiTimersControl {
    #[doc = "LPI TW Timer   TWT. This field specifies the minimum time  in microseconds  for which the MAC waits after it stops transmitting the LPI pattern to the PHY and before it resumes the normal transmission. The TLPIEX status bit is set after the expiry of this timer. Value After Reset  0x0"]
    #[inline(always)]
    pub fn twt(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        MacLpiTimersControl_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            MacLpiTimersControl_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "LPI LS Timer   LST. This field specifies the minimum time  in milliseconds  for which the link status from the PHY should be up  OKAY  before the LPI pattern can be transmitted to the PHY. The MAC does not transmit the LPI pattern even when the LPIEN bit is set unless the LPI LS Timer reaches the programmed terminal count. The default value of the LPI LS Timer is 1000  1 sec  as defined in the IEEE standard. Value After Reset 0x3e8"]
    #[inline(always)]
    pub fn lst(
        self,
    ) -> crate::common::RegisterField<
        16,
        0x3ff,
        1,
        0,
        u16,
        MacLpiTimersControl_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            16,
            0x3ff,
            1,
            0,
            u16,
            MacLpiTimersControl_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacLpiTimersControl {
    #[inline(always)]
    fn default() -> MacLpiTimersControl {
        <crate::RegValueT<MacLpiTimersControl_SPEC> as RegisterValue<_>>::new(65536000)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacMdioAddress_SPEC;
impl crate::sealed::RegSpec for MacMdioAddress_SPEC {
    type DataType = u32;
}
#[doc = "MAC MDIO Address Register\n resetvalue={Application Reset:0x0}"]
pub type MacMdioAddress = crate::RegValueT<MacMdioAddress_SPEC>;

impl MacMdioAddress {
    #[doc = "GMII Busy   GB. The application sets this bit to instruct the SMA to initiate a Read or Write access to the MDIO slave. The MAC clears this bit after the MDIO frame transfer is completed. Hence the software must not write or change any of the fields in MAC MDIO Address and MAC MDIO Data registers as long as this bit is set. For write transfers  the application must first write 16 bit data in the GDl field  and also RA field when C45E is set  in MAC MDIO Data register before setting this bit. When C45E is set  it should also write into the RA field of MAC MDIO Data register before initiating a read transfer. When a read transfer is completed  GB 0   the data read from the PHY register is valid in the GD field of the MAC MDIO Data register. Note   Even if the addressed PHY is not present  there is no change in the functionality of this bit. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn gb(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacMdioAddress_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Clause 45 PHY Enable   C45E. When this bit is set  Clause 45 capable PHY is connected to MDIO. When this bit is reset  Clause 22 capable PHY is connected to MDIO. Value After Reset  0x0"]
    #[inline(always)]
    pub fn c45e(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacMdioAddress_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1,1,0,MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "GMII Operation Command 0   GOC 0. This is the lower bit of the operation command to the PHY or RevMII. When in SMA mode  MDIO master  this bit along with GOC 1 determines the operation to be performed to the PHY. When only RevMII is selected in configuration this bit is read only and tied to 1. Value After Reset  0x0"]
    #[inline(always)]
    pub fn goc_0(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MacMdioAddress_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<2,1,0,MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "GMII Operation Command 1   GOC 1. This bit is higher bit of the operation command to the PHY or RevMII  GOC 1 and GOC O is encoded as follows  00 Reserved 01 Write 10 Post Read Increment Address for Clause 45 PHY 11 Read When Clause 22 PHY or RevMII is enabled  only Write and Read commands are valid. Value After Reset  0x0"]
    #[inline(always)]
    pub fn goc_1(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MacMdioAddress_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Skip Address Packet   SKAP. When this bit is set  the SMA does not send the address packets before read  write  or post read increment address packets. This bit is valid only when C45E is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn skap(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MacMdioAddress_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<4,1,0,MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "CSR Clock Range   CR. The CSR Clock Range selection determines the frequency of the MDC clock according to the CSR clock frequency used in your design  0110   0111 Reserved The suggested range of CSR clock frequency applicable for each value  when Bit 11   0  ensures that the MDC clock is approximately between 1.0 MHz to 2.5 MHz frequency range. When Bit 11 is set  you can achieve a higher frequency of the MDC clock than the frequency limit of 2.5 MHz  specified in the IEEE 802.3  and program a clock divider of lower value. For example  when CSR clock is of 100 MHz frequency and you program these bits as 1010  the resultant MDC clock is of 12.5 MHz which is above the range specified in IEEE 802.3. Program the following values only if the interfacing chips support faster MDC clocks  These bits are not used for accessing RevMII. These bits are read only if the RevMII interface is selected as single PHY interface. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cr(
        self,
    ) -> crate::common::RegisterField<8, 0xf, 1, 0, u8, MacMdioAddress_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<8,0xf,1,0,u8, MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Number of Trailing Clocks   NTC. This field controls the number of trailing clock cycles generated on        gmii mdc o  MDC  after the end of transmission of MDIO frame. The valid        values can be from 0 to 7. Programming the value to 3 h3 indicates that        there are additional three clock cycles on the MDC line after the end of        MDIO frame transfer. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ntc(
        self,
    ) -> crate::common::RegisterField<12, 0x7, 1, 0, u8, MacMdioAddress_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<12,0x7,1,0,u8, MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Register Device Address   RDA. These bits select the PHY register in selected Clause 22 PHY device. These bits select the Device  MMD  in selected Clause 45 capable PHY. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rda(
        self,
    ) -> crate::common::RegisterField<16, 0x1f, 1, 0, u8, MacMdioAddress_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x1f,1,0,u8, MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Physical Layer Address   PA. This field indicates which Clause 22 PHY devices  out of 32 devices  the MAC is accessing. This field indicates which Clause 45 capable PHYs  out of 32 PHYs  the MAC is accessing. Value After Reset  0x0"]
    #[inline(always)]
    pub fn pa(
        self,
    ) -> crate::common::RegisterField<21, 0x1f, 1, 0, u8, MacMdioAddress_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<21,0x1f,1,0,u8, MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Back to Back transactions   BTB. When this bit is set and the NTC has value greater than 0  then the MAC informs the completion of a read or write command at the end of frame transfer  before the trailing clocks are transmitted . The software can thus initiate the next command which is executed immediately irrespective of the number trailing clocks generated for the previous frame. When this bit is reset  then the read write command completion  GB is cleared  only after the trailing clocks are generated. In this mode  it is ensured that the NTC is always generated after each frame. This bit must not be set when NTC 0. Value After Reset  0x0"]
    #[inline(always)]
    pub fn btb(
        self,
    ) -> crate::common::RegisterFieldBool<26, 1, 0, MacMdioAddress_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<26,1,0,MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Preamble Suppression Enable   PSE. When this bit is set  the SMA  suppresses the 32 bit preamble and transmits MDIO frames with only 1 preamble bit. When this bit is 0  the MDIO frame always has 32 bits of preamble as defined in the IEEE specifications. Value After Reset  0x0"]
    #[inline(always)]
    pub fn pse(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, MacMdioAddress_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<27,1,0,MacMdioAddress_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacMdioAddress {
    #[inline(always)]
    fn default() -> MacMdioAddress {
        <crate::RegValueT<MacMdioAddress_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacMdioData_SPEC;
impl crate::sealed::RegSpec for MacMdioData_SPEC {
    type DataType = u32;
}
#[doc = "MAC MDIO Data Register\n resetvalue={Application Reset:0x0}"]
pub type MacMdioData = crate::RegValueT<MacMdioData_SPEC>;

impl MacMdioData {
    #[doc = "GMII Data   GD. This field contains the 16 bit data value read from the PHY or RevMII        after a Management Read operation or the 16 bit data value to be written        to the PHY or RevMII before a Management Write operation. Value After Reset  0x0"]
    #[inline(always)]
    pub fn gd(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacMdioData_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacMdioData_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Register Address   RA. This field is valid only when C45E is set. It contains the Register Address in the PHY to which the MDIO frame is intended for. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ra(
        self,
    ) -> crate::common::RegisterField<16, 0xffff, 1, 0, u16, MacMdioData_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0xffff,1,0,u16, MacMdioData_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacMdioData {
    #[inline(always)]
    fn default() -> MacMdioData {
        <crate::RegValueT<MacMdioData_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacPacketFilter_SPEC;
impl crate::sealed::RegSpec for MacPacketFilter_SPEC {
    type DataType = u32;
}
#[doc = "MAC Packet Filter Register\n resetvalue={Application Reset:0x0}"]
pub type MacPacketFilter = crate::RegValueT<MacPacketFilter_SPEC>;

impl MacPacketFilter {
    #[doc = "Promiscuous Mode   PR. When this bit is set  the Address Filtering module passes all incoming packets irrespective of the destination or source address. The SA or DA Filter Fails status bits of the Rx Status Word are always cleared when PR is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn pr(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacPacketFilter_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MacPacketFilter_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DA Inverse Filtering   DAIF. When this bit is set  the Address Check block operates in inverse filtering mode for the DA address comparison for both unicast and multicast packets. When this bit is reset  normal filtering of packets is performed. Value After Reset  0x0"]
    #[inline(always)]
    pub fn daif(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MacPacketFilter_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MacPacketFilter_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Pass All Multicast   PM. When this bit is set  it indicates that all received packets with a multicast destination address  first bit in the destination address field is  1   are passed. Value After Reset  0x0"]
    #[inline(always)]
    pub fn pm(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MacPacketFilter_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<4,1,0,MacPacketFilter_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Disable Broadcast Packets   DBF. When this bit is set  the AFM module blocks all incoming broadcast packets. In addition  it overrides all other filter settings. When this bit is reset  the AFM module passes all received broadcast packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dbf(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MacPacketFilter_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<5,1,0,MacPacketFilter_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Pass Control Packets   PCF. These bits control the forwarding of all control packets  including unicast and multicast Pause packets . Value After Reset  0x0"]
    #[inline(always)]
    pub fn pcf(
        self,
    ) -> crate::common::RegisterField<6, 0x3, 1, 0, u8, MacPacketFilter_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<6,0x3,1,0,u8, MacPacketFilter_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "SA Inverse Filtering   SAIF. When this bit is set  the Address Check block operates in the inverse filtering mode for SA address comparison. If the SA of a packet matches the values programmed in the SA registers  it is marked as failing the SA Address filter. When this bit is reset  if the SA of a packet does not match the values programmed in the SA registers  it is marked as failing the SA Address filter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn saif(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacPacketFilter_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<8,1,0,MacPacketFilter_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Source Address Filter Enable   SAF. When this bit is set  the MAC compares the SA field of the received packets with the values programmed in the enabled SA registers. If the comparison fails  the MAC drops the packet. When this bit is reset  the MAC forwards the received packet to the application with updated SAF bit of the Rx Status depending on the SA address comparison. Note   According to the IEEE specification  Bit 47 of the SA is reserved. However  in DWC ether qos  the MAC compares all 48 bits. The software driver should take this into consideration while programming the MAC address registers for SA. Value After Reset  0x0"]
    #[inline(always)]
    pub fn saf(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MacPacketFilter_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<9,1,0,MacPacketFilter_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Tag Filter Enable   VTFE. When this bit is set  the MAC drops the VLAN tagged packets that do not match the VLAN Tag. When this bit is reset  the MAC forwards all packets irrespective of the match status of the VLAN Tag. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vtfe(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacPacketFilter_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<16,1,0,MacPacketFilter_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive All   RA. When this bit is set  the MAC Receiver module passes all received packets to the application  irrespective of whether they pass the address filter or not. The result of the SA or DA filtering is updated  pass or fail  in the corresponding bit in the Rx Status Word. When this bit is reset  the Receiver module passes only those packets to the application that pass the SA or DA address filter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ra(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacPacketFilter_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacPacketFilter_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacPacketFilter {
    #[inline(always)]
    fn default() -> MacPacketFilter {
        <crate::RegValueT<MacPacketFilter_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacPhyifControlStatus_SPEC;
impl crate::sealed::RegSpec for MacPhyifControlStatus_SPEC {
    type DataType = u32;
}
#[doc = "MAC PHY Interface Control and Status Register\n resetvalue={Application Reset:0x0}"]
pub type MacPhyifControlStatus = crate::RegValueT<MacPhyifControlStatus_SPEC>;

impl MacPhyifControlStatus {
    #[doc = "Transmit Configuration in RGMII  SGMII  or SMII   TC. When set  this bit enables the transmission of duplex mode  link speed  and link up or down information to the PHY in the RGMII  SMII  or SGMII port. When this bit is reset  no such information is driven to the PHY. The details of this feature are provided in the following sections   Reduced Gigabit Media Independent Interface   Serial Media Independent Interface   Serial Gigabit Media Independent Interface  Value After Reset  0x0"]
    #[inline(always)]
    pub fn tc(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacPhyifControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<0,1,0,MacPhyifControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Link Up or Down   LUD. This bit indicates whether the link is up or down during transmission of configuration in the RGMII  SGMII  or SMII interface  Value After Reset  0x0"]
    #[inline(always)]
    pub fn lud(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacPhyifControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<1,1,0,MacPhyifControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Link Mode   LNKMOD. This bit indicates the current mode of operation of the link  Value After Reset  0x0"]
    #[inline(always)]
    pub fn lnkmod(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacPhyifControlStatus_SPEC, crate::common::R>
    {
        crate::common::RegisterFieldBool::<16,1,0,MacPhyifControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Link Speed   LNKSPEED. This bit indicates the current speed of the link  Value After Reset  0x0"]
    #[inline(always)]
    pub fn lnkspeed(
        self,
    ) -> crate::common::RegisterField<17, 0x3, 1, 0, u8, MacPhyifControlStatus_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<
            17,
            0x3,
            1,
            0,
            u8,
            MacPhyifControlStatus_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Link Status   LNKSTS. This bit indicates whether the link is up  1 b1  or down  1 b0 . Value After Reset  0x0"]
    #[inline(always)]
    pub fn lnksts(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MacPhyifControlStatus_SPEC, crate::common::R>
    {
        crate::common::RegisterFieldBool::<19,1,0,MacPhyifControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacPhyifControlStatus {
    #[inline(always)]
    fn default() -> MacPhyifControlStatus {
        <crate::RegValueT<MacPhyifControlStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacPmtControlStatus_SPEC;
impl crate::sealed::RegSpec for MacPmtControlStatus_SPEC {
    type DataType = u32;
}
#[doc = "MAC PMT Control and Status Register\n resetvalue={Application Reset:0x0}"]
pub type MacPmtControlStatus = crate::RegValueT<MacPmtControlStatus_SPEC>;

impl MacPmtControlStatus {
    #[doc = "Power Down   PWRDWN. When this bit is set  the MAC receiver drops all received packets until it receives the expected magic packet or remote wake up packet. This bit is then self cleared and the power down mode is disabled. The software can clear this bit before the expected magic packet or remote wake up packet is received. The packets received by the MAC after this bit is cleared are forwarded to the application. This bit must only be set when the Magic Packet Enable  Global Unicast  or Remote Wake Up Packet Enable bit is set high. Note   You can gate off the CSR clock during the power down mode. However  when the CSR clock is gated off  you cannot perform any read or write operations on this register. Therefore  the Software cannot clear this bit. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn pwrdwn(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacPmtControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<0,1,0,MacPmtControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Magic Packet Enable   MGKPKTEN. When this bit is set  a power management event is generated when the MAC receives a magic packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mgkpkten(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacPmtControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<1,1,0,MacPmtControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Remote Wake Up Packet Enable   RWKPKTEN. When this bit is set  a power management event is generated when the MAC receives a remote wake up packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rwkpkten(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MacPmtControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<2,1,0,MacPmtControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Magic Packet Received   MGKPRCVD. When this bit is set  it indicates that the power management event is        generated because of the reception of a magic packet. This bit is        cleared when this register is read. Access restriction applies. Clears on read  or write of 1 when RCWE bit        in MAC CSR SW Ctrl register is set . Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mgkprcvd(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MacPmtControlStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MacPmtControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Remote Wake Up Packet Received   RWKPRCVD. When this bit is set  it indicates that the power management event is generated because of the reception of a remote wake up packet. This bit is cleared when this register is read. Access restriction applies. Clears on read  or write of 1 when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rwkprcvd(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MacPmtControlStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<6,1,0,MacPmtControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Global Unicast   GLBLUCAST. When this bit set  any unicast packet filtered by the MAC  DAF  address recognition is detected as a remote wake up packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn glblucast(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MacPmtControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<9,1,0,MacPmtControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Remote Wake up Packet Forwarding Enable   RWKPFE. When this bit is set along with RWKPKTEN  the MAC receiver drops all received frames until it receives the expected Wake up frame. All frames after that event including the received wake up frame are forwarded to application. This bit is then self cleared on receiving the wake up packet. The application can also clear this bit before the expected wake up frame is received. In such cases  the MAC reverts to the default behavior where packets received are forwarded to the application. This bit must only be set when RWKPKTEN is set high and PWRDWN is set low. The setting of this bit has no effect when PWRDWN is set high. Note  If Magic Packet Enable and Wake Up Frame Enable are both set along with setting of this bit and Magic Packet is received prior to wake up frame  this bit is self cleared on receiving Magic Packet  the received Magic packet is dropped  and all frames after received Magic Packet are forwarded to application. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rwkpfe(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, MacPmtControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<10,1,0,MacPmtControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Remote Wake up FIFO Pointer   RWKPTR. This field gives the current value  0 to 7  of the Remote Wake up Packet        Filter register pointer. When the value of this pointer is equal to 7         the contents of the Remote Wake up Packet Filter Register are        transferred to the clk rx i domain when a Write occurs to that register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rwkptr(
        self,
    ) -> crate::common::RegisterField<24, 0x1f, 1, 0, u8, MacPmtControlStatus_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<24,0x1f,1,0,u8, MacPmtControlStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Remote Wake Up Packet Filter Register Pointer Reset   RWKFILTRST. When this bit is set  the remote wake up packet filter register pointer is reset to 3 b000. It is automatically cleared after 1 clock cycle. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rwkfiltrst(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacPmtControlStatus_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<31,1,0,MacPmtControlStatus_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacPmtControlStatus {
    #[inline(always)]
    fn default() -> MacPmtControlStatus {
        <crate::RegValueT<MacPmtControlStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacPps0Interval_SPEC;
impl crate::sealed::RegSpec for MacPps0Interval_SPEC {
    type DataType = u32;
}
#[doc = "MAC PPS 0 Interval Register\n resetvalue={Application Reset:0x0}"]
pub type MacPps0Interval = crate::RegValueT<MacPps0Interval_SPEC>;

impl MacPps0Interval {
    #[doc = "PPS Output Signal Interval   PPSINT0. These bits store the interval between the rising edges of PPS0 signal output. The interval is stored in terms of number of units of sub second increment value. You need to program one value less than the required interval. For example  if the PTP reference clock is 50 MHz  period of 20 ns   and desired interval between the rising edges of PPS0 signal output is 100 ns  that is  5 units of sub second increment value   you should program value 4  5 1  in this register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ppsint0(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacPps0Interval_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacPps0Interval_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacPps0Interval {
    #[inline(always)]
    fn default() -> MacPps0Interval {
        <crate::RegValueT<MacPps0Interval_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacPps0TargetTimeNanoseconds_SPEC;
impl crate::sealed::RegSpec for MacPps0TargetTimeNanoseconds_SPEC {
    type DataType = u32;
}
#[doc = "MAC PPS 0 Target Time Nanoeconds Register\n resetvalue={Application Reset:0x0}"]
pub type MacPps0TargetTimeNanoseconds = crate::RegValueT<MacPps0TargetTimeNanoseconds_SPEC>;

impl MacPps0TargetTimeNanoseconds {
    #[doc = "Target Time Low for PPS Register   TTSL0. This register stores the time in  signed  nanoseconds. When the value of the timestamp matches the value in both Target Timestamp registers  the MAC starts or stops the PPS signal output and generates an interrupt  if enabled  based on the TRGTMODSEL0 field  Bits  6 5   in MAC PPS Control. When the TSCTRLSSR bit is reset in the MAC Timestamp Control register  this value should be  time in ns   0.465 . The actual start or stop time of the PPS signal output may have an error margin up to one unit of sub second increment value. When the TSCTRLSSR bit is set in the MAC Timestamp Control register  this value should not exceed 0x3B9A C9FF. The actual start or stop time of the PPS signal output may have an error margin up to one unit of sub second increment value. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ttsl0(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x7fffffff,
        1,
        0,
        u32,
        MacPps0TargetTimeNanoseconds_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x7fffffff,
            1,
            0,
            u32,
            MacPps0TargetTimeNanoseconds_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "PPS Target Time Register Busy   TRGTBUSY0. The MAC sets this bit when the PPSCMD0 field in the MAC PPS Control register is programmed to 010 or 011. Programming the PPSCMD0 field to 010 or 011 instructs the MAC to synchronize the Target Time Registers to the PTP clock domain. The MAC clears this bit after synchronizing the Target Time Registers to the PTP clock domain The application must not update the Target Time Registers when this bit is read as 1. Otherwise  the synchronization of the previous programmed time gets corrupted. Value After Reset  0x0"]
    #[inline(always)]
    pub fn trgtbusy0(
        self,
    ) -> crate::common::RegisterFieldBool<
        31,
        1,
        0,
        MacPps0TargetTimeNanoseconds_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            31,
            1,
            0,
            MacPps0TargetTimeNanoseconds_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacPps0TargetTimeNanoseconds {
    #[inline(always)]
    fn default() -> MacPps0TargetTimeNanoseconds {
        <crate::RegValueT<MacPps0TargetTimeNanoseconds_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacPps0TargetTimeSeconds_SPEC;
impl crate::sealed::RegSpec for MacPps0TargetTimeSeconds_SPEC {
    type DataType = u32;
}
#[doc = "MAC PPS 0 Target Time Seconds Register\n resetvalue={Application Reset:0x0}"]
pub type MacPps0TargetTimeSeconds = crate::RegValueT<MacPps0TargetTimeSeconds_SPEC>;

impl MacPps0TargetTimeSeconds {
    #[doc = "PPS Target Time Seconds Register   TSTRH0. This field stores the time in seconds. When the timestamp value matches or exceeds both Target Timestamp registers  the MAC starts or stops the PPS signal output and generates an interrupt  if enabled  based on Target Time mode selected for the corresponding PPS output in the MAC PPS Control register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tstrh0(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacPps0TargetTimeSeconds_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacPps0TargetTimeSeconds_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacPps0TargetTimeSeconds {
    #[inline(always)]
    fn default() -> MacPps0TargetTimeSeconds {
        <crate::RegValueT<MacPps0TargetTimeSeconds_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacPps0Width_SPEC;
impl crate::sealed::RegSpec for MacPps0Width_SPEC {
    type DataType = u32;
}
#[doc = "MAC PPS 0 Width Register\n resetvalue={Application Reset:0x0}"]
pub type MacPps0Width = crate::RegValueT<MacPps0Width_SPEC>;

impl MacPps0Width {
    #[doc = "PPS Output Signal Width   PPSWIDTH0. These bits store the width between the rising edge and corresponding falling edge of PPS0 signal output. The width is stored in terms of number of units of sub second increment value. You need to program one value less than the required interval. For example  if PTP reference clock is 50 MHz  period of 20 ns   and width between the rising and corresponding falling edges of PPS0 signal output is 80 ns  that is  four units of sub second increment value   you should program value 3  4 1  in this register. Note   The value programmed in this register must be lesser than the value programmed in MAC PPS0 Interval. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ppswidth0(
        self,
    ) -> crate::common::RegisterField<0, 0xffffffff, 1, 0, u32, MacPps0Width_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffffffff,1,0,u32, MacPps0Width_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacPps0Width {
    #[inline(always)]
    fn default() -> MacPps0Width {
        <crate::RegValueT<MacPps0Width_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacPpsControl_SPEC;
impl crate::sealed::RegSpec for MacPpsControl_SPEC {
    type DataType = u32;
}
#[doc = "MAC PPS Control Register\n resetvalue={Application Reset:0x0}"]
pub type MacPpsControl = crate::RegValueT<MacPpsControl_SPEC>;

impl MacPpsControl {
    #[doc = "Flexible PPS Output  ptp pps o 0   Control   PPSCTRL PPSCMD. This field controls the frequency of the PPS0 output  ptp pps o 0   signal. The default value of PPSCTRL is 0000  and the PPS output is 1 pulse  of width clk ptp i  every second. For other values of PPSCTRL  the PPS output becomes a generated clock of following frequencies  LOST SEQUENCE DEFINITION Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ppsctrl_ppscmd(
        self,
    ) -> crate::common::RegisterField<0, 0xf, 1, 0, u8, MacPpsControl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<0,0xf,1,0,u8, MacPpsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Flexible PPS Output Mode Enable   PPSEN0. When this bit is set  Bits 3 0  function as PPSCMD. When this bit is reset  Bits 3 0  function as PPSCTRL  Fixed PPS mode . Value After Reset  0x0"]
    #[inline(always)]
    pub fn ppsen0(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MacPpsControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<4,1,0,MacPpsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Target Time Register Mode for PPS0 Output   TRGTMODSEL0. This field indicates the Target Time registers         MAC PPS0 Target Time Seconds and MAC PPS0 Target Time Nanoseconds  mode        for PPS0 output signal  Value After Reset  0x0"]
    #[inline(always)]
    pub fn trgtmodsel0(
        self,
    ) -> crate::common::RegisterField<5, 0x3, 1, 0, u8, MacPpsControl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<5,0x3,1,0,u8, MacPpsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacPpsControl {
    #[inline(always)]
    fn default() -> MacPpsControl {
        <crate::RegValueT<MacPpsControl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacQ0TxFlowCtrl_SPEC;
impl crate::sealed::RegSpec for MacQ0TxFlowCtrl_SPEC {
    type DataType = u32;
}
#[doc = "MAC Queue 0 TX Flow Control Register\n resetvalue={Application Reset:0x0}"]
pub type MacQ0TxFlowCtrl = crate::RegValueT<MacQ0TxFlowCtrl_SPEC>;

impl MacQ0TxFlowCtrl {
    #[doc = "Flow Control Busy or Backpressure Activate   FCB BPA. This bit initiates a Pause packet in the full duplex mode and activates the backpressure function in the half duplex mode if the TFE bit is set. Full Duplex Mode  In the full duplex mode  this bit should be read as 1 b0 before writing to this register. To initiate a Pause packet  the application must set this bit to 1 b1. During Control packet transfer  this bit continues to be set to indicate that a packet transmission is in progress. When Pause packet transmission is complete  the MAC resets this bit to 1 b0. You should not write to this register until this bit is cleared. Half  Duplex Mode  When this bit is set  and TFE bit is set  in the half duplex mode  the MAC asserts the backpressure. During backpressure  when the MAC receives a new packet  the transmitter starts sending a JAM pattern resulting in a collision. This control register bit is logically ORed with the mti flowctrl i input signal for the backpressure function. When the MAC is configured for the full duplex mode  the BPA is automatically disabled. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn fcb_bpa(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacQ0TxFlowCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MacQ0TxFlowCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Flow Control Enable   TFE. Full Duplex Mode  In the full duplex mode  when this bit is set  the MAC enables the flow control operation to Tx Pause packets. When this bit is reset  the flow control operation in the MAC is disabled  and the MAC does not transmit any Pause packets. Half  Duplex Mode  In the half duplex mode  when this bit is set  the MAC enables the backpressure operation. When this bit is reset  the backpressure feature is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tfe(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacQ0TxFlowCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1,1,0,MacQ0TxFlowCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Pause Low Threshold   PLT. This field configures the threshold of the Pause timer at which the input flow control signal mti flowctrl i  or sbd flowctrl i  is checked for automatic retransmission of the Pause packet. The threshold values should be always less than the Pause Time configured in Bits 31 16 . For example  if PT   100H  256 slot times   and PLT   001  a second Pause packet is automatically transmitted if the mti flowctrl i signal is asserted at 228  256 28  slot times after the first Pause packet is transmitted. The following list provides the threshold values for different values  110   111 Reserved The slot time is defined as the time taken to transmit 512 bits  64 bytes  on the GMII or MII interface. This  approximate  computation is based on the packet size  64  1518  2000  9018  16384  or 32768    2 Pause Packet Size   IPG in Slot Times. Value After Reset  0x0"]
    #[inline(always)]
    pub fn plt(
        self,
    ) -> crate::common::RegisterField<4, 0x7, 1, 0, u8, MacQ0TxFlowCtrl_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<4,0x7,1,0,u8, MacQ0TxFlowCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Disable Zero Quanta Pause   DZPQ. When this bit is set  it disables the automatic generation of the zero quanta Pause packets on de assertion of the flow control signal from the FIFO layer  MTL or external sideband flow control signal sbd flowctrl i or mti flowctrl i . When this bit is reset  normal operation with automatic zero quanta Pause packet generation is enabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dzpq(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MacQ0TxFlowCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<7,1,0,MacQ0TxFlowCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Pause Time   PT. This field holds the value to be used in the Pause Time field in the Tx control packet. If the Pause Time bits are configured to be double synchronized to the  G MII clock domain  consecutive writes to this register should be performed only after at least four clock cycles in the destination clock domain. Value After Reset  0x0"]
    #[inline(always)]
    pub fn pt(
        self,
    ) -> crate::common::RegisterField<16, 0xffff, 1, 0, u16, MacQ0TxFlowCtrl_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0xffff,1,0,u16, MacQ0TxFlowCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacQ0TxFlowCtrl {
    #[inline(always)]
    fn default() -> MacQ0TxFlowCtrl {
        <crate::RegValueT<MacQ0TxFlowCtrl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacRwkPacketFilter_SPEC;
impl crate::sealed::RegSpec for MacRwkPacketFilter_SPEC {
    type DataType = u32;
}
#[doc = "MAC Wake up Packet Filter Register\n resetvalue={Application Reset:0x0}"]
pub type MacRwkPacketFilter = crate::RegValueT<MacRwkPacketFilter_SPEC>;

impl MacRwkPacketFilter {
    #[doc = "RWK Packet Filter   WKUPFRMFTR. This field contains the various controls of RWK Packet filter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn wkupfrmftr(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacRwkPacketFilter_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacRwkPacketFilter_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacRwkPacketFilter {
    #[inline(always)]
    fn default() -> MacRwkPacketFilter {
        <crate::RegValueT<MacRwkPacketFilter_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacRxqCtrl0_SPEC;
impl crate::sealed::RegSpec for MacRxqCtrl0_SPEC {
    type DataType = u32;
}
#[doc = "MAC Receive Queue Control 0 Register\n resetvalue={Application Reset:0x0}"]
pub type MacRxqCtrl0 = crate::RegValueT<MacRxqCtrl0_SPEC>;

impl MacRxqCtrl0 {
    #[doc = "Receive Queue 0 Enable   RXQ0EN. This field indicates whether Rx Queue 0 is enabled for AV or DCB. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxq0en(
        self,
    ) -> crate::common::RegisterField<0, 0x3, 1, 0, u8, MacRxqCtrl0_SPEC, crate::common::RW> {
        crate::common::RegisterField::<0,0x3,1,0,u8, MacRxqCtrl0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Queue 1 Enable   RXQ1EN. This field is similar to the RXQ0EN field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxq1en(
        self,
    ) -> crate::common::RegisterField<2, 0x3, 1, 0, u8, MacRxqCtrl0_SPEC, crate::common::RW> {
        crate::common::RegisterField::<2,0x3,1,0,u8, MacRxqCtrl0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Queue 2 Enable   RXQ2EN. This field is similar to the RXQ0EN field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxq2en(
        self,
    ) -> crate::common::RegisterField<4, 0x3, 1, 0, u8, MacRxqCtrl0_SPEC, crate::common::RW> {
        crate::common::RegisterField::<4,0x3,1,0,u8, MacRxqCtrl0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Queue 3 Enable   RXQ3EN. This field is similar to the RXQ0EN field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxq3en(
        self,
    ) -> crate::common::RegisterField<6, 0x3, 1, 0, u8, MacRxqCtrl0_SPEC, crate::common::RW> {
        crate::common::RegisterField::<6,0x3,1,0,u8, MacRxqCtrl0_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacRxqCtrl0 {
    #[inline(always)]
    fn default() -> MacRxqCtrl0 {
        <crate::RegValueT<MacRxqCtrl0_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacRxqCtrl1_SPEC;
impl crate::sealed::RegSpec for MacRxqCtrl1_SPEC {
    type DataType = u32;
}
#[doc = "MAC Receive Queue Control 1 Register\n resetvalue={Application Reset:0x0}"]
pub type MacRxqCtrl1 = crate::RegValueT<MacRxqCtrl1_SPEC>;

impl MacRxqCtrl1 {
    #[doc = "AV Untagged Control Packets Queue   AVCPQ. This field specifies the Receive queue on which the received AV tagged and untagged control packets are routed  The AV tagged  when TACPQE bit is set  and untagged control packets are routed to Receive queue specified by this field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn avcpq(
        self,
    ) -> crate::common::RegisterField<0, 0x7, 1, 0, u8, MacRxqCtrl1_SPEC, crate::common::RW> {
        crate::common::RegisterField::<0,0x7,1,0,u8, MacRxqCtrl1_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "PTP Packets Queue   PTPQ. This field specifies the Rx queue on which the PTP packets sent over the        Ethernet payload  not over IPv4 or IPv6  are routed. When the AV8021ASMEN bit of MAC Timestamp Control register is set  only        untagged PTP over Ethernet packets are routed on an Rx Queue. If the bit        is not set  then based on programming of TPQC field  both tagged and        untagged PTPoE packets can be routed to this Rx Queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ptpq(
        self,
    ) -> crate::common::RegisterField<4, 0x7, 1, 0, u8, MacRxqCtrl1_SPEC, crate::common::RW> {
        crate::common::RegisterField::<4,0x7,1,0,u8, MacRxqCtrl1_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Untagged Packet Queue   UPQ. This field indicates the Rx Queue to which Untagged Packets are to be routed. Any Rx Queue enabled for Generic DCB AV traffic can be used to route the Untagged Packets. LOST SEQUENCE DEFINITION Value After Reset  0x0"]
    #[inline(always)]
    pub fn upq(
        self,
    ) -> crate::common::RegisterField<12, 0x7, 1, 0, u8, MacRxqCtrl1_SPEC, crate::common::RW> {
        crate::common::RegisterField::<12,0x7,1,0,u8, MacRxqCtrl1_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Multicast and Broadcast Queue   MCBCQ. This field specifies the Rx Queue onto which Multicast or Broadcast Packets are routed. Any Rx Queue enabled for Generic DCB AV traffic can be used to route the Multicast or Broadcast Packets. LOST SEQUENCE DEFINITION Value After Reset  0x0"]
    #[inline(always)]
    pub fn mcbcq(
        self,
    ) -> crate::common::RegisterField<16, 0x7, 1, 0, u8, MacRxqCtrl1_SPEC, crate::common::RW> {
        crate::common::RegisterField::<16,0x7,1,0,u8, MacRxqCtrl1_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Multicast and Broadcast Queue Enable   MCBCQEN. This bit specifies that Multicast or Broadcast packets routing to the Rx Queue is enabled and the Multicast or Broadcast packets must be routed to Rx Queue specified in MCBCQ field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mcbcqen(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MacRxqCtrl1_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<20,1,0,MacRxqCtrl1_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Tagged AV Control Packets Queuing Enable.   TACPQE. When set  the MAC routes the received Tagged AV Control packets to the Rx queue specified by AVCPQ field. When reset  the MAC routes the received Tagged AV Control packets based on the tag priority matching the PSRQ fields in MAC RxQ Ctrl2 register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tacpqe(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MacRxqCtrl1_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<21,1,0,MacRxqCtrl1_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Tagged PTP over Ethernet Packets Queuing Control   MFFQE. This field controls the routing of the VLAN Tagged PTPoE packets. The        following programmable options are allowed.   8226  2 b00  VLAN Tagged PTPoE        packets are routed as generic VLAN Tagged packet  based on PSRQ for only        non AV enabled Rx Queues .   8226  2 b01  VLAN Tagged PTPoE packets are routed        to Rx Queue specified by PTPQ field  That Rx Queue can be enabled for AV        or non AV traffic .   8226  2 b10  VLAN Tagged PTPoE packets are routed to        only AV enabled Rx Queues based on PSRQ.   8226  2 b11  Reserved Value After        Reset  0x0"]
    #[inline(always)]
    pub fn tpqc(
        self,
    ) -> crate::common::RegisterField<22, 0x3, 1, 0, u8, MacRxqCtrl1_SPEC, crate::common::RW> {
        crate::common::RegisterField::<22,0x3,1,0,u8, MacRxqCtrl1_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacRxqCtrl1 {
    #[inline(always)]
    fn default() -> MacRxqCtrl1 {
        <crate::RegValueT<MacRxqCtrl1_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacRxqCtrl2_SPEC;
impl crate::sealed::RegSpec for MacRxqCtrl2_SPEC {
    type DataType = u32;
}
#[doc = "MAC Receive Queue Control 2 Register\n resetvalue={Application Reset:0x0}"]
pub type MacRxqCtrl2 = crate::RegValueT<MacRxqCtrl2_SPEC>;

impl MacRxqCtrl2 {
    #[doc = "Priorities Selected in the Receive Queue 0   PSRQ0. This field decides the priorities assigned to Rx Queue 0. All packets with priorities that match the values set in this field are routed to Rx Queue 0. For example  if PSRQ0 5  is set  packets with USP field equal to 5 are routed to Rx Queue 0. The software must ensure that the content of this field is mutually exclusive to the PSRQ fields for other queues  that is  the same priority is not mapped to multiple Rx queues. Value After Reset  0x0"]
    #[inline(always)]
    pub fn psrq0(
        self,
    ) -> crate::common::RegisterField<0, 0xff, 1, 0, u8, MacRxqCtrl2_SPEC, crate::common::RW> {
        crate::common::RegisterField::<0,0xff,1,0,u8, MacRxqCtrl2_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Priorities Selected in the Receive Queue 1   PSRQ1. This field decides the priorities assigned to Rx Queue 1. All packets with priorities that match the values set in this field are routed to Rx Queue 1. For example  if PSRQ1 4  is set  packets with USP field equal to 4 are routed to Rx Queue 1. The software must ensure that the content of this field is mutually exclusive to the PSRQ fields for other queues  that is  the same priority is not mapped to multiple Rx queues. Value After Reset  0x0"]
    #[inline(always)]
    pub fn psrq1(
        self,
    ) -> crate::common::RegisterField<8, 0xff, 1, 0, u8, MacRxqCtrl2_SPEC, crate::common::RW> {
        crate::common::RegisterField::<8,0xff,1,0,u8, MacRxqCtrl2_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Priorities Selected in the Receive Queue 2   PSRQ2. This field decides the priorities assigned to Rx Queue 2. All packets with priorities that match the values set in this field are routed to Rx Queue 2. For example  if PSRQ2 1  0  are set  packets with USP field equal to 1 or 0 are routed to Rx Queue 2. The software must ensure that the content of this field is mutually exclusive to the PSRQ fields for other queues  that is  the same priority is not mapped to multiple Rx queues. Value After Reset  0x0"]
    #[inline(always)]
    pub fn psrq2(
        self,
    ) -> crate::common::RegisterField<16, 0xff, 1, 0, u8, MacRxqCtrl2_SPEC, crate::common::RW> {
        crate::common::RegisterField::<16,0xff,1,0,u8, MacRxqCtrl2_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Priorities Selected in the Receive Queue 3   PSRQ3. This field decides the priorities assigned to Rx Queue 3. All packets with priorities that match the values set in this field are routed to Rx Queue 3. For example  if PSRQ3 6  3  are set  packets with USP field equal to 3 or 6 are routed to Rx Queue 3. The software must ensure that the content of this field is mutually exclusive to the PSRQ fields for other queues  that is  the same priority is not mapped to multiple Rx queues. Value After Reset  0x0"]
    #[inline(always)]
    pub fn psrq3(
        self,
    ) -> crate::common::RegisterField<24, 0xff, 1, 0, u8, MacRxqCtrl2_SPEC, crate::common::RW> {
        crate::common::RegisterField::<24,0xff,1,0,u8, MacRxqCtrl2_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacRxqCtrl2 {
    #[inline(always)]
    fn default() -> MacRxqCtrl2 {
        <crate::RegValueT<MacRxqCtrl2_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacRxqCtrl4_SPEC;
impl crate::sealed::RegSpec for MacRxqCtrl4_SPEC {
    type DataType = u32;
}
#[doc = "MAC Receive Queue Control 4 register\n resetvalue={Application Reset:0x0}"]
pub type MacRxqCtrl4 = crate::RegValueT<MacRxqCtrl4_SPEC>;

impl MacRxqCtrl4 {
    #[doc = "Unicast Address Filter Fail Packets Queuing Enable    UFFQE. When this bit is set  the Unicast packets which fail the Destination or        Source address filter is routed to the Rx Queue Number programmed in the        UFFQ. When this bit is reset  the Unicast packets which fail the        Destination or Source address filter is routed based on other routing        options. This bit is valid only when the RA bit of the MAC Packet Filter        register is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn uffqe(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacRxqCtrl4_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MacRxqCtrl4_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Unicast Address Filter Fail Packets Queue   UFFQ. This field holds the Rx queue number to which the Unicast packets        failing the Destination or Source Address filter are routed to. This        field is valid only when the UFFQE bit is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn uffq(
        self,
    ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, MacRxqCtrl4_SPEC, crate::common::RW> {
        crate::common::RegisterField::<1,0x3,1,0,u8, MacRxqCtrl4_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Multicast Address Filter Fail Packets Queuing Enable    MFFQE. When this bit is set  the Multicast packets which fail the Destination        or Source address filter is routed to the Rx Queue Number programmed in        the MFFQ. When this bit is reset  the Multicast packets which fail the        Destination or Source address filter is routed based on other routing        options. This bit is valid only when the RA bit of the MAC Packet Filter        register is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mffqe(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacRxqCtrl4_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<8,1,0,MacRxqCtrl4_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Multicast Address Filter Fail Packets Queue   MFFQ. This field holds the Rx queue number to which the Multicast packets        failing the Destination or Source Address filter are routed to. This        field is valid only when the MFFQE bit is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mffq(
        self,
    ) -> crate::common::RegisterField<9, 0x3, 1, 0, u8, MacRxqCtrl4_SPEC, crate::common::RW> {
        crate::common::RegisterField::<9,0x3,1,0,u8, MacRxqCtrl4_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Tag Filter Fail Packets Queuing Enable    VFFQE. When this bit is set  the tagged packets which fail the Destination or Source address filter or fail the VLAN tag filter  are routed to the Rx Queue Number programmed in the VFFQ. When this bit is reset  the tagged packets which fail the Destination or Source address filter or fail the VLAN tag filter are routed based on other routing options. This bit is valid only when the RA bit of the MAC Packet Filter register is set."]
    #[inline(always)]
    pub fn vffqe(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacRxqCtrl4_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<16,1,0,MacRxqCtrl4_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Tag Filter Fail Packets Queue   VFFQ. This field holds the Rx queue number to which the tagged packets failing the Destination or Source Address filter  and UFFQE MFFQE not enabled  or failing the VLAN tag filter must be routed to. This field is valid only when the VFFQE bit is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vffq(
        self,
    ) -> crate::common::RegisterField<17, 0x3, 1, 0, u8, MacRxqCtrl4_SPEC, crate::common::RW> {
        crate::common::RegisterField::<17,0x3,1,0,u8, MacRxqCtrl4_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacRxqCtrl4 {
    #[inline(always)]
    fn default() -> MacRxqCtrl4 {
        <crate::RegValueT<MacRxqCtrl4_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacRxFlowCtrl_SPEC;
impl crate::sealed::RegSpec for MacRxFlowCtrl_SPEC {
    type DataType = u32;
}
#[doc = "MAC Receive Flow Control Register\n resetvalue={Application Reset:0x0}"]
pub type MacRxFlowCtrl = crate::RegValueT<MacRxFlowCtrl_SPEC>;

impl MacRxFlowCtrl {
    #[doc = "Receive Flow Control Enable   RFE. When this bit is set and the MAC is operating in full duplex mode  the MAC decodes the received Pause packet and disables its transmitter for a specified  Pause  time. When this bit is reset or the MAC is operating in half duplex mode  the decode function of the Pause packet is disabled. When PFC is enabled  flow control is enabled for PFC packets. The MAC decodes the received PFC packet and disables the Transmit queue  with matching priorities  for a duration of received Pause time. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rfe(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacRxFlowCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MacRxFlowCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Unicast Pause Packet Detect   UP. A pause packet is processed when it has the unique multicast address specified in the IEEE 802.3. When this bit is set  the MAC can also detect Pause packets with unicast address of the station. This unicast address should be as specified in MAC Address0 High and MAC Address0 Low. When this bit is reset  the MAC only detects Pause packets with unique multicast address. Note   The MAC does not process a Pause packet if the multicast address is different from the unique multicast address. This is also applicable to the received PFC packet when the Priority Flow Control  PFC  is enabled. The unique multicast address  0x01 80 C2 00 00 01  is as specified in IEEE 802.1 Qbb 2011. Value After Reset  0x0"]
    #[inline(always)]
    pub fn up(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacRxFlowCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1,1,0,MacRxFlowCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacRxFlowCtrl {
    #[inline(always)]
    fn default() -> MacRxFlowCtrl {
        <crate::RegValueT<MacRxFlowCtrl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacRxTxStatus_SPEC;
impl crate::sealed::RegSpec for MacRxTxStatus_SPEC {
    type DataType = u32;
}
#[doc = "MAC Receive Transmit Status Register\n resetvalue={Application Reset:0x0}"]
pub type MacRxTxStatus = crate::RegValueT<MacRxTxStatus_SPEC>;

impl MacRxTxStatus {
    #[doc = "Transmit Jabber Timeout   TJT. This bit indicates that the Transmit Jabber Timer expired which happens when the packet size exceeds 2 048 bytes  10 240 bytes when the Jumbo packet is enabled  and JD bit is reset in the MAC Configuration register. This bit is set when the packet size exceeds 16 383 bytes and the JD bit is set in the MAC Configuration register. Access restriction applies. Clears on read  or write of 1 when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tjt(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacRxTxStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MacRxTxStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "No Carrier   NCARR. When the DTXSTS bit is set in the MTL Operation Mode register  this bit        indicates that the carrier signal from the PHY is not present at the end        of preamble transmission. Access restriction applies. Clears on read  or write of 1 when RCWE bit        in MAC CSR SW Ctrl register is set . Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ncarr(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacRxTxStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1,1,0,MacRxTxStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Loss of Carrier   LCARR. When the DTXSTS bit is set in the MTL Operation Mode register  this bit        indicates that the loss of carrier occurred during packet transmission         that is  the phy crs i signal was inactive for one or more transmission        clock periods during packet transmission. This bit is valid only for        packets transmitted without collision. Access restriction applies. Clears on read  or write of 1 when RCWE bit in        MAC CSR SW Ctrl register is set . Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lcarr(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MacRxTxStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<2,1,0,MacRxTxStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Excessive Deferral   EXDEF. When the DTXSTS bit is set in the MTL Operation Mode register and the DC        bit is set in the MAC Configuration register  this bit indicates that        the transmission ended because of excessive deferral of over 24 288 bit        times  155 680 in 1000 2500 Mbps mode or when Jumbo packet is enabled . Access restriction applies. Clears on read  or write of 1 when RCWE bit        in MAC CSR SW Ctrl register is set . Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn exdef(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MacRxTxStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MacRxTxStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Late Collision   LCOL. When the DTXSTS bit is set in the MTL Operation Mode register  this bit        indicates that the packet transmission aborted because a collision        occurred after the collision window  64 bytes including Preamble in MII        mode  512 bytes including Preamble and Carrier Extension in GMII mode . This bit is not valid if the Underflow error occurs. This bit is        reserved in the EQOS CORE configurations and also in configurations with        full duplex mode. Access restriction applies. Clears on read  or write of 1 when RCWE bit        in MAC CSR SW Ctrl register is set . Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lcol(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MacRxTxStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MacRxTxStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Excessive Collisions   EXCOL. When the DTXSTS bit is set in the MTL Operation Mode register  this bit        indicates that the transmission aborted after 16 successive collisions        while attempting to transmit the current packet. If the DR bit is set in        the MAC Configuration register  this bit is set after the first        collision and the packet transmission is aborted. Access restriction applies. Clears on read  or write of 1 when RCWE bit        in MAC CSR SW Ctrl register is set . Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn excol(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MacRxTxStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MacRxTxStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Receive Watchdog Timeout   RWT. This bit is set when a packet with length greater than 2 048 bytes is received  10  240 bytes when Jumbo Packet mode is enabled  and the WD bit is reset in the MAC Configuration register. This bit is set when a packet with length greater than 16 383 bytes is received and the WD bit is set in the MAC Configuration register. Access restriction applies. Clears on read  or write of 1 when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rwt(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacRxTxStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<8,1,0,MacRxTxStatus_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacRxTxStatus {
    #[inline(always)]
    fn default() -> MacRxTxStatus {
        <crate::RegValueT<MacRxTxStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacSubSecondIncrement_SPEC;
impl crate::sealed::RegSpec for MacSubSecondIncrement_SPEC {
    type DataType = u32;
}
#[doc = "MAC Sub Second Increment Register\n resetvalue={Application Reset:0x0}"]
pub type MacSubSecondIncrement = crate::RegValueT<MacSubSecondIncrement_SPEC>;

impl MacSubSecondIncrement {
    #[doc = "Sub nanosecond Increment Value   SNSINC. This field contains the sub nanosecond increment value  represented in        nanoseconds multiplied by 2 8. This value is accumulated with the sub nanoseconds field of the        subsecond register. For example  when TSCTRLSSR field in the MAC Timestamp Control register        is set. and if the required increment is 5.3ns  then SSINC should be        0x05 and SNSINC should be 0x4C. Value After Reset  0x0"]
    #[inline(always)]
    pub fn snsinc(
        self,
    ) -> crate::common::RegisterField<
        8,
        0xff,
        1,
        0,
        u8,
        MacSubSecondIncrement_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            8,
            0xff,
            1,
            0,
            u8,
            MacSubSecondIncrement_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Sub second Increment Value   SSINC. The value programmed in this field is accumulated every clock cycle  of clk ptp i  with the contents of the sub second register. For example  when the PTP clock is 50 MHz  period is 20 ns   you should program 20  0x14  when the System Time Nanoseconds register has an accuracy of 1 ns  Bit 9  TSCTRLSSR  is set in MAC Timestamp Control . When TSCTRLSSR is clear  the Nanoseconds register has a resolution of  0.465 ns. In this case  you should program a value of 43  0x2B  which is derived by 20 ns 0.465. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ssinc(
        self,
    ) -> crate::common::RegisterField<
        16,
        0xff,
        1,
        0,
        u8,
        MacSubSecondIncrement_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            16,
            0xff,
            1,
            0,
            u8,
            MacSubSecondIncrement_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacSubSecondIncrement {
    #[inline(always)]
    fn default() -> MacSubSecondIncrement {
        <crate::RegValueT<MacSubSecondIncrement_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacSystemTimeHigherWordSeconds_SPEC;
impl crate::sealed::RegSpec for MacSystemTimeHigherWordSeconds_SPEC {
    type DataType = u32;
}
#[doc = "MAC System Time Higher Word Seconds Register\n resetvalue={Application Reset:0x0}"]
pub type MacSystemTimeHigherWordSeconds = crate::RegValueT<MacSystemTimeHigherWordSeconds_SPEC>;

impl MacSystemTimeHigherWordSeconds {
    #[doc = "Timestamp Higher Word Register   TSHWR. This field contains the most significant 16 bits of timestamp seconds value. This register is optional. You can add this register by selecting the Add IEEE 1588 Higher Word Register option. This register is directly written to initialize the value and it is incremented when there is an overflow from 32 bits of the System Time Seconds register. Access restriction applies. Updated based on the event. Setting 1 sets. Setting 0 clears. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tshwr(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        MacSystemTimeHigherWordSeconds_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            MacSystemTimeHigherWordSeconds_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacSystemTimeHigherWordSeconds {
    #[inline(always)]
    fn default() -> MacSystemTimeHigherWordSeconds {
        <crate::RegValueT<MacSystemTimeHigherWordSeconds_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacSystemTimeNanoseconds_SPEC;
impl crate::sealed::RegSpec for MacSystemTimeNanoseconds_SPEC {
    type DataType = u32;
}
#[doc = "MAC System Time Nanoseconds Register\n resetvalue={Application Reset:0x0}"]
pub type MacSystemTimeNanoseconds = crate::RegValueT<MacSystemTimeNanoseconds_SPEC>;

impl MacSystemTimeNanoseconds {
    #[doc = "Timestamp Sub Seconds   TSSS. The value in this field has the sub second representation of time  with an accuracy of 0.46 ns. When Bit 9 is set in MAC Timestamp Control  each bit represents 1 ns. The maximum value is 0x3B9A C9FF after which it rolls over to zero. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsss(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x7fffffff,
        1,
        0,
        u32,
        MacSystemTimeNanoseconds_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0x7fffffff,
            1,
            0,
            u32,
            MacSystemTimeNanoseconds_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacSystemTimeNanoseconds {
    #[inline(always)]
    fn default() -> MacSystemTimeNanoseconds {
        <crate::RegValueT<MacSystemTimeNanoseconds_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacSystemTimeNanosecondsUpdate_SPEC;
impl crate::sealed::RegSpec for MacSystemTimeNanosecondsUpdate_SPEC {
    type DataType = u32;
}
#[doc = "MAC System Time Nanoseconds Update Register\n resetvalue={Application Reset:0x0}"]
pub type MacSystemTimeNanosecondsUpdate = crate::RegValueT<MacSystemTimeNanosecondsUpdate_SPEC>;

impl MacSystemTimeNanosecondsUpdate {
    #[doc = "Timestamp Sub Seconds   TSSS. The value in this field is the sub seconds part of the update. When ADDSUB is reset  this field must be programmed with the sub seconds part of the update value  with an accuracy based on the TSCTRLSSR bit of the MAC Timestamp Control register. When ADDSUB is set  this field must be programmed with the complement of the sub seconds part of the update value as described below. When TSCTRLSSR bit in MAC Timestamp Control is set  the programmed value must be 10 9    lt sub second value gt . When TSCTRLSSR bit in MAC Timestamp Control is reset  the programmed value must be 2 31    lt sub second value gt . When the TSCTRLSSR bit is reset in the MAC Timestamp Control register  each bit represents an accuracy of 0.46 ns. When the TSCTRLSSR bit is set in the MAC Timestamp Control register  each bit represents 1 ns and the programmed value should not exceed 0x3B9A C9FF. For example  if 2.000000001 seconds need to be subtracted from the system time  then the TSSS field in the MAC Timestamp Nanoseconds Update register must be 0x7FFF FFFF  that is  2 31   1   when TSCTRLSSR bit in MAC Timestamp Control is reset and 0x3B9A C9FF  that is  10 9   1   when TSCTRLSSR bit in MAC Timestamp Control is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsss(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x7fffffff,
        1,
        0,
        u32,
        MacSystemTimeNanosecondsUpdate_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x7fffffff,
            1,
            0,
            u32,
            MacSystemTimeNanosecondsUpdate_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Add or Subtract Time   ADDSUB. When this bit is set  the time value is subtracted with the contents of the update register. When this bit is reset  the time value is added with the contents of the update register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn addsub(
        self,
    ) -> crate::common::RegisterFieldBool<
        31,
        1,
        0,
        MacSystemTimeNanosecondsUpdate_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            31,
            1,
            0,
            MacSystemTimeNanosecondsUpdate_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacSystemTimeNanosecondsUpdate {
    #[inline(always)]
    fn default() -> MacSystemTimeNanosecondsUpdate {
        <crate::RegValueT<MacSystemTimeNanosecondsUpdate_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacSystemTimeSeconds_SPEC;
impl crate::sealed::RegSpec for MacSystemTimeSeconds_SPEC {
    type DataType = u32;
}
#[doc = "MAC System Time Seconds Register\n resetvalue={Application Reset:0x0}"]
pub type MacSystemTimeSeconds = crate::RegValueT<MacSystemTimeSeconds_SPEC>;

impl MacSystemTimeSeconds {
    #[doc = "Timestamp Second   TSS. The value in this field indicates the current value in seconds of the System Time maintained by the MAC. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tss(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacSystemTimeSeconds_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacSystemTimeSeconds_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacSystemTimeSeconds {
    #[inline(always)]
    fn default() -> MacSystemTimeSeconds {
        <crate::RegValueT<MacSystemTimeSeconds_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacSystemTimeSecondsUpdate_SPEC;
impl crate::sealed::RegSpec for MacSystemTimeSecondsUpdate_SPEC {
    type DataType = u32;
}
#[doc = "MAC System Time Seconds Update Register\n resetvalue={Application Reset:0x0}"]
pub type MacSystemTimeSecondsUpdate = crate::RegValueT<MacSystemTimeSecondsUpdate_SPEC>;

impl MacSystemTimeSecondsUpdate {
    #[doc = "Timestamp Seconds   TSS. The value in this field is the seconds part of the update. When ADDSUB is reset  this field must be programmed with the seconds part of the update value. When ADDSUB is set  this field must be programmed with the complement of the seconds part of the update value. For example  if 2.000000001 seconds need to be subtracted from the system time  the TSS field in the MAC Timestamp Seconds Update register must be 0xFFFF FFFE  that is  2 32   2 . Value After Reset  0x0"]
    #[inline(always)]
    pub fn tss(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacSystemTimeSecondsUpdate_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacSystemTimeSecondsUpdate_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacSystemTimeSecondsUpdate {
    #[inline(always)]
    fn default() -> MacSystemTimeSecondsUpdate {
        <crate::RegValueT<MacSystemTimeSecondsUpdate_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTimestampAddend_SPEC;
impl crate::sealed::RegSpec for MacTimestampAddend_SPEC {
    type DataType = u32;
}
#[doc = "MAC Timestamp Addend Register\n resetvalue={Application Reset:0x0}"]
pub type MacTimestampAddend = crate::RegValueT<MacTimestampAddend_SPEC>;

impl MacTimestampAddend {
    #[doc = "Timestamp Addend Register   TSAR. This field indicates the 32 bit time value to be added to the Accumulator register to achieve time synchronization. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsar(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacTimestampAddend_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacTimestampAddend_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacTimestampAddend {
    #[inline(always)]
    fn default() -> MacTimestampAddend {
        <crate::RegValueT<MacTimestampAddend_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTimestampControl_SPEC;
impl crate::sealed::RegSpec for MacTimestampControl_SPEC {
    type DataType = u32;
}
#[doc = "MAC Timestamp Control Register\n resetvalue={Application Reset:0x2000}"]
pub type MacTimestampControl = crate::RegValueT<MacTimestampControl_SPEC>;

impl MacTimestampControl {
    #[doc = "Enable Timestamp   TSENA. When this bit is set  the timestamp is added for Transmit and Receive packets. When disabled  timestamp is not added for transmit and receive packets and the Timestamp Generator is also suspended. You need to initialize the Timestamp  system time  after enabling this mode. On the Receive side  the MAC processes the 1588 packets only if this bit is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsena(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<0,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Fine or Coarse Timestamp Update   TSCFUPDT. When this bit is set  the Fine method is used to update system timestamp. When this bit is reset  Coarse method is used to update the system timestamp. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tscfupdt(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<1,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Initialize Timestamp   TSINIT. When this bit is set  the system time is initialized  overwritten  with the value specified in the MAC Register 80  System Time Seconds Update Register  and MAC Register 81  System Time Nanoseconds Update Register . This bit should be zero before it is updated. This bit is reset when the initialization is complete. The Timestamp Higher Word register  if enabled during core configuration  can only be initialized. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsinit(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<2,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Update Timestamp   TSUPDT. When this bit is set  the system time is updated  added or subtracted  with the value specified in MAC System Time Seconds Update and MAC System Time Nanoseconds Update. This bit should be zero before updating it. This bit is reset when the update is complete in hardware. The Timestamp Higher Word register  if enabled during core configuration  is not updated. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsupdt(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<3,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Update Addend Register   TSADDREG. When this bit is set  the content of the Timestamp Addend register is updated in the PTP block for fine correction. This bit is cleared when the update is complete. This bit should be zero before it is set. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsaddreg(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<5,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Timestamp for All Packets   TSENALL. When this bit is set  the timestamp snapshot is enabled for all packets received by the MAC. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsenall(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<8,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Timestamp Digital or Binary Rollover Control   TSCTRLSSR. When this bit is set  the Timestamp Low register rolls over after 0x3B9A C9FF value  that is  1 nanosecond accuracy  and increments the timestamp  High  seconds. When this bit is reset  the rollover value of sub second register is 0x7FFF FFFF. The sub second increment must be programmed correctly depending on the PTP reference clock frequency and the value of this bit. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsctrlssr(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<9,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable PTP Packet Processing for Version 2 Format   TSVER2ENA. When this bit is set  the IEEE 1588 version 2 format is used to process the PTP packets. When this bit is reset  the IEEE 1588 version 1 format is used to process the PTP packets. The IEEE 1588 formats are described in  PTP Processing and Control . Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsver2ena(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<10,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Processing of PTP over Ethernet Packets   TSIPENA. When this bit is set  the MAC receiver processes the PTP packets encapsulated directly in the Ethernet packets. When this bit is reset  the MAC ignores the PTP over Ethernet packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsipena(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<11,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Processing of PTP Packets Sent over IPv6 UDP   TSIPV6ENA. When this bit is set  the MAC receiver processes the PTP packets encapsulated in IPv6 UDP packets. When this bit is clear  the MAC ignores the PTP transported over IPv6 UDP packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsipv6ena(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<12,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Processing of PTP Packets Sent over IPv4 UDP   TSIPV4ENA. When this bit is set  the MAC receiver processes the PTP packets encapsulated in IPv4 UDP packets. When this bit is reset  the MAC ignores the PTP transported over IPv4 UDP packets. This bit is set by default. Value After Reset  0x1"]
    #[inline(always)]
    pub fn tsipv4ena(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<13,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Timestamp Snapshot for Event Messages   TSEVNTENA. When this bit is set  the timestamp snapshot is taken only for event        messages  SYNC  Delay Req  Pdelay Req  or Pdelay Resp . When this bit is        reset  the snapshot is taken for all messages except Announce         Management  and Signaling. For more information about the timestamp        snapshots  see Timestamp Snapshot Dependency on Register Bits Table. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsevntena(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<14,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Snapshot for Messages Relevant to Master   TSMSTRENA. When this bit is set  the snapshot is taken only for the messages that are relevant to the master node. Otherwise  the snapshot is taken for the messages relevant to the slave node. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsmstrena(
        self,
    ) -> crate::common::RegisterFieldBool<15, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<15,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Select PTP packets for Taking Snapshots   SNAPTYPSEL. These bits  along with Bits 15 and 14  decide the set of PTP packet types for which snapshot needs to be taken. The encoding is given in Timestamp Snapshot Dependency on Register Bits Table. Value After Reset  0x0"]
    #[inline(always)]
    pub fn snaptypsel(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable MAC Address for PTP Packet Filtering   TSENMACADDR. When this bit is set  the DA MAC address  that matches any MAC Address        register  is used to filter the PTP packets when PTP is directly sent        over Ethernet. When this bit is set  received PTP packets with DA containing a special        multicast or unicast address that matches the one programmed in MAC        address registers are considered for processing as indicated below  when        PTP is directly sent over Ethernet. For normal time stamping operation  MAC address registers 0 to 31 is        considered for unicast destination address matching. For PTP offload  only MAC address register 0 is considered for unicast        destination address matching. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsenmacaddr(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<18,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable checksum correction during OST for PTP over UDP IPv4 packets   CSC. When this bit is set  the last two bytes of PTP message sent over UDP IPv4 is updated to keep the UDP checksum correct  for changes made to origin timestamp and or correction field as part of one step timestamp operation. The application shall form the packet with these two dummy bytes. When reset  no updates are done to keep the UDP checksum correct. The application shall form the packet with UDP checksum set to 0. Value After Reset  0x0"]
    #[inline(always)]
    pub fn csc(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<19,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Timestamp Status Mode   TXTSSTSM. When this bit is set  the MAC overwrites the earlier transmit timestamp        status even if it is not read by the software. The MAC indicates this by        setting the TXTSSMIS bit of the MAC TxTimestamp Status Nanoseconds        register. When this bit is reset  the MAC ignores the timestamp status of current        packet if the timestamp status of previous packet is not read by the        software. The MAC indicates this by setting the TXTSSMIS bit of the        MAC TxTimestamp Status Nanoseconds register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txtsstsm(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<24,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "AV 802.1AS Mode Enable   AV8021ASMEN. When this bit is set  the MAC processes only untagged PTP over Ethernet packets for providing PTP status and capturing timestamp snapshots  that is  IEEE 802.1AS mode of operation. When PTP offload feature is enabled  for the purpose of PTP offload  the transport specific field in the PTP header is generated and checked based on the value of this bit. Value After Reset  0x0"]
    #[inline(always)]
    pub fn av8021asmen(
        self,
    ) -> crate::common::RegisterFieldBool<28, 1, 0, MacTimestampControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<28,1,0,MacTimestampControl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacTimestampControl {
    #[inline(always)]
    fn default() -> MacTimestampControl {
        <crate::RegValueT<MacTimestampControl_SPEC> as RegisterValue<_>>::new(8192)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTimestampEgressAsymCorr_SPEC;
impl crate::sealed::RegSpec for MacTimestampEgressAsymCorr_SPEC {
    type DataType = u32;
}
#[doc = "MAC Timestamp Egress Asymmetry Correction Register\n resetvalue={Application Reset:0x0}"]
pub type MacTimestampEgressAsymCorr = crate::RegValueT<MacTimestampEgressAsymCorr_SPEC>;

impl MacTimestampEgressAsymCorr {
    #[doc = "One Step Timestamp Egress Asymmetry Correction   OSTEAC. This field contains the egress path asymmetry value to be subtracted from correctionField of Pdelay Resp PTP packet. The programmed value must be the negated value in units of nanoseconds multiplied by 2 16. For example  if the required correction is  2.5 ns  the programmed value must be 0xFFFD 8000  which is the 2 s complement of 0x0002 8000 2.5   216 . Similarly  if the required correction is  3.3 ns  the programmed value is 0x0003 4CCC  3.3   216 . Value After Reset  0x0"]
    #[inline(always)]
    pub fn osteac(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacTimestampEgressAsymCorr_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacTimestampEgressAsymCorr_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacTimestampEgressAsymCorr {
    #[inline(always)]
    fn default() -> MacTimestampEgressAsymCorr {
        <crate::RegValueT<MacTimestampEgressAsymCorr_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTimestampEgressCorrNanosecond_SPEC;
impl crate::sealed::RegSpec for MacTimestampEgressCorrNanosecond_SPEC {
    type DataType = u32;
}
#[doc = "MAC Timestamp Egress Correction Nanoseconds Register\n resetvalue={Application Reset:0x0}"]
pub type MacTimestampEgressCorrNanosecond = crate::RegValueT<MacTimestampEgressCorrNanosecond_SPEC>;

impl MacTimestampEgressCorrNanosecond {
    #[doc = "Timestamp Egress Correction   TSEC. This field contains the nanoseconds part of the egress path correction value as defined by the Egress Correction expression. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsec(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacTimestampEgressCorrNanosecond_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacTimestampEgressCorrNanosecond_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacTimestampEgressCorrNanosecond {
    #[inline(always)]
    fn default() -> MacTimestampEgressCorrNanosecond {
        <crate::RegValueT<MacTimestampEgressCorrNanosecond_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTimestampEgressCorrSubnanosec_SPEC;
impl crate::sealed::RegSpec for MacTimestampEgressCorrSubnanosec_SPEC {
    type DataType = u32;
}
#[doc = "MAC Timestamp Egress Correction Subnanoseconds Register\n resetvalue={Application Reset:0x0}"]
pub type MacTimestampEgressCorrSubnanosec = crate::RegValueT<MacTimestampEgressCorrSubnanosec_SPEC>;

impl MacTimestampEgressCorrSubnanosec {
    #[doc = "Timestamp Egress Correction  sub nanoseconds   TSECSNS. This field contains the sub nanoseconds part of the egress path correction value as defined by the  Egress Correction  expression. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsecsns(
        self,
    ) -> crate::common::RegisterField<
        8,
        0xff,
        1,
        0,
        u8,
        MacTimestampEgressCorrSubnanosec_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            8,
            0xff,
            1,
            0,
            u8,
            MacTimestampEgressCorrSubnanosec_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacTimestampEgressCorrSubnanosec {
    #[inline(always)]
    fn default() -> MacTimestampEgressCorrSubnanosec {
        <crate::RegValueT<MacTimestampEgressCorrSubnanosec_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTimestampIngressAsymCorr_SPEC;
impl crate::sealed::RegSpec for MacTimestampIngressAsymCorr_SPEC {
    type DataType = u32;
}
#[doc = "MAC Timestamp Ingress Asymmetry Correction Register\n resetvalue={Application Reset:0x0}"]
pub type MacTimestampIngressAsymCorr = crate::RegValueT<MacTimestampIngressAsymCorr_SPEC>;

impl MacTimestampIngressAsymCorr {
    #[doc = "One Step Timestamp Ingress Asymmetry Correction   OSTIAC. This field contains the ingress path asymmetry value to be added to correctionField of Pdelay Resp PTP packet. The programmed value should be in units of nanoseconds and multiplied by 2 16. For example  2.5 ns is represented as 0x00028000. The value can also be negative  which is represented in 2 s complement form with bit 31 representing the sign bit. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ostiac(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacTimestampIngressAsymCorr_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacTimestampIngressAsymCorr_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacTimestampIngressAsymCorr {
    #[inline(always)]
    fn default() -> MacTimestampIngressAsymCorr {
        <crate::RegValueT<MacTimestampIngressAsymCorr_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTimestampIngressCorrNanosecond_SPEC;
impl crate::sealed::RegSpec for MacTimestampIngressCorrNanosecond_SPEC {
    type DataType = u32;
}
#[doc = "MAC Timestamp Ingress Correction Nanoseconds Register\n resetvalue={Application Reset:0x0}"]
pub type MacTimestampIngressCorrNanosecond =
    crate::RegValueT<MacTimestampIngressCorrNanosecond_SPEC>;

impl MacTimestampIngressCorrNanosecond {
    #[doc = "Timestamp Ingress Correction   TSIC. This field contains the ingress path correction value as defined by the Ingress Correction expression. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsic(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacTimestampIngressCorrNanosecond_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacTimestampIngressCorrNanosecond_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacTimestampIngressCorrNanosecond {
    #[inline(always)]
    fn default() -> MacTimestampIngressCorrNanosecond {
        <crate::RegValueT<MacTimestampIngressCorrNanosecond_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTimestampIngressCorrSubnanosec_SPEC;
impl crate::sealed::RegSpec for MacTimestampIngressCorrSubnanosec_SPEC {
    type DataType = u32;
}
#[doc = "MAC Timestamp Ingress Correction Subnanoseconds Register\n resetvalue={Application Reset:0x0}"]
pub type MacTimestampIngressCorrSubnanosec =
    crate::RegValueT<MacTimestampIngressCorrSubnanosec_SPEC>;

impl MacTimestampIngressCorrSubnanosec {
    #[doc = "Timestamp Ingress Correction  sub nanoseconds   TSICSNS. This field contains the sub nanoseconds part of the ingress path correction value as defined by the  Ingress Correction  expression. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsicsns(
        self,
    ) -> crate::common::RegisterField<
        8,
        0xff,
        1,
        0,
        u8,
        MacTimestampIngressCorrSubnanosec_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            8,
            0xff,
            1,
            0,
            u8,
            MacTimestampIngressCorrSubnanosec_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacTimestampIngressCorrSubnanosec {
    #[inline(always)]
    fn default() -> MacTimestampIngressCorrSubnanosec {
        <crate::RegValueT<MacTimestampIngressCorrSubnanosec_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTimestampStatus_SPEC;
impl crate::sealed::RegSpec for MacTimestampStatus_SPEC {
    type DataType = u32;
}
#[doc = "MAC Timestamp Status Register\n resetvalue={Application Reset:0x0}"]
pub type MacTimestampStatus = crate::RegValueT<MacTimestampStatus_SPEC>;

impl MacTimestampStatus {
    #[doc = "Timestamp Seconds Overflow   TSSOVF. When this bit is set  it indicates that the seconds value of the        timestamp  when supporting version 2 format  has overflowed beyond        32 hFFFF FFFF. Access restriction applies. Clears on read  or this bit is written to 1        when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on        internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tssovf(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacTimestampStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MacTimestampStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Timestamp Target Time Reached   TSTARGT0. When set  this bit indicates that the value of system time is greater        than or equal to the value specified in the MAC PPS0 Target Time Seconds        and MAC PPS0 Target Time Nanoseconds registers. Access restriction applies. Clears on read  or this bit is written to 1        when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on        internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tstargt0(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacTimestampStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1,1,0,MacTimestampStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Timestamp Target Time Error   TSTRGTERR0. This bit is set when the latest target time programmed in the        MAC PPS0 Target Time Seconds and MAC PPS0 Target Time Nanoseconds registers elapses. This bit is cleared when the application reads this        bit. Access restriction applies. Clears on read  or this bit is written to 1        when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on        internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tstrgterr0(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MacTimestampStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MacTimestampStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Timestamp Target Time Reached for Target Time PPS1   TSTARGT1. When set  this bit indicates that the value of system time is greater        than or equal to the value specified in the MAC PPS1 Target Time Seconds        and MAC PPS1 Target Time Nanoseconds registers. Access restriction applies. Clears on read  or this bit is written to 1        when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on        internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tstargt1(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MacTimestampStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MacTimestampStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Timestamp Target Time Error   TSTRGTERR1. This bit is set when the latest target time programmed in the        MAC PPS1 Target Time Seconds and MAC PPS1 Target Time Nanoseconds        registers elapses. This bit is cleared when the application reads this        bit. Access restriction applies. Clears on read  or this bit is written to 1        when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on        internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tstrgterr1(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MacTimestampStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MacTimestampStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Timestamp Target Time Reached for Target Time PPS2   TSTARGT2. When set  this bit indicates that the value of system time is greater        than or equal to the value specified in the MAC PPS2 Target Time Seconds        and MAC PPS2 Target Time Nanoseconds registers. Access restriction applies. Clears on read  or this bit is written to 1        when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on        internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tstargt2(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MacTimestampStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<6,1,0,MacTimestampStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Timestamp Target Time Error   TSTRGTERR2. This bit is set when the latest target time programmed in the        MAC PPS2 Target Time Seconds and MAC PPS2 Target Time Nanoseconds        registers elapses. This bit is cleared when the application reads this        bit. Access restriction applies. Clears on read  or this bit is written to 1        when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on        internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tstrgterr2(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MacTimestampStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<7,1,0,MacTimestampStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Timestamp Target Time Reached for Target Time PPS3   TSTARGT3. When this bit is set  it indicates that the value of system time is        greater than or equal to the value specified in the        MAC PPS3 Target Time Seconds and MAC PPS3 Target Time Nanoseconds        registers. Access restriction applies. Clears on read  or this bit is written to 1        when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on        internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tstargt3(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacTimestampStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<8,1,0,MacTimestampStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Timestamp Target Time Error   TSTRGTERR3. This bit is set when the latest target time programmed in the        MAC PPS3 Target Time Seconds and MAC PPS3 Target Time Nanoseconds        registers elapses. This bit is cleared when the application reads this        bit. Access restriction applies. Clears on read  or this bit is written to 1        when RCWE bit in MAC CSR SW Ctrl register is set . Self set to 1 on        internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tstrgterr3(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MacTimestampStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<9,1,0,MacTimestampStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Tx Timestamp Status Interrupt Status   TXTSSIS. When drop transmit status is enabled in        MTL  this bit is set when the captured transmit timestamp is updated in        the MAC Tx Timestamp Status Nanoseconds and        MAC Tx Timestamp Status Seconds registers. When PTP offload feature is enabled  this bit is set when the captured        transmit timestamp is updated in the MAC Tx Timestamp Status Nanoseconds        and MAC Tx Timestamp Status Seconds registers  for PTO generated Delay        Request and Pdelay request packets. This bit is cleared when the MAC Tx Timestamp Status Seconds register is        read  or write to MAC Tx Timestamp Status Seconds register when RCWE bit        of MAC CSR SW Ctrl register is set . Value After Reset  0x0"]
    #[inline(always)]
    pub fn txtssis(
        self,
    ) -> crate::common::RegisterFieldBool<15, 1, 0, MacTimestampStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<15,1,0,MacTimestampStatus_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacTimestampStatus {
    #[inline(always)]
    fn default() -> MacTimestampStatus {
        <crate::RegValueT<MacTimestampStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTxTimestampStatusNanoseconds_SPEC;
impl crate::sealed::RegSpec for MacTxTimestampStatusNanoseconds_SPEC {
    type DataType = u32;
}
#[doc = "MAC Transmit Timestamp Nanoseconds Status Register\n resetvalue={Application Reset:0x0}"]
pub type MacTxTimestampStatusNanoseconds = crate::RegValueT<MacTxTimestampStatusNanoseconds_SPEC>;

impl MacTxTimestampStatusNanoseconds {
    #[doc = "Transmit Timestamp Status Low   TXTSSLO. This field contains the 31 bits of the Nanoseconds field of the Transmit packet s captured timestamp. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txtsslo(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x7fffffff,
        1,
        0,
        u32,
        MacTxTimestampStatusNanoseconds_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0x7fffffff,
            1,
            0,
            u32,
            MacTxTimestampStatusNanoseconds_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Transmit Timestamp Status Missed   TXTSSMIS. When this bit is set  it indicates one of the following  The timestamp of the current packet is ignored if TXTSSTSM bit of the MAC Timestamp Control register is reset The timestamp of the previous packet is overwritten with timestamp of the current packet if TXTSSTSM bit of the MAC Timestamp Control register is set. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txtssmis(
        self,
    ) -> crate::common::RegisterFieldBool<
        31,
        1,
        0,
        MacTxTimestampStatusNanoseconds_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterFieldBool::<
            31,
            1,
            0,
            MacTxTimestampStatusNanoseconds_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacTxTimestampStatusNanoseconds {
    #[inline(always)]
    fn default() -> MacTxTimestampStatusNanoseconds {
        <crate::RegValueT<MacTxTimestampStatusNanoseconds_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacTxTimestampStatusSeconds_SPEC;
impl crate::sealed::RegSpec for MacTxTimestampStatusSeconds_SPEC {
    type DataType = u32;
}
#[doc = "MAC Transmit Timestamp Seconds Status Register\n resetvalue={Application Reset:0x0}"]
pub type MacTxTimestampStatusSeconds = crate::RegValueT<MacTxTimestampStatusSeconds_SPEC>;

impl MacTxTimestampStatusSeconds {
    #[doc = "Transmit Timestamp Status High   TXTSSHI. This field contains the lower 32 bits of the Seconds field of Transmit packet s captured timestamp. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txtsshi(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        MacTxTimestampStatusSeconds_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            MacTxTimestampStatusSeconds_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MacTxTimestampStatusSeconds {
    #[inline(always)]
    fn default() -> MacTxTimestampStatusSeconds {
        <crate::RegValueT<MacTxTimestampStatusSeconds_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacVersion_SPEC;
impl crate::sealed::RegSpec for MacVersion_SPEC {
    type DataType = u32;
}
#[doc = "MAC Version Register\n resetvalue={Application Reset:0x1042,Application Reset:0x1050}"]
pub type MacVersion = crate::RegValueT<MacVersion_SPEC>;

impl MacVersion {
    #[doc = "Synopsys defined Version   SNPSVER. IP Version"]
    #[inline(always)]
    pub fn snpsver(
        self,
    ) -> crate::common::RegisterField<0, 0xff, 1, 0, u8, MacVersion_SPEC, crate::common::R> {
        crate::common::RegisterField::<0,0xff,1,0,u8, MacVersion_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "User defined Version  configured with coreConsultant    USERVER. Value After Reset  0x10"]
    #[inline(always)]
    pub fn userver(
        self,
    ) -> crate::common::RegisterField<8, 0xff, 1, 0, u8, MacVersion_SPEC, crate::common::R> {
        crate::common::RegisterField::<8,0xff,1,0,u8, MacVersion_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacVersion {
    #[inline(always)]
    fn default() -> MacVersion {
        <crate::RegValueT<MacVersion_SPEC> as RegisterValue<_>>::new(4160)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacVlanHashTable_SPEC;
impl crate::sealed::RegSpec for MacVlanHashTable_SPEC {
    type DataType = u32;
}
#[doc = "MAC VLAN Hash Table Register\n resetvalue={Application Reset:0x0}"]
pub type MacVlanHashTable = crate::RegValueT<MacVlanHashTable_SPEC>;

impl MacVlanHashTable {
    #[doc = "VLAN Hash Table   VLHT. This field contains the 16 bit VLAN Hash Table. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vlht(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacVlanHashTable_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacVlanHashTable_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacVlanHashTable {
    #[inline(always)]
    fn default() -> MacVlanHashTable {
        <crate::RegValueT<MacVlanHashTable_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacVlanIncl_SPEC;
impl crate::sealed::RegSpec for MacVlanIncl_SPEC {
    type DataType = u32;
}
#[doc = "MAC VLAN Tag Inclusion or Replacement Register\n resetvalue={Application Reset:0x0}"]
pub type MacVlanIncl = crate::RegValueT<MacVlanIncl_SPEC>;

impl MacVlanIncl {
    #[doc = "VLAN Tag for Transmit Packets   VLT. This field contains the value of the VLAN tag to be inserted or        replaced. The value must only be changed when the transmit lines are        inactive or during the initialization phase. Bits 15 13  are the User Priority field  Bit 12 is the CFI DEI field         and Bits 11 0  are the VID field in the VLAN tag. The following list describes the bits of this field  Bits 15 13   User Priority Bit 12  Canonical Format Indicator  CFI  or Drop Eligible Indicator           DEI  Bits 11 0   VLAN Identifier  VID  field of VLAN tag Value After Reset  0x0"]
    #[inline(always)]
    pub fn vlt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacVlanIncl_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacVlanIncl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Tag Control in Transmit Packets   VLC. Note   Changes to this field take effect        only on the start of a packet. If you write this register field when a        packet is being transmitted  only the subsequent packet can use the        updated value  that is  the current packet does not use the updated        value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vlc(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MacVlanIncl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<16,0x3,1,0,u8, MacVlanIncl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Priority Control   VLP. When this bit is set  the control bits 17 16  are used for VLAN        deletion  insertion  or replacement. When this bit is reset  the        mti vlan ctrl i control input is used and bits 17 16  are ignored. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vlp(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacVlanIncl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<18,1,0,MacVlanIncl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "C VLAN or S VLAN   CSVL. When this bit is set  S VLAN type  0x88A8  is inserted or replaced in        the 13th and 14th bytes of transmitted packets. When this bit is reset         C VLAN type  0x8100  is inserted or replaced in the 13th and 14th bytes        of transmitted packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn csvl(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MacVlanIncl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<19,1,0,MacVlanIncl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Tag Input   VLTI. When this bit is set  it indicates that the VLAN tag to be inserted or        replaced in Tx packet should be taken from  The Tx descriptor Value After Reset  0x0"]
    #[inline(always)]
    pub fn vlti(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MacVlanIncl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<20,1,0,MacVlanIncl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Channel based tag insertion   CBTI. When this bit is set  outer VLAN tag is inserted for every packets transmitted by the MAC.        The tag value is taken from the queue channel specific VLAN tag register. The VLTI  VLP  VLC and VLT fields of this register        are ignored when this bit is set. When this bit is set  a write operation to byte 3 of this register initiates the read write access to the indirect register. When reset outer VLAN operation is based on the setting of VLTI  VLP  VLC and VLT fields of this register Value After Reset  0x0"]
    #[inline(always)]
    pub fn cbti(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MacVlanIncl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<21,1,0,MacVlanIncl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Address   ADDR. This field selects one of the queue channel specific VLAN Inclusion        register for read write access This doesn  8217 t have any effect when CBTI is reset Value After Reset  0x0"]
    #[inline(always)]
    pub fn addr(
        self,
    ) -> crate::common::RegisterField<24, 0x3, 1, 0, u8, MacVlanIncl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<24,0x3,1,0,u8, MacVlanIncl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Read write control   RDWR. This bit controls the read or write operation for indirectly accessing        the queue channel specific VLAN Inclusion register. When set indicates write operation and when reset indicates read        operation This doesn  8217 t have any effect when CBTI is reset Value After Reset  0x0"]
    #[inline(always)]
    pub fn rdwr(
        self,
    ) -> crate::common::RegisterFieldBool<30, 1, 0, MacVlanIncl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<30,1,0,MacVlanIncl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Busy   BUSY. Value After Reset  0x0"]
    #[inline(always)]
    pub fn busy(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacVlanIncl_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<31,1,0,MacVlanIncl_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MacVlanIncl {
    #[inline(always)]
    fn default() -> MacVlanIncl {
        <crate::RegValueT<MacVlanIncl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacVlanInclQI_SPEC;
impl crate::sealed::RegSpec for MacVlanInclQI_SPEC {
    type DataType = u32;
}
#[doc = "MAC VLAN Tag Inclusion or Replacement Register per Queue\n resetvalue={Application Reset:0x0}"]
pub type MacVlanInclQI = crate::RegValueT<MacVlanInclQI_SPEC>;

impl MacVlanInclQI {
    #[doc = "VLAN Tag for Transmit Packets   VLT. This field contains the value of the VLAN tag to be inserted. The value must only be changed when the transmit lines are inactive or during the initialization phase. Bits 15 13  are the User Priority field  Bit 12 is the CFI DEI field  and Bits 11 0  are the VID field in the VLAN tag. The following list describes the bits of this field  Bits 15 13   User Priority Bit 12  Canonical Format Indicator  CFI  or Drop Eligible Indicator  DEI  Bits 11 0   VLAN Identifier  VID  field of VLAN tag Value After Reset  0x0"]
    #[inline(always)]
    pub fn vlt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacVlanInclQI_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacVlanInclQI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "C VLAN or S VLAN   CSVL. When this bit is set  S VLAN type  0x88A8  is inserted in the 13th and 14th bytes of transmitted packets. When this bit is reset  C VLAN type  0x8100  is inserted in the 13th and 14th bytes of transmitted packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn csvl(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MacVlanInclQI_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<19,1,0,MacVlanInclQI_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacVlanInclQI {
    #[inline(always)]
    fn default() -> MacVlanInclQI {
        <crate::RegValueT<MacVlanInclQI_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacVlanTagCtrl_SPEC;
impl crate::sealed::RegSpec for MacVlanTagCtrl_SPEC {
    type DataType = u32;
}
#[doc = "MAC VLAN Tag Control Register\n resetvalue={Application Reset:0x0}"]
pub type MacVlanTagCtrl = crate::RegValueT<MacVlanTagCtrl_SPEC>;

impl MacVlanTagCtrl {
    #[doc = "Operation Busy   OB. This bit is set along with a read or write command for initiating the indirect access to per VLAN Tag Filter register. This bit is              reset when the read or write command to per VLAN Tag Filter indirect access register is complete.The next indirect register access can be initiated only after              this bit is reset. During a write operation  the bit is reset only after the data has been written into the Per VLAN Tag register.              During a read operation  the data should be read from the MAC VLAN Tag Data register only after this bit is reset. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ob(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MacVlanTagCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Command Type   CT. This bit indicates if the current register access is a read or a write. When set  it indicate a read operation. When reset  it indicates a write operation. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ct(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MacVlanTagCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1,1,0,MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Offset   OFS. This field holds the address offset of the MAC VLAN Tag Filter Register which the application is trying to access. The width of the field depends on the number of MAC VLAN Tag Registers enabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ofs(
        self,
    ) -> crate::common::RegisterField<2, 0x1f, 1, 0, u8, MacVlanTagCtrl_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<2,0x1f,1,0,u8, MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Tag Inverse Match Enable   VTIM. When this bit is set  this bit enables the VLAN Tag inverse matching.        The packets without matching VLAN Tag are marked as matched. When reset         this bit enables the VLAN Tag perfect matching. The packets with matched        VLAN Tag are marked as matched. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vtim(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MacVlanTagCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<17,1,0,MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable S VLAN   ESVL. When this bit is set  the MAC transmitter and receiver consider the S VLAN packets  Type   0x88A8  as valid VLAN tagged packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn esvl(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacVlanTagCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<18,1,0,MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable VLAN Tag Stripping on Receive   EVLS. This field indicates the stripping operation on the outer VLAN Tag in received packet  Value After Reset  0x0"]
    #[inline(always)]
    pub fn evls(
        self,
    ) -> crate::common::RegisterField<21, 0x3, 1, 0, u8, MacVlanTagCtrl_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<21,0x3,1,0,u8, MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable VLAN Tag in Rx status   EVLRXS. When this bit is set  MAC provides the outer VLAN Tag in the Rx status. When this bit is reset  the MAC does not provide the outer VLAN Tag in Rx status. Value After Reset  0x0"]
    #[inline(always)]
    pub fn evlrxs(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MacVlanTagCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<24,1,0,MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Tag Hash Table Match Enable   VTHM. When this bit is set  the most significant four bits of CRC of VLAN Tag               ones complement of most significant four bits of CRC of VLAN Tag when ETV bit is reset               are used to index the content of the MAC VLAN Hash Table register. A value of 1 in the              VLAN Hash Table register  corresponding to the index  indicates that the packet matched the VLAN hash table. When the ETV bit is set  the CRC of the 12 bit VLAN Identifier  VID  is used for comparison. When the ETV bit is reset  the ones complement of the CRC of the 16 bit VLAN tag is used for comparison. When this bit is reset  the VLAN Hash Match operation is not performed. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vthm(
        self,
    ) -> crate::common::RegisterFieldBool<25, 1, 0, MacVlanTagCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<25,1,0,MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Double VLAN Processing   EDVLP. When this bit is set  the MAC enables processing of up to two VLAN Tags on Tx and Rx  if present . When this bit is reset  the MAC enables processing of up to one VLAN Tag on Tx and Rx  if present . Value After Reset  0x0"]
    #[inline(always)]
    pub fn edvlp(
        self,
    ) -> crate::common::RegisterFieldBool<26, 1, 0, MacVlanTagCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<26,1,0,MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Reserved   RES 27. Value After Reset  0x0"]
    #[inline(always)]
    pub fn res_27(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, MacVlanTagCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<27,1,0,MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Inner VLAN Tag Stripping on Receive   EIVLS. This field indicates the stripping operation on inner VLAN Tag in received packet  Value After Reset  0x0"]
    #[inline(always)]
    pub fn eivls(
        self,
    ) -> crate::common::RegisterField<28, 0x3, 1, 0, u8, MacVlanTagCtrl_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<28,0x3,1,0,u8, MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Inner VLAN Tag in Rx Status   EIVLRXS. When this bit is set  the MAC provides the inner VLAN Tag in the Rx status. When this bit is reset  the MAC does not provide the inner VLAN Tag in Rx status. Value After Reset  0x0"]
    #[inline(always)]
    pub fn eivlrxs(
        self,
    ) -> crate::common::RegisterFieldBool<31, 1, 0, MacVlanTagCtrl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<31,1,0,MacVlanTagCtrl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacVlanTagCtrl {
    #[inline(always)]
    fn default() -> MacVlanTagCtrl {
        <crate::RegValueT<MacVlanTagCtrl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacVlanTagData_SPEC;
impl crate::sealed::RegSpec for MacVlanTagData_SPEC {
    type DataType = u32;
}
#[doc = "MAC VLAN Tag Data Register\n resetvalue={Application Reset:0x0}"]
pub type MacVlanTagData = crate::RegValueT<MacVlanTagData_SPEC>;

impl MacVlanTagData {
    #[doc = "VLAN Tag ID   VID. This field holds the VLAN Tag value which is used by the MAC for perfect comparison. It is valid when VLAN Tag Enable is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vid(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacVlanTagData_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, MacVlanTagData_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "VLAN Tag Enable   VEN. This bit is used to enable or disable the VLAN Tag. When this bit is        set  the MAC compares the VLAN Tag of received packet with the VLAN Tag        ID. When this bit is reset  no comparison is performed irrespective of        the programming of the other fields. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ven(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacVlanTagData_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<16,1,0,MacVlanTagData_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "12bits or 16bits VLAN comparison   ETV. This bit is valid only when VEN of the Filter is set. When this bit is set  a 12 bit VLAN identifier is used for comparing and filtering instead of the complete 16 bit VLAN tag. Bits  11 0  of VLAN tag are compared with the corresponding field in the received VLAN tagged packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn etv(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MacVlanTagData_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<17,1,0,MacVlanTagData_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Disable VLAN Type Comparison   DOVLTC. This bit is valid only when VLAN Tag Enable of the Filter is set. When        this bit is set  the MAC does not check whether the VLAN Tag specified        by the Enable Inner VLAN Tag Comparison bit is of type S VLAN or C VLAN.        When this bit is reset  the MAC filters or matches the VLAN Tag        specified by the Enable Inner VLAN Tag Comparison bit only when VLAN Tag        type is similar to the one specified by the Enable S VLAN Match for        received Frames bit. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dovltc(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacVlanTagData_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<18,1,0,MacVlanTagData_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable S VLAN Match for received Frames   ERSVLM. This bit is valid only when VLAN Tag Enable of the Filter is set. When        this bit is set  the MAC receiver enables filtering or matching for        S VLAN  Type   0x88A8  packets. When this bit is reset  the MAC receiver        enables filtering or matching for C VLAN  Type   0x8100  packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ersvlm(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MacVlanTagData_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<19,1,0,MacVlanTagData_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Inner VLAN Tag Comparison   ERIVLT. This bit is valid only when VLAN Tag Enable of the Filter is set. When this bit and the EDVLP field are set  the MAC receiver enables operation on the inner VLAN Tag  if present . When this bit is reset  the MAC receiver enables operation on the outer VLAN Tag  if present . Value After Reset  0x0"]
    #[inline(always)]
    pub fn erivlt(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MacVlanTagData_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<20,1,0,MacVlanTagData_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Number Enable   DMACHEN. This bit is the Enable for the DMA Channel Number value programmed in the field DMACH. When this bit is reset  the Routing does not occur based on VLAN Filter result. The frame is routed based on DA Based DMA Channel Routing. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dmachen(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MacVlanTagData_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<24,1,0,MacVlanTagData_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Number   DMACHN. The DMA Channel number to which the VLAN Tagged Frame is to be routed if it passes this VLAN Tag Filter is programmed in this field. If the Routing based on VLAN Tag Filter is not necessary  this field need not be programmed. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dmachn(
        self,
    ) -> crate::common::RegisterField<25, 0x3, 1, 0, u8, MacVlanTagData_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<25,0x3,1,0,u8, MacVlanTagData_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacVlanTagData {
    #[inline(always)]
    fn default() -> MacVlanTagData {
        <crate::RegValueT<MacVlanTagData_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacVlanTagFilterI_SPEC;
impl crate::sealed::RegSpec for MacVlanTagFilterI_SPEC {
    type DataType = u32;
}
#[doc = "MAC VLAN Tag Filter Register\n resetvalue={Application Reset:0x0}"]
pub type MacVlanTagFilterI = crate::RegValueT<MacVlanTagFilterI_SPEC>;

impl MacVlanTagFilterI {
    #[doc = "VLAN Tag ID   VID. This field holds the VLAN Tag value which is used by the MAC for perfect comparison. It is valid when VLAN Tag Enable is set. Value After Reset  0x0"]
    #[inline(always)]
    pub fn vid(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, MacVlanTagFilterI_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            MacVlanTagFilterI_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "VLAN Tag Enable   VEN. This bit is used to enable or disable the VLAN Tag. When this bit is        set  the MAC compares the VLAN Tag of received packet with the VLAN Tag        ID. When this bit is reset  no comparison is performed irrespective of        the programming of the other fields. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ven(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MacVlanTagFilterI_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<16,1,0,MacVlanTagFilterI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "12bits or 16bits VLAN comparison   ETV. This bit is valid only when VEN of the Filter is set. When this bit is set  a 12 bit VLAN identifier is used for comparing and filtering instead of the complete 16 bit VLAN tag. Bits  11 0  of VLAN tag are compared with the corresponding field in the received VLAN tagged packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn etv(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MacVlanTagFilterI_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<17,1,0,MacVlanTagFilterI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Disable VLAN Type Comparison   DOVLTC. This bit is valid only when VLAN Tag Enable of the Filter is set. When        this bit is set  the MAC does not check whether the VLAN Tag specified        by the Enable Inner VLAN Tag Comparison bit is of type S VLAN or C VLAN.        When this bit is reset  the MAC filters or matches the VLAN Tag        specified by the Enable Inner VLAN Tag Comparison bit only when VLAN Tag        type is similar to the one specified by the Enable S VLAN Match for        received Frames bit. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dovltc(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MacVlanTagFilterI_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<18,1,0,MacVlanTagFilterI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable S VLAN Match for received Frames   ERSVLM. This bit is valid only when VLAN Tag Enable of the Filter is set. When        this bit is set  the MAC receiver enables filtering or matching for        S VLAN  Type   0x88A8  packets. When this bit is reset  the MAC receiver        enables filtering or matching for C VLAN  Type   0x8100  packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ersvlm(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MacVlanTagFilterI_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<19,1,0,MacVlanTagFilterI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Inner VLAN Tag Comparison   ERIVLT. This bit is valid only when VLAN Tag Enable of the Filter is set. When this bit and the EDVLP field are set  the MAC receiver enables operation on the inner VLAN Tag  if present . When this bit is reset  the MAC receiver enables operation on the outer VLAN Tag  if present . Value After Reset  0x0"]
    #[inline(always)]
    pub fn erivlt(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MacVlanTagFilterI_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<20,1,0,MacVlanTagFilterI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Number Enable   DMACHEN. This bit is the Enable for the DMA Channel Number value programmed in the field DMACH. When this bit is reset  the Routing does not occur based on VLAN Filter result. The frame is routed based on DA Based DMA Channel Routing. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dmachen(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MacVlanTagFilterI_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<24,1,0,MacVlanTagFilterI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "DMA Channel Number   DMACHN. The DMA Channel number to which the VLAN Tagged Frame is to be routed if it passes this VLAN Tag Filter is programmed in this field. If the Routing based on VLAN Tag Filter is not necessary  this field need not be programmed. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dmachn(
        self,
    ) -> crate::common::RegisterField<25, 0x3, 1, 0, u8, MacVlanTagFilterI_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<25,0x3,1,0,u8, MacVlanTagFilterI_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacVlanTagFilterI {
    #[inline(always)]
    fn default() -> MacVlanTagFilterI {
        <crate::RegValueT<MacVlanTagFilterI_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MacWatchdogTimeout_SPEC;
impl crate::sealed::RegSpec for MacWatchdogTimeout_SPEC {
    type DataType = u32;
}
#[doc = "MAC Watchdog Timeout Register\n resetvalue={Application Reset:0x0}"]
pub type MacWatchdogTimeout = crate::RegValueT<MacWatchdogTimeout_SPEC>;

impl MacWatchdogTimeout {
    #[doc = "Watchdog Timeout   WTO. When the PWE bit is set and the WD bit of the MAC Configuration register is reset  this field is used as watchdog timeout for a received packet. If the length of a received packet exceeds the value of this field  such packet is terminated and declared as an error packet. Encoding is as follows  LOST SEQUENCE DEFINITION Note   When the PWE bit is set  the value in this field should be more than 1 522  0x05F2 . Otherwise  the IEEE 802.3 specified valid tagged packets are declared as error packets and then dropped. Value After Reset  0x0"]
    #[inline(always)]
    pub fn wto(
        self,
    ) -> crate::common::RegisterField<0, 0xf, 1, 0, u8, MacWatchdogTimeout_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xf,1,0,u8, MacWatchdogTimeout_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Programmable Watchdog Enable   PWE. When this bit is set and the WD bit of the MAC Configuration register is reset  the WTO field is used as watchdog timeout for a received packet. When this bit is cleared  the watchdog timeout for a received packet is controlled by setting of WD and JE bits in MAC Configuration register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn pwe(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MacWatchdogTimeout_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<8,1,0,MacWatchdogTimeout_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MacWatchdogTimeout {
    #[inline(always)]
    fn default() -> MacWatchdogTimeout {
        <crate::RegValueT<MacWatchdogTimeout_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MmcControl_SPEC;
impl crate::sealed::RegSpec for MmcControl_SPEC {
    type DataType = u32;
}
#[doc = "MMC Control Register\n resetvalue={Application Reset:0x0}"]
pub type MmcControl = crate::RegValueT<MmcControl_SPEC>;

impl MmcControl {
    #[doc = "Counters Reset   CNTRST. When this bit is set  all counters are reset. This bit is cleared automatically after 1 clock cycle. Access restriction applies. Self cleared. Setting 0 clears. Setting 1 sets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cntrst(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MmcControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MmcControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Counter Stop Rollover   CNTSTOPRO. When this bit is set  the counter does not roll over to zero after reaching the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cntstopro(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MmcControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1,1,0,MmcControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Reset on Read   RSTONRD. When this bit is set  the MMC counters are reset to zero after Read  self clearing after reset . The counters are cleared when the least significant byte lane  Bits 7 0   is read. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rstonrd(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MmcControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<2,1,0,MmcControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Counter Freeze   CNTFREEZ. When this bit is set  it freezes all MMC counters to their current value. Until this bit is reset to 0  no MMC counter is updated because of any transmitted or received packet. If any MMC counter is read with the Reset on Read bit set  then that counter is also cleared in this mode. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cntfreez(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MmcControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MmcControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Counters Preset   CNTPRST. When this bit is set  all counters are initialized or preset to almost full or almost half according to the CNTPRSTLVL bit. This bit is cleared automatically after 1 clock cycle. This bit  along with the CNTPRSTLVL bit  is useful for debugging and testing the assertion of interrupts because of MMC counter becoming half full or full. Access restriction applies. Self cleared. Setting 0 clears. Setting 1 sets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cntprst(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MmcControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<4,1,0,MmcControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Full Half Preset   CNTPRSTLVL. When this bit is low and the CNTPRST bit is set  all MMC counters get preset to almost half value. All octet counters get preset to 0x7FFF F800  Half 2KBytes  and all packet counters gets preset to 0x7FFF FFF0  Half 16 . When this bit is high and the CNTPRST bit is set  all MMC counters get preset to almost full value. All octet counters get preset to 0xFFFF F800  Full 2KBytes  and all packet counters gets preset to 0xFFFF FFF0  Full 16 . For 16 bit counters  the almost half preset values are 0x7800 and 0x7FF0 for the respective octet and packet counters. Similarly  the almost full preset values for the 16 bit counters are 0xF800 and 0xFFF0. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cntprstlvl(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MmcControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<5,1,0,MmcControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Update MMC Counters for Dropped Broadcast Packets   UCDBC. When set  the MAC updates all related MMC Counters for Broadcast packets that are dropped because of the setting of the DBF bit of MAC Packet Filter register. When reset  the MMC Counters are not updated for dropped Broadcast packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ucdbc(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MmcControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<8,1,0,MmcControl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MmcControl {
    #[inline(always)]
    fn default() -> MmcControl {
        <crate::RegValueT<MmcControl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MmcIpcRxInterrupt_SPEC;
impl crate::sealed::RegSpec for MmcIpcRxInterrupt_SPEC {
    type DataType = u32;
}
#[doc = "MMC IPC Receive Interrupts Register\n resetvalue={Application Reset:0x0}"]
pub type MmcIpcRxInterrupt = crate::RegValueT<MmcIpcRxInterrupt_SPEC>;

impl MmcIpcRxInterrupt {
    #[doc = "MMC Receive IPV4 Good Packet Counter Interrupt Status   RXIPV4GPIS. This bit is set when the rxipv4 gd pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4gpis(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 Header Error Packet Counter Interrupt Status   RXIPV4HERPIS. This bit is set when the rxipv4 hdrerr pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4herpis(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 No Payload Packet Counter Interrupt Status   RXIPV4NOPAYPIS. This bit is set when the rxipv4 nopay pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4nopaypis(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<2,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 Fragmented Packet Counter Interrupt Status   RXIPV4FRAGPIS. This bit is set when the rxipv4 frag pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4fragpis(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Status   RXIPV4UDSBLPIS. This bit is set when the rxipv4 udsbl pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4udsblpis(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 Good Packet Counter Interrupt Status   RXIPV6GPIS. This bit is set when the rxipv6 gd pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6gpis(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 Header Error Packet Counter Interrupt Status   RXIPV6HERPIS. This bit is set when the rxipv6 hdrerr pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6herpis(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<6,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 No Payload Packet Counter Interrupt Status   RXIPV6NOPAYPIS. This bit is set when the rxipv6 nopay pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6nopaypis(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<7,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MC Receive UDP Good Packet Counter Interrupt Status   RXUDPGPIS. This bit is set when the rxudp gd pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudpgpis(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<8,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive UDP Error Packet Counter Interrupt Status   RXUDPERPIS. This bit is set when the rxudp err pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudperpis(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<9,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive TCP Good Packet Counter Interrupt Status   RXTCPGPIS. This bit is set when the rxtcp gd pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcpgpis(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<10,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive TCP Error Packet Counter Interrupt Status   RXTCPERPIS. This bit is set when the rxtcp err pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcperpis(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<11,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive ICMP Good Packet Counter Interrupt Status   RXICMPGPIS. This bit is set when the rxicmp gd pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmpgpis(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<12,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive ICMP Error Packet Counter Interrupt Status   RXICMPERPIS. This bit is set when the rxicmp err pkts counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmperpis(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<13,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 Good Octet Counter Interrupt Status   RXIPV4GOIS. This bit is set when the rxipv4 gd octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4gois(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<16,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 Header Error Octet Counter Interrupt Status   RXIPV4HEROIS. This bit is set when the rxipv4 hdrerr octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4herois(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<17,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 No Payload Octet Counter Interrupt Status   RXIPV4NOPAYOIS. This bit is set when the rxipv4 nopay octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4nopayois(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<18,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 Fragmented Octet Counter Interrupt Status   RXIPV4FRAGOIS. This bit is set when the rxipv4 frag octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4fragois(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<19,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Status   RXIPV4UDSBLOIS. This bit is set when the rxipv4 udsbl octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4udsblois(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<20,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 Good Octet Counter Interrupt Status   RXIPV6GOIS. This bit is set when the rxipv6 gd octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6gois(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<21,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 Header Error Octet Counter Interrupt Status   RXIPV6HEROIS. This bit is set when the rxipv6 hdrerr octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6herois(
        self,
    ) -> crate::common::RegisterFieldBool<22, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<22,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 No Payload Octet Counter Interrupt Status   RXIPV6NOPAYOIS. This bit is set when the rxipv6 nopay octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6nopayois(
        self,
    ) -> crate::common::RegisterFieldBool<23, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<23,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive UDP Good Octet Counter Interrupt Status   RXUDPGOIS. This bit is set when the rxudp gd octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudpgois(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<24,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive UDP Error Octet Counter Interrupt Status   RXUDPEROIS. This bit is set when the rxudp err octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudperois(
        self,
    ) -> crate::common::RegisterFieldBool<25, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<25,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive TCP Good Octet Counter Interrupt Status   RXTCPGOIS. This bit is set when the rxtcp gd octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcpgois(
        self,
    ) -> crate::common::RegisterFieldBool<26, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<26,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive TCP Error Octet Counter Interrupt Status   RXTCPEROIS. This bit is set when the rxtcp err octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcperois(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<27,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive ICMP Good Octet Counter Interrupt Status   RXICMPGOIS. This bit is set when the rxicmp gd octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmpgois(
        self,
    ) -> crate::common::RegisterFieldBool<28, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<28,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive ICMP Error Octet Counter Interrupt Status   RXICMPEROIS. This bit is set when the rxicmp err octets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmperois(
        self,
    ) -> crate::common::RegisterFieldBool<29, 1, 0, MmcIpcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<29,1,0,MmcIpcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MmcIpcRxInterrupt {
    #[inline(always)]
    fn default() -> MmcIpcRxInterrupt {
        <crate::RegValueT<MmcIpcRxInterrupt_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MmcIpcRxInterruptMask_SPEC;
impl crate::sealed::RegSpec for MmcIpcRxInterruptMask_SPEC {
    type DataType = u32;
}
#[doc = "MMC IPC Receive Interrupts Mask Register\n resetvalue={Application Reset:0x0}"]
pub type MmcIpcRxInterruptMask = crate::RegValueT<MmcIpcRxInterruptMask_SPEC>;

impl MmcIpcRxInterruptMask {
    #[doc = "MMC Receive IPV4 Good Packet Counter Interrupt Mask   RXIPV4GPIM. Setting this bit masks the interrupt when the rxipv4 gd pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4gpim(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<0,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 Header Error Packet Counter Interrupt Mask   RXIPV4HERPIM. Setting this bit masks the interrupt when the rxipv4 hdrerr pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4herpim(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<1,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 No Payload Packet Counter Interrupt Mask   RXIPV4NOPAYPIM. Setting this bit masks the interrupt when the rxipv4 nopay pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4nopaypim(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<2,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 Fragmented Packet Counter Interrupt Mask   RXIPV4FRAGPIM. Setting this bit masks the interrupt when the rxipv4 frag pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4fragpim(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<3,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 UDP Checksum Disabled Packet Counter Interrupt Mask   RXIPV4UDSBLPIM. Setting this bit masks the interrupt when the rxipv4 udsbl pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4udsblpim(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<4,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 Good Packet Counter Interrupt Mask   RXIPV6GPIM. Setting this bit masks the interrupt when the rxipv6 gd pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6gpim(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<5,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 Header Error Packet Counter Interrupt Mask   RXIPV6HERPIM. Setting this bit masks the interrupt when the rxipv6 hdrerr pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6herpim(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<6,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 No Payload Packet Counter Interrupt Mask   RXIPV6NOPAYPIM. Setting this bit masks the interrupt when the rxipv6 nopay pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6nopaypim(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<7,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive UDP Good Packet Counter Interrupt Mask   RXUDPGPIM. Setting this bit masks the interrupt when the rxudp gd pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudpgpim(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<8,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive UDP Error Packet Counter Interrupt Mask   RXUDPERPIM. Setting this bit masks the interrupt when the rxudp err pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudperpim(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<9,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive TCP Good Packet Counter Interrupt Mask   RXTCPGPIM. Setting this bit masks the interrupt when the rxtcp gd pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcpgpim(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<10,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive TCP Error Packet Counter Interrupt Mask   RXTCPERPIM. Setting this bit masks the interrupt when the rxtcp err pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcperpim(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<11,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive ICMP Good Packet Counter Interrupt Mask   RXICMPGPIM. Setting this bit masks the interrupt when the rxicmp gd pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmpgpim(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<12,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive ICMP Error Packet Counter Interrupt Mask   RXICMPERPIM. Setting this bit masks the interrupt when the rxicmp err pkts counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmperpim(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<13,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 Good Octet Counter Interrupt Mask   RXIPV4GOIM. Setting this bit masks the interrupt when the rxipv4 gd octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4goim(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<16,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 Header Error Octet Counter Interrupt Mask   RXIPV4HEROIM. Setting this bit masks the interrupt when the rxipv4 hdrerr octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4heroim(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<17,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 No Payload Octet Counter Interrupt Mask   RXIPV4NOPAYOIM. Setting this bit masks the interrupt when the rxipv4 nopay octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4nopayoim(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<18,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 Fragmented Octet Counter Interrupt Mask   RXIPV4FRAGOIM. Setting this bit masks the interrupt when the rxipv4 frag octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4fragoim(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<19,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV4 UDP Checksum Disabled Octet Counter Interrupt Mask   RXIPV4UDSBLOIM. Setting this bit masks the interrupt when the rxipv4 udsbl octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4udsbloim(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<20,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 Good Octet Counter Interrupt Mask   RXIPV6GOIM. Setting this bit masks the interrupt when the rxipv6 gd octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6goim(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<21,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 Good Octet Counter Interrupt Mask   RXIPV6HEROIM. Setting this bit masks the interrupt when the rxipv6 hdrerr octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6heroim(
        self,
    ) -> crate::common::RegisterFieldBool<22, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<22,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 Header Error Octet Counter Interrupt Mask   RXIPV6NOPAYOIM. Setting this bit masks the interrupt when the rxipv6 nopay octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6nopayoim(
        self,
    ) -> crate::common::RegisterFieldBool<23, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<23,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive IPV6 No Payload Octet Counter Interrupt Mask   RXUDPGOIM. Setting this bit masks the interrupt when the rxudp gd octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudpgoim(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<24,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive UDP Good Octet Counter Interrupt Mask   RXUDPEROIM. Setting this bit masks the interrupt when the rxudp err octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudperoim(
        self,
    ) -> crate::common::RegisterFieldBool<25, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<25,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive TCP Good Octet Counter Interrupt Mask   RXTCPGOIM. Setting this bit masks the interrupt when the rxtcp gd octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcpgoim(
        self,
    ) -> crate::common::RegisterFieldBool<26, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<26,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive TCP Error Octet Counter Interrupt Mask   RXTCPEROIM. Setting this bit masks the interrupt when the rxtcp err octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcperoim(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<27,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive ICMP Good Octet Counter Interrupt Mask   RXICMPGOIM. Setting this bit masks the interrupt when the rxicmp gd octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmpgoim(
        self,
    ) -> crate::common::RegisterFieldBool<28, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<28,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive ICMP Error Octet Counter Interrupt Mask   RXICMPEROIM. Setting this bit masks the interrupt when the rxicmp err octets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmperoim(
        self,
    ) -> crate::common::RegisterFieldBool<29, 1, 0, MmcIpcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<29,1,0,MmcIpcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MmcIpcRxInterruptMask {
    #[inline(always)]
    fn default() -> MmcIpcRxInterruptMask {
        <crate::RegValueT<MmcIpcRxInterruptMask_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MmcRxInterrupt_SPEC;
impl crate::sealed::RegSpec for MmcRxInterrupt_SPEC {
    type DataType = u32;
}
#[doc = "MMC Receive Interrupts Register\n resetvalue={Application Reset:0x0}"]
pub type MmcRxInterrupt = crate::RegValueT<MmcRxInterrupt_SPEC>;

impl MmcRxInterrupt {
    #[doc = "MMC Receive Good Bad Packet Counter Interrupt Status   RXGBPKTIS. This bit is set when the rxpacketcount gb counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxgbpktis(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Good Bad Octet Counter Interrupt Status   RXGBOCTIS. This bit is set when the rxoctetcount gb counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxgboctis(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Good Octet Counter Interrupt Status   RXGOCTIS. This bit is set when the rxoctetcount g counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxgoctis(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<2,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Broadcast Good Packet Counter Interrupt Status   RXBCGPIS. This bit is set when the rxbroadcastpackets g counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxbcgpis(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Multicast Good Packet Counter Interrupt Status   RXMCGPIS. This bit is set when the rxmulticastpackets g counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxmcgpis(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive CRC Error Packet Counter Interrupt Status   RXCRCERPIS. This bit is set when the rxcrcerror counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxcrcerpis(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Alignment Error Packet Counter Interrupt Status   RXALGNERPIS. This bit is set when the rxalignmenterror counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxalgnerpis(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<6,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Runt Packet Counter Interrupt Status   RXRUNTPIS. This bit is set when the rxrunterror counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxruntpis(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<7,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Jabber Error Packet Counter Interrupt Status   RXJABERPIS. This bit is set when the rxjabbererror counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxjaberpis(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<8,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Undersize Good Packet Counter Interrupt Status   RXUSIZEGPIS. This bit is set when the rxundersize g counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxusizegpis(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<9,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Oversize Good Packet Counter Interrupt Status   RXOSIZEGPIS. This bit is set when the rxoversize g counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxosizegpis(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<10,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive 64 Octet Good Bad Packet Counter Interrupt Status   RX64OCTGBPIS. This bit is set when the rx64octets gb counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx64octgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<11,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive 65 to 127 Octet Good Bad Packet Counter Interrupt Status   RX65T127OCTGBPIS. This bit is set when the rx65to127octets gb counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx65t127octgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<12,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive 128 to 255 Octet Good Bad Packet Counter Interrupt Status   RX128T255OCTGBPIS. This bit is set when the rx128to255octets gb counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx128t255octgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<13,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive 256 to 511 Octet Good Bad Packet Counter Interrupt Status   RX256T511OCTGBPIS. This bit is set when the rx256to511octets gb counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx256t511octgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<14,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive 512 to 1023 Octet Good Bad Packet Counter Interrupt Status   RX512T1023OCTGBPIS. This bit is set when the rx512to1023octets gb counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx512t1023octgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<15, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<15,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive 1024 to Maximum Octet Good Bad Packet Counter Interrupt Status   RX1024TMAXOCTGBPIS. This bit is set when the rx1024tomaxoctets gb counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx1024tmaxoctgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<16,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Unicast Good Packet Counter Interrupt Status   RXUCGPIS. This bit is set when the rxunicastpackets g counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxucgpis(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<17,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Length Error Packet Counter Interrupt Status   RXLENERPIS. This bit is set when the rxlengtherror counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxlenerpis(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<18,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Out Of Range Error Packet Counter Interrupt Status.   RXORANGEPIS. This bit is set when the rxoutofrangetype counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxorangepis(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<19,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Pause Packet Counter Interrupt Status   RXPAUSPIS. This bit is set when the rxpausepackets counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxpauspis(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<20,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive FIFO Overflow Packet Counter Interrupt Status   RXFOVPIS. This bit is set when the rxfifooverflow counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxfovpis(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<21,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive VLAN Good Bad Packet Counter Interrupt Status   RXVLANGBPIS. This bit is set when the rxvlanpackets gb counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxvlangbpis(
        self,
    ) -> crate::common::RegisterFieldBool<22, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<22,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Watchdog Error Packet Counter Interrupt Status   RXWDOGPIS. This bit is set when the rxwatchdog error counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxwdogpis(
        self,
    ) -> crate::common::RegisterFieldBool<23, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<23,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Error Packet Counter Interrupt Status   RXRCVERRPIS. This bit is set when the rxrcverror counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxrcverrpis(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<24,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive Control Packet Counter Interrupt Status   RXCTRLPIS. This bit is set when the rxctrlpackets g counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxctrlpis(
        self,
    ) -> crate::common::RegisterFieldBool<25, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<25,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive LPI microsecond counter interrupt status   RXLPIUSCIS. This bit is set when the Rx LPI USEC Cntr counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxlpiuscis(
        self,
    ) -> crate::common::RegisterFieldBool<26, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<26,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Receive LPI transition counter interrupt status   RXLPITRCIS. This bit is set when the Rx LPI Tran Cntr counter reaches half of the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxlpitrcis(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, MmcRxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<27,1,0,MmcRxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MmcRxInterrupt {
    #[inline(always)]
    fn default() -> MmcRxInterrupt {
        <crate::RegValueT<MmcRxInterrupt_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MmcRxInterruptMask_SPEC;
impl crate::sealed::RegSpec for MmcRxInterruptMask_SPEC {
    type DataType = u32;
}
#[doc = "MMC Receive Interrupts Mask Register\n resetvalue={Application Reset:0x0}"]
pub type MmcRxInterruptMask = crate::RegValueT<MmcRxInterruptMask_SPEC>;

impl MmcRxInterruptMask {
    #[doc = "MMC Receive Good Bad Packet Counter Interrupt Mask   RXGBPKTIM. Setting this bit masks the interrupt when the rxpacketcount gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxgbpktim(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Good Bad Octet Counter Interrupt Mask   RXGBOCTIM. Setting this bit masks the interrupt when the rxoctetcount gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxgboctim(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Good Octet Counter Interrupt Mask   RXGOCTIM. Setting this bit masks the interrupt when the rxoctetcount g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxgoctim(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<2,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Broadcast Good Packet Counter Interrupt Mask   RXBCGPIM. Setting this bit masks the interrupt when the rxbroadcastpackets g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxbcgpim(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Multicast Good Packet Counter Interrupt Mask   RXMCGPIM. Setting this bit masks the interrupt when the rxmulticastpackets g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxmcgpim(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<4,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive CRC Error Packet Counter Interrupt Mask   RXCRCERPIM. Setting this bit masks the interrupt when the rxcrcerror counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxcrcerpim(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<5,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Alignment Error Packet Counter Interrupt Mask   RXALGNERPIM. Setting this bit masks the interrupt when the rxalignmenterror counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxalgnerpim(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<6,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Runt Packet Counter Interrupt Mask   RXRUNTPIM. Setting this bit masks the interrupt when the rxrunterror counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxruntpim(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<7,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Jabber Error Packet Counter Interrupt Mask   RXJABERPIM. Setting this bit masks the interrupt when the rxjabbererror counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxjaberpim(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<8,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Undersize Good Packet Counter Interrupt Mask   RXUSIZEGPIM. Setting this bit masks the interrupt when the rxundersize g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxusizegpim(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<9,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Oversize Good Packet Counter Interrupt Mask   RXOSIZEGPIM. Setting this bit masks the interrupt when the rxoversize g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxosizegpim(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<10,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive 64 Octet Good Bad Packet Counter Interrupt Mask   RX64OCTGBPIM. Setting this bit masks the interrupt when the rx64octets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx64octgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<11,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive 65 to 127 Octet Good Bad Packet Counter Interrupt Mask   RX65T127OCTGBPIM. Setting this bit masks the interrupt when the rx65to127octets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx65t127octgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<12,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive 128 to 255 Octet Good Bad Packet Counter Interrupt Mask   RX128T255OCTGBPIM. Setting this bit masks the interrupt when the rx128to255octets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx128t255octgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<13,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive 256 to 511 Octet Good Bad Packet Counter Interrupt Mask   RX256T511OCTGBPIM. Setting this bit masks the interrupt when the rx256to511octets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx256t511octgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<14,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive 512 to 1023 Octet Good Bad Packet Counter Interrupt Mask   RX512T1023OCTGBPIM. Setting this bit masks the interrupt when the rx512to1023octets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx512t1023octgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<15, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<15,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive 1024 to Maximum Octet Good Bad Packet Counter Interrupt Mask.   RX1024TMAXOCTGBPIM. Setting this bit masks the interrupt when the rx1024tomaxoctets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx1024tmaxoctgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<16,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Unicast Good Packet Counter Interrupt Mask   RXUCGPIM. Setting this bit masks the interrupt when the rxunicastpackets g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxucgpim(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<17,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Length Error Packet Counter Interrupt Mask   RXLENERPIM. Setting this bit masks the interrupt when the rxlengtherror counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxlenerpim(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<18,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Out Of Range Error Packet Counter Interrupt Mask   RXORANGEPIM. Setting this bit masks the interrupt when the rxoutofrangetype counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxorangepim(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<19,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Pause Packet Counter Interrupt Mask   RXPAUSPIM. Setting this bit masks the interrupt when the rxpausepackets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxpauspim(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<20,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive FIFO Overflow Packet Counter Interrupt Mask   RXFOVPIM. Setting this bit masks the interrupt when the rxfifooverflow counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxfovpim(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<21,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive VLAN Good Bad Packet Counter Interrupt Mask   RXVLANGBPIM. Setting this bit masks the interrupt when the rxvlanpackets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxvlangbpim(
        self,
    ) -> crate::common::RegisterFieldBool<22, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<22,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Watchdog Error Packet Counter Interrupt Mask   RXWDOGPIM. Setting this bit masks the interrupt when the rxwatchdog counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxwdogpim(
        self,
    ) -> crate::common::RegisterFieldBool<23, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<23,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Error Packet Counter Interrupt Mask   RXRCVERRPIM. Setting this bit masks the interrupt when the rxrcverror counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxrcverrpim(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<24,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive Control Packet Counter Interrupt Mask   RXCTRLPIM. Setting this bit masks the interrupt when the rxctrlpackets g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxctrlpim(
        self,
    ) -> crate::common::RegisterFieldBool<25, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<25,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive LPI microsecond counter interrupt Mask   RXLPIUSCIM. Setting this bit masks the interrupt when the Rx LPI USEC Cntr counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxlpiuscim(
        self,
    ) -> crate::common::RegisterFieldBool<26, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<26,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Receive LPI transition counter interrupt Mask   RXLPITRCIM. Setting this bit masks the interrupt when the Rx LPI Tran Cntr counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxlpitrcim(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, MmcRxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<27,1,0,MmcRxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MmcRxInterruptMask {
    #[inline(always)]
    fn default() -> MmcRxInterruptMask {
        <crate::RegValueT<MmcRxInterruptMask_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MmcTxInterrupt_SPEC;
impl crate::sealed::RegSpec for MmcTxInterrupt_SPEC {
    type DataType = u32;
}
#[doc = "MMC Transmit Interrupts Register\n resetvalue={Application Reset:0x0}"]
pub type MmcTxInterrupt = crate::RegValueT<MmcTxInterrupt_SPEC>;

impl MmcTxInterrupt {
    #[doc = "MMC Transmit Good Bad Octet Counter Interrupt Status   TXGBOCTIS. This bit is set when the txoctetcount gb counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txgboctis(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Good Bad Packet Counter Interrupt Status   TXGBPKTIS. This bit is set when the txpacketcount gb counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txgbpktis(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Broadcast Good Packet Counter Interrupt Status   TXBCGPIS. This bit is set when the txbroadcastpackets g counter reaches half of        the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txbcgpis(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<2,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Multicast Good Packet Counter Interrupt Status   TXMCGPIS. This bit is set when the txmulticastpackets g counter reaches half of        the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txmcgpis(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit 64 Octet Good Bad Packet Counter Interrupt Status   TX64OCTGBPIS. This bit is set when the tx64octets gb counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx64octgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit 65 to 127 Octet Good Bad Packet Counter Interrupt Status   TX65T127OCTGBPIS. This bit is set when the tx65to127octets gb counter reaches half the        maximum value  and also when it reaches the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx65t127octgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit 128 to 255 Octet Good Bad Packet Counter Interrupt Status   TX128T255OCTGBPIS. This bit is set when the tx128to255octets gb counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx128t255octgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<6,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit 256 to 511 Octet Good Bad Packet Counter Interrupt Status   TX256T511OCTGBPIS. This bit is set when the tx256to511octets gb counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx256t511octgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<7,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit 512 to 1023 Octet Good Bad Packet Counter Interrupt Status   TX512T1023OCTGBPIS. This bit is set when the tx512to1023octets gb counter reaches half of        the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx512t1023octgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<8,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit 1024 to Maximum Octet Good Bad Packet Counter Interrupt Status   TX1024TMAXOCTGBPIS. This bit is set when the tx1024tomaxoctets gb counter reaches half of        the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx1024tmaxoctgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<9,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Unicast Good Bad Packet Counter Interrupt Status   TXUCGBPIS. This bit is set when the txunicastpackets gb counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txucgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<10,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Multicast Good Bad Packet Counter Interrupt Status   TXMCGBPIS. The bit is set when the txmulticastpackets gb counter reaches half of        the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txmcgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<11,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Broadcast Good Bad Packet Counter Interrupt Status   TXBCGBPIS. This bit is set when the txbroadcastpackets gb counter reaches half of        the maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txbcgbpis(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<12,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Underflow Error Packet Counter Interrupt Status   TXUFLOWERPIS. This bit is set when the txunderflowerror counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txuflowerpis(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<13,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Single Collision Good Packet Counter Interrupt Status   TXSCOLGPIS. This bit is set when the txsinglecol g counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txscolgpis(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<14,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Multiple Collision Good Packet Counter Interrupt Status   TXMCOLGPIS. This bit is set when the txmulticol g counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txmcolgpis(
        self,
    ) -> crate::common::RegisterFieldBool<15, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<15,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Deferred Packet Counter Interrupt Status   TXDEFPIS. This bit is set when the txdeferred counter reaches half of the maximum        value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txdefpis(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<16,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Late Collision Packet Counter Interrupt Status   TXLATCOLPIS. This bit is set when the txlatecol counter reaches half of the maximum        value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txlatcolpis(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<17,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Excessive Collision Packet Counter Interrupt Status   TXEXCOLPIS. This bit is set when the txexesscol counter reaches half of the maximum        value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txexcolpis(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<18,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Carrier Error Packet Counter Interrupt Status   TXCARERPIS. This bit is set when the txcarriererror counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txcarerpis(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<19,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Good Octet Counter Interrupt Status   TXGOCTIS. This bit is set when the txoctetcount g counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txgoctis(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<20,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Good Packet Counter Interrupt Status   TXGPKTIS. This bit is set when the txpacketcount g counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txgpktis(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<21,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Excessive Deferral Packet Counter Interrupt Status   TXEXDEFPIS. This bit is set when the txexcessdef counter reaches half of the maximum        value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txexdefpis(
        self,
    ) -> crate::common::RegisterFieldBool<22, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<22,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Pause Packet Counter Interrupt Status   TXPAUSPIS. This bit is set when the txpausepacketserror counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txpauspis(
        self,
    ) -> crate::common::RegisterFieldBool<23, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<23,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit VLAN Good Packet Counter Interrupt Status   TXVLANGPIS. This bit is set when the txvlanpackets g counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txvlangpis(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<24,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit Oversize Good Packet Counter Interrupt Status   TXOSIZEGPIS. This bit is set when the txoversize g counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txosizegpis(
        self,
    ) -> crate::common::RegisterFieldBool<25, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<25,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit LPI microsecond counter interrupt status   TXLPIUSCIS. This bit is set when the Tx LPI USEC Cntr counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txlpiuscis(
        self,
    ) -> crate::common::RegisterFieldBool<26, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<26,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MMC Transmit LPI transition counter interrupt status   TXLPITRCIS. This bit is set when the Tx LPI Tran Cntr counter reaches half of the        maximum value or the maximum value. Access restriction applies. Clears on read. Self set to 1 on internal        event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txlpitrcis(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, MmcTxInterrupt_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<27,1,0,MmcTxInterrupt_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MmcTxInterrupt {
    #[inline(always)]
    fn default() -> MmcTxInterrupt {
        <crate::RegValueT<MmcTxInterrupt_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MmcTxInterruptMask_SPEC;
impl crate::sealed::RegSpec for MmcTxInterruptMask_SPEC {
    type DataType = u32;
}
#[doc = "MMC Transmit Interrupts Mask Register\n resetvalue={Application Reset:0x0}"]
pub type MmcTxInterruptMask = crate::RegValueT<MmcTxInterruptMask_SPEC>;

impl MmcTxInterruptMask {
    #[doc = "MMC Transmit Good Bad Octet Counter Interrupt Mask   TXGBOCTIM. Setting this bit masks the interrupt when the txoctetcount gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txgboctim(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<0,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Good Bad Packet Counter Interrupt Mask   TXGBPKTIM. Setting this bit masks the interrupt when the txpacketcount gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txgbpktim(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Broadcast Good Packet Counter Interrupt Mask   TXBCGPIM. Setting this bit masks the interrupt when the txbroadcastpackets g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txbcgpim(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<2,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Multicast Good Packet Counter Interrupt Mask   TXMCGPIM. Setting this bit masks the interrupt when the txmulticastpackets g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txmcgpim(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit 64 Octet Good Bad Packet Counter Interrupt Mask   TX64OCTGBPIM. Setting this bit masks the interrupt when the tx64octets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx64octgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<4,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit 65 to 127 Octet Good Bad Packet Counter Interrupt Mask   TX65T127OCTGBPIM. Setting this bit masks the interrupt when the tx65to127octets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx65t127octgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<5,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit 128 to 255 Octet Good Bad Packet Counter Interrupt Mask   TX128T255OCTGBPIM. Setting this bit masks the interrupt when the tx128to255octets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx128t255octgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<6,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit 256 to 511 Octet Good Bad Packet Counter Interrupt Mask   TX256T511OCTGBPIM. Setting this bit masks the interrupt when the tx256to511octets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx256t511octgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<7,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit 512 to 1023 Octet Good Bad Packet Counter Interrupt Mask   TX512T1023OCTGBPIM. Setting this bit masks the interrupt when the tx512to1023octets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx512t1023octgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<8,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit 1024 to Maximum Octet Good Bad Packet Counter Interrupt Mask   TX1024TMAXOCTGBPIM. Setting this bit masks the interrupt when the tx1024tomaxoctets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx1024tmaxoctgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<9,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Unicast Good Bad Packet Counter Interrupt Mask   TXUCGBPIM. Setting this bit masks the interrupt when the txunicastpackets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txucgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<10, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<10,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Multicast Good Bad Packet Counter Interrupt Mask   TXMCGBPIM. Setting this bit masks the interrupt when the txmulticastpackets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txmcgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<11,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Broadcast Good Bad Packet Counter Interrupt Mask   TXBCGBPIM. Setting this bit masks the interrupt when the txbroadcastpackets gb counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txbcgbpim(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<12,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Underflow Error Packet Counter Interrupt Mask   TXUFLOWERPIM. Setting this bit masks the interrupt when the txunderflowerror counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txuflowerpim(
        self,
    ) -> crate::common::RegisterFieldBool<13, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<13,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Single Collision Good Packet Counter Interrupt Mask   TXSCOLGPIM. Setting this bit masks the interrupt when the txsinglecol g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txscolgpim(
        self,
    ) -> crate::common::RegisterFieldBool<14, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<14,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Multiple Collision Good Packet Counter Interrupt Mask   TXMCOLGPIM. Setting this bit masks the interrupt when the txmulticol g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txmcolgpim(
        self,
    ) -> crate::common::RegisterFieldBool<15, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<15,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Deferred Packet Counter Interrupt Mask   TXDEFPIM. Setting this bit masks the interrupt when the txdeferred counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txdefpim(
        self,
    ) -> crate::common::RegisterFieldBool<16, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<16,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Late Collision Packet Counter Interrupt Mask   TXLATCOLPIM. Setting this bit masks the interrupt when the txlatecol counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txlatcolpim(
        self,
    ) -> crate::common::RegisterFieldBool<17, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<17,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Excessive Collision Packet Counter Interrupt Mask   TXEXCOLPIM. Setting this bit masks the interrupt when the txexcesscol counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txexcolpim(
        self,
    ) -> crate::common::RegisterFieldBool<18, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<18,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Carrier Error Packet Counter Interrupt Mask   TXCARERPIM. Setting this bit masks the interrupt when the txcarriererror counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txcarerpim(
        self,
    ) -> crate::common::RegisterFieldBool<19, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<19,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Good Octet Counter Interrupt Mask   TXGOCTIM. Setting this bit masks the interrupt when the txoctetcount g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txgoctim(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<20,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Good Packet Counter Interrupt Mask   TXGPKTIM. Setting this bit masks the interrupt when the txpacketcount g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txgpktim(
        self,
    ) -> crate::common::RegisterFieldBool<21, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<21,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Excessive Deferral Packet Counter Interrupt Mask   TXEXDEFPIM. Setting this bit masks the interrupt when the txexcessdef counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txexdefpim(
        self,
    ) -> crate::common::RegisterFieldBool<22, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<22,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Pause Packet Counter Interrupt Mask   TXPAUSPIM. Setting this bit masks the interrupt when the txpausepackets counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txpauspim(
        self,
    ) -> crate::common::RegisterFieldBool<23, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<23,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit VLAN Good Packet Counter Interrupt Mask   TXVLANGPIM. Setting this bit masks the interrupt when the txvlanpackets g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txvlangpim(
        self,
    ) -> crate::common::RegisterFieldBool<24, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<24,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit Oversize Good Packet Counter Interrupt Mask   TXOSIZEGPIM. Setting this bit masks the interrupt when the txoversize g counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txosizegpim(
        self,
    ) -> crate::common::RegisterFieldBool<25, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<25,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit LPI microsecond counter interrupt Mask   TXLPIUSCIM. Setting this bit masks the interrupt when the Tx LPI USEC Cntr counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txlpiuscim(
        self,
    ) -> crate::common::RegisterFieldBool<26, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<26,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "MMC Transmit LPI transition counter interrupt Mask   TXLPITRCIM. Setting this bit masks the interrupt when the Tx LPI Tran Cntr counter reaches half of the maximum value or the maximum value. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txlpitrcim(
        self,
    ) -> crate::common::RegisterFieldBool<27, 1, 0, MmcTxInterruptMask_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<27,1,0,MmcTxInterruptMask_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MmcTxInterruptMask {
    #[inline(always)]
    fn default() -> MmcTxInterruptMask {
        <crate::RegValueT<MmcTxInterruptMask_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlInterruptStatus_SPEC;
impl crate::sealed::RegSpec for MtlInterruptStatus_SPEC {
    type DataType = u32;
}
#[doc = "MTL Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
pub type MtlInterruptStatus = crate::RegValueT<MtlInterruptStatus_SPEC>;

impl MtlInterruptStatus {
    #[doc = "Queue 0 Interrupt status   Q0IS. This bit indicates that there is an interrupt from Queue 0. To reset this bit  the application must read Queue 0 Interrupt Control and Status register to get the exact cause of the interrupt and clear its source. Value After Reset  0x0"]
    #[inline(always)]
    pub fn q0is(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MtlInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Queue 1 Interrupt status   Q1IS. This bit indicates that there is an interrupt from Queue 1. To reset this bit  the application must read the MTL Q1 Interrupt Control Status register to get the exact cause of the interrupt and clear its source. Value After Reset  0x0"]
    #[inline(always)]
    pub fn q1is(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MtlInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<1,1,0,MtlInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Queue 2 Interrupt status   Q2IS. This bit indicates that there is an interrupt from Queue 2. To reset this bit  the application must read the MTL Q2 Interrupt Control Status register to get the exact cause of the interrupt and clear its source. Value After Reset  0x0"]
    #[inline(always)]
    pub fn q2is(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MtlInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<2,1,0,MtlInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Queue 3 Interrupt status   Q3IS. This bit indicates that there is an interrupt from Queue 3. To reset this bit  the application must read the MTL Q3 Interrupt Control Status register to get the exact cause of the interrupt and clear its source. Value After Reset  0x0"]
    #[inline(always)]
    pub fn q3is(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlInterruptStatus_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MtlInterruptStatus_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MtlInterruptStatus {
    #[inline(always)]
    fn default() -> MtlInterruptStatus {
        <crate::RegValueT<MtlInterruptStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlOperationMode_SPEC;
impl crate::sealed::RegSpec for MtlOperationMode_SPEC {
    type DataType = u32;
}
#[doc = "MTL Operation Mode Register\n resetvalue={Application Reset:0x0}"]
pub type MtlOperationMode = crate::RegValueT<MtlOperationMode_SPEC>;

impl MtlOperationMode {
    #[doc = "Drop Transmit Status   DTXSTS. When this bit is set  the Tx packet status received from the MAC is dropped in the MTL. When this bit is reset  the Tx packet status received from the MAC is forwarded to the application. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dtxsts(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MtlOperationMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<1,1,0,MtlOperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Arbitration Algorithm   RAA. This field is used to select the arbitration algorithm for the Rx side. Queue 0 has the lowest priority and the last queue has the highest priority. Value After Reset  0x0"]
    #[inline(always)]
    pub fn raa(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MtlOperationMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<2,1,0,MtlOperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Tx Scheduling Algorithm   SCHALG. This field indicates the algorithm for Tx scheduling  Value After Reset  0x0"]
    #[inline(always)]
    pub fn schalg(
        self,
    ) -> crate::common::RegisterField<5, 0x3, 1, 0, u8, MtlOperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<5,0x3,1,0,u8, MtlOperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Counters Preset   CNTPRST. When this bit is set  MTL TxQ 0 7  Underflow register is initialized preset to 12 h7F0. Missed Packet and Overflow Packet counters in MTL RxQ 0 7  Missed Packet Overflow Cnt register is initialized preset to 12 h7F0. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cntprst(
        self,
    ) -> crate::common::RegisterFieldBool<8, 1, 0, MtlOperationMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<8,1,0,MtlOperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Counters Reset   CNTCLR. When this bit is set  all counters are reset. This bit is cleared        automatically after 1 clock cycle. If this bit is set along with CNTPRESET bit  CNTPRESET has precedence. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has        no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cntclr(
        self,
    ) -> crate::common::RegisterFieldBool<9, 1, 0, MtlOperationMode_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<9,1,0,MtlOperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MtlOperationMode {
    #[inline(always)]
    fn default() -> MtlOperationMode {
        <crate::RegValueT<MtlOperationMode_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlQ1InterruptControlStatus_SPEC;
impl crate::sealed::RegSpec for MtlQ1InterruptControlStatus_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
pub type MtlQ1InterruptControlStatus = crate::RegValueT<MtlQ1InterruptControlStatus_SPEC>;

impl MtlQ1InterruptControlStatus {
    #[doc = "Transmit Queue Underflow Interrupt Status   TXUNFIS. This bit indicates that the Transmit Queue had an underflow while transmitting the packet. Transmission is suspended and an Underflow Error TDES3 2  is set. This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txunfis(
        self,
    ) -> crate::common::RegisterFieldBool<
        0,
        1,
        0,
        MtlQ1InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            0,
            1,
            0,
            MtlQ1InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Average Bits Per Slot Interrupt Status   ABPSIS. When set  this bit indicates that the MAC has updated the ABS value. This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn abpsis(
        self,
    ) -> crate::common::RegisterFieldBool<
        1,
        1,
        0,
        MtlQ1InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            1,
            1,
            0,
            MtlQ1InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Transmit Queue Underflow Interrupt Enable   TXUIE. When this bit is set  the Transmit Queue Underflow interrupt is enabled. When this bit is reset  the Transmit Queue Underflow interrupt is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txuie(
        self,
    ) -> crate::common::RegisterFieldBool<
        8,
        1,
        0,
        MtlQ1InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            8,
            1,
            0,
            MtlQ1InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Average Bits Per Slot Interrupt Enable   ABPSIE. When this bit is set  the MAC asserts the sbd intr o or mci intr o interrupt when the average bits per slot status is updated. When this bit is cleared  the interrupt is not asserted for such an event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn abpsie(
        self,
    ) -> crate::common::RegisterFieldBool<
        9,
        1,
        0,
        MtlQ1InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            9,
            1,
            0,
            MtlQ1InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Receive Queue Overflow Interrupt Status   RXOVFIS. This bit indicates that the Receive Queue had an overflow while receiving the packet. If a partial packet is transferred to the application  the overflow status is set in RDES3 21 . This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxovfis(
        self,
    ) -> crate::common::RegisterFieldBool<
        16,
        1,
        0,
        MtlQ1InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            16,
            1,
            0,
            MtlQ1InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Receive Queue Overflow Interrupt Enable   RXOIE. When this bit is set  the Receive Queue Overflow interrupt is enabled. When this bit is reset  the Receive Queue Overflow interrupt is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxoie(
        self,
    ) -> crate::common::RegisterFieldBool<
        24,
        1,
        0,
        MtlQ1InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            24,
            1,
            0,
            MtlQ1InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlQ1InterruptControlStatus {
    #[inline(always)]
    fn default() -> MtlQ1InterruptControlStatus {
        <crate::RegValueT<MtlQ1InterruptControlStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlQ2InterruptControlStatus_SPEC;
impl crate::sealed::RegSpec for MtlQ2InterruptControlStatus_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
pub type MtlQ2InterruptControlStatus = crate::RegValueT<MtlQ2InterruptControlStatus_SPEC>;

impl MtlQ2InterruptControlStatus {
    #[doc = "Transmit Queue Underflow Interrupt Status   TXUNFIS. This bit indicates that the Transmit Queue had an underflow while transmitting the packet. Transmission is suspended and an Underflow Error TDES3 2  is set. This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txunfis(
        self,
    ) -> crate::common::RegisterFieldBool<
        0,
        1,
        0,
        MtlQ2InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            0,
            1,
            0,
            MtlQ2InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Average Bits Per Slot Interrupt Status   ABPSIS. When set  this bit indicates that the MAC has updated the ABS value. This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn abpsis(
        self,
    ) -> crate::common::RegisterFieldBool<
        1,
        1,
        0,
        MtlQ2InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            1,
            1,
            0,
            MtlQ2InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Transmit Queue Underflow Interrupt Enable   TXUIE. When this bit is set  the Transmit Queue Underflow interrupt is enabled. When this bit is reset  the Transmit Queue Underflow interrupt is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txuie(
        self,
    ) -> crate::common::RegisterFieldBool<
        8,
        1,
        0,
        MtlQ2InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            8,
            1,
            0,
            MtlQ2InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Average Bits Per Slot Interrupt Enable   ABPSIE. When this bit is set  the MAC asserts the sbd intr o or mci intr o interrupt when the average bits per slot status is updated. When this bit is cleared  the interrupt is not asserted for such an event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn abpsie(
        self,
    ) -> crate::common::RegisterFieldBool<
        9,
        1,
        0,
        MtlQ2InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            9,
            1,
            0,
            MtlQ2InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Receive Queue Overflow Interrupt Status   RXOVFIS. This bit indicates that the Receive Queue had an overflow while receiving the packet. If a partial packet is transferred to the application  the overflow status is set in RDES3 21 . This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxovfis(
        self,
    ) -> crate::common::RegisterFieldBool<
        16,
        1,
        0,
        MtlQ2InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            16,
            1,
            0,
            MtlQ2InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Receive Queue Overflow Interrupt Enable   RXOIE. When this bit is set  the Receive Queue Overflow interrupt is enabled. When this bit is reset  the Receive Queue Overflow interrupt is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxoie(
        self,
    ) -> crate::common::RegisterFieldBool<
        24,
        1,
        0,
        MtlQ2InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            24,
            1,
            0,
            MtlQ2InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlQ2InterruptControlStatus {
    #[inline(always)]
    fn default() -> MtlQ2InterruptControlStatus {
        <crate::RegValueT<MtlQ2InterruptControlStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlQ3InterruptControlStatus_SPEC;
impl crate::sealed::RegSpec for MtlQ3InterruptControlStatus_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Interrupt Status Register\n resetvalue={Application Reset:0x0}"]
pub type MtlQ3InterruptControlStatus = crate::RegValueT<MtlQ3InterruptControlStatus_SPEC>;

impl MtlQ3InterruptControlStatus {
    #[doc = "Transmit Queue Underflow Interrupt Status   TXUNFIS. This bit indicates that the Transmit Queue had an underflow while transmitting the packet. Transmission is suspended and an Underflow Error TDES3 2  is set. This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txunfis(
        self,
    ) -> crate::common::RegisterFieldBool<
        0,
        1,
        0,
        MtlQ3InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            0,
            1,
            0,
            MtlQ3InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Average Bits Per Slot Interrupt Status   ABPSIS. When set  this bit indicates that the MAC has updated the ABS value. This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn abpsis(
        self,
    ) -> crate::common::RegisterFieldBool<
        1,
        1,
        0,
        MtlQ3InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            1,
            1,
            0,
            MtlQ3InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Transmit Queue Underflow Interrupt Enable   TXUIE. When this bit is set  the Transmit Queue Underflow interrupt is enabled. When this bit is reset  the Transmit Queue Underflow interrupt is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txuie(
        self,
    ) -> crate::common::RegisterFieldBool<
        8,
        1,
        0,
        MtlQ3InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            8,
            1,
            0,
            MtlQ3InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Average Bits Per Slot Interrupt Enable   ABPSIE. When this bit is set  the MAC asserts the sbd intr o or mci intr o interrupt when the average bits per slot status is updated. When this bit is cleared  the interrupt is not asserted for such an event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn abpsie(
        self,
    ) -> crate::common::RegisterFieldBool<
        9,
        1,
        0,
        MtlQ3InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            9,
            1,
            0,
            MtlQ3InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Receive Queue Overflow Interrupt Status   RXOVFIS. This bit indicates that the Receive Queue had an overflow while receiving the packet. If a partial packet is transferred to the application  the overflow status is set in RDES3 21 . This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxovfis(
        self,
    ) -> crate::common::RegisterFieldBool<
        16,
        1,
        0,
        MtlQ3InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            16,
            1,
            0,
            MtlQ3InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Receive Queue Overflow Interrupt Enable   RXOIE. When this bit is set  the Receive Queue Overflow interrupt is enabled. When this bit is reset  the Receive Queue Overflow interrupt is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxoie(
        self,
    ) -> crate::common::RegisterFieldBool<
        24,
        1,
        0,
        MtlQ3InterruptControlStatus_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterFieldBool::<
            24,
            1,
            0,
            MtlQ3InterruptControlStatus_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlQ3InterruptControlStatus {
    #[inline(always)]
    fn default() -> MtlQ3InterruptControlStatus {
        <crate::RegValueT<MtlQ3InterruptControlStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq1Control_SPEC;
impl crate::sealed::RegSpec for MtlRxq1Control_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Control Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq1Control = crate::RegValueT<MtlRxq1Control_SPEC>;

impl MtlRxq1Control {
    #[doc = "Receive Queue Weight   RXQ WEGT. This field indicates the weight assigned to the Rx Queue 0. The weight is used as the number of continuous PBL or packets requests  depending on the RXQ FRM ARBIT  allocated to the queue in one arbitration cycle. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxq_wegt(
        self,
    ) -> crate::common::RegisterField<0, 0x7, 1, 0, u8, MtlRxq1Control_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0x7,1,0,u8, MtlRxq1Control_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Queue Packet Arbitration   RXQ FRM ARBIT. When this bit is set  the DWC ether qos drives the packet data to the ARI interface such that the entire packet data of currently selected queue is transmitted before switching to other queue. When this bit is reset  the DWC ether qos drives the packet data to the ARI interface such that the following amount of data of currently selected queue is transmitted before switching to other queue  PBL amount of data  indicated by ari qN pbl i    or Complete data of a packet The status and the timestamp are not a part of the PBL data. Therefore  the DWC ether qos drives the complete status  including timestamp status  during first PBL request for the packet  in store and forward mode  or the last PBL request for the packet  in Threshold mode . Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxq_frm_arbit(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlRxq1Control_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MtlRxq1Control_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MtlRxq1Control {
    #[inline(always)]
    fn default() -> MtlRxq1Control {
        <crate::RegValueT<MtlRxq1Control_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq1Debug_SPEC;
impl crate::sealed::RegSpec for MtlRxq1Debug_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Debug Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq1Debug = crate::RegValueT<MtlRxq1Debug_SPEC>;

impl MtlRxq1Debug {
    #[doc = "MTL Rx Queue Write Controller Active Status   RWCSTS. When high  this bit indicates that the MTL Rx queue Write controller is        active  and it is transferring a received packet to the Rx Queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rwcsts(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlRxq1Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MtlRxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Rx Queue Read Controller State   RRCSTS. This field gives the state of the Rx queue Read controller  Value After Reset  0x0"]
    #[inline(always)]
    pub fn rrcsts(
        self,
    ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, MtlRxq1Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<1,0x3,1,0,u8, MtlRxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Rx Queue Fill Level Status   RXQSTS. This field gives the status of the fill level of the Rx Queue  Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxqsts(
        self,
    ) -> crate::common::RegisterField<4, 0x3, 1, 0, u8, MtlRxq1Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<4,0x3,1,0,u8, MtlRxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of Packets in Receive Queue   PRXQ. This field indicates the current number of packets in the Rx Queue. The theoretical maximum value for this field is 256KB 16B   16K Packets  that is  Max Queue Size Min Packet Size. Value After Reset  0x0"]
    #[inline(always)]
    pub fn prxq(
        self,
    ) -> crate::common::RegisterField<16, 0x3fff, 1, 0, u16, MtlRxq1Debug_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<16,0x3fff,1,0,u16, MtlRxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MtlRxq1Debug {
    #[inline(always)]
    fn default() -> MtlRxq1Debug {
        <crate::RegValueT<MtlRxq1Debug_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq1MissedPacketOverflowCnt_SPEC;
impl crate::sealed::RegSpec for MtlRxq1MissedPacketOverflowCnt_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Missed Packet and Overflow Counter Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq1MissedPacketOverflowCnt = crate::RegValueT<MtlRxq1MissedPacketOverflowCnt_SPEC>;

impl MtlRxq1MissedPacketOverflowCnt {
    #[doc = "Overflow Packet Counter   OVFPKTCNT. This field indicates the number of packets discarded by the DWC ether qos because of Receive queue overflow. This counter is incremented each time the DWC ether qos discards an incoming packet because of overflow. This counter is reset when this register is read with mci be i 0  at 1 b1. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ovfpktcnt(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x7ff,
        1,
        0,
        u16,
        MtlRxq1MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0x7ff,
            1,
            0,
            u16,
            MtlRxq1MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Overflow Counter Overflow Bit   OVFCNTOVF. When set  this bit indicates that the Rx Queue Overflow Packet Counter field crossed the maximum limit. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ovfcntovf(
        self,
    ) -> crate::common::RegisterFieldBool<
        11,
        1,
        0,
        MtlRxq1MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterFieldBool::<
            11,
            1,
            0,
            MtlRxq1MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Missed Packet Counter   MISPKTCNT. This field indicates the number of packets missed by the DWC ether qos because the application asserted ari pkt flush i   for this queue. This counter is reset when this register is read with mci be i 0  at 1b1. This counter is incremented by 1 when the DMA discards the packet because of buffer unavailability. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mispktcnt(
        self,
    ) -> crate::common::RegisterField<
        16,
        0x7ff,
        1,
        0,
        u16,
        MtlRxq1MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            16,
            0x7ff,
            1,
            0,
            u16,
            MtlRxq1MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Missed Packet Counter Overflow Bit   MISCNTOVF. When set  this bit indicates that the Rx Queue Missed Packet Counter crossed the maximum limit. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn miscntovf(
        self,
    ) -> crate::common::RegisterFieldBool<
        27,
        1,
        0,
        MtlRxq1MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterFieldBool::<
            27,
            1,
            0,
            MtlRxq1MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlRxq1MissedPacketOverflowCnt {
    #[inline(always)]
    fn default() -> MtlRxq1MissedPacketOverflowCnt {
        <crate::RegValueT<MtlRxq1MissedPacketOverflowCnt_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq1OperationMode_SPEC;
impl crate::sealed::RegSpec for MtlRxq1OperationMode_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Operation Mode Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq1OperationMode = crate::RegValueT<MtlRxq1OperationMode_SPEC>;

impl MtlRxq1OperationMode {
    #[doc = "Receive Queue Threshold Control   RTC. These bits control the threshold level of the MTL Rx queue  in bytes   The received packet is transferred to the application or DMA when the packet size within the MTL Rx queue is larger than the threshold. In addition  full packets with length less than the threshold are automatically transferred. This field is valid only when the RSF bit is zero. This field is ignored when the RSF bit is set to 1. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rtc(
        self,
    ) -> crate::common::RegisterField<0, 0x3, 1, 0, u8, MtlRxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0x3,1,0,u8, MtlRxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Forward Undersized Good Packets   FUP. When this bit is set  the Rx queue forwards the undersized good packets  packets with no error and length less than 64 bytes   including pad bytes and CRC. When this bit is reset  the Rx queue drops all packets of less than 64 bytes  unless a packet is already transferred because of the lower value of Rx Threshold  for example  RTC   01. Value After Reset  0x0"]
    #[inline(always)]
    pub fn fup(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlRxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<3,1,0,MtlRxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Forward Error Packets   FEP. When this bit is reset  the Rx queue drops packets with error status  CRC error  GMII ER  watchdog timeout  or overflow . However  if the start byte  write  pointer of a packet is already transferred to the read controller side  in Threshold mode   the packet is not dropped. When this bit is set  all packets except the runt error packets are forwarded to the application or DMA. If the RSF bit is set and the Rx queue overflows when a partial packet is written  the packet is dropped irrespective of the setting of this bit. However  if the RSF bit is reset and the Rx queue overflows when a partial packet is written  a partial packet may be forwarded to the application or DMA. Value After Reset  0x0"]
    #[inline(always)]
    pub fn fep(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MtlRxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<4,1,0,MtlRxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Queue Store and Forward   RSF. When this bit is set  the DWC ether qos reads a packet from the Rx queue only after the complete packet has been written to it  ignoring the RTC field of this register. When this bit is reset  the Rx queue operates in the Threshold  cut through  mode  subject to the threshold specified by the RTC field of this register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rsf(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MtlRxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<5,1,0,MtlRxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Disable Dropping of TCP IP Checksum Error Packets   DIS TCP EF. When this bit is set  the MAC does not drop the packets which only have the errors detected by the Receive Checksum Offload engine. Such packets have errors only in the encapsulated payload. There are no errors  including FCS error  in the Ethernet packet received by the MAC. When this bit is reset  all error packets are dropped if the FEP bit is reset. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dis_tcp_ef(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MtlRxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<6,1,0,MtlRxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Hardware Flow Control   EHFC. When this bit is set  the flow control signal operation  based on the fill level of Rx queue  is enabled. When reset  the flow control operation is disabled. This bit is not used  reserved and always reset  when the Rx queue is less than 4 KB. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ehfc(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MtlRxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<7,1,0,MtlRxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Threshold for Activating Flow Control  in half duplex and full duplex   RFA. These bits control the threshold  fill level of Rx queue  at which the flow control is activated  For more information on encoding for this field  see RFD. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rfa(
        self,
    ) -> crate::common::RegisterField<8, 0xf, 1, 0, u8, MtlRxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<8,0xf,1,0,u8, MtlRxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Threshold for Deactivating Flow Control  in half duplex and full duplex modes    RFD. These bits control the threshold  fill level of Rx queue  at which the flow control is de asserted after activation  LOST SEQUENCE DEFINITION The de assertion is effective only after flow control is asserted. Note  The value must be programmed in such a way to make sure that the threshold is a positive number. When the EHFC is set high  these values are applicable only when the Rx queue size determined by the RQS field of this register  is equal to or greater than 4 KB. For a given queue size  the values ranges between 0 and the encoding for FULL minus  QSIZE   0.5 KB  and all other values are illegal. Here the term FULL and QSIZE refers to the queue size determined by the RQS field of this register. The width of this field depends on RX FIFO size selected during the configuration. Remaining bits are reserved and read only. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rfd(
        self,
    ) -> crate::common::RegisterField<14, 0xf, 1, 0, u8, MtlRxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<
            14,
            0xf,
            1,
            0,
            u8,
            MtlRxq1OperationMode_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Receive Queue Size   RQS. This field indicates the size of the allocated Receive queues in blocks        of 256 bytes. The RQS field is read write only if the number of Rx        Queues more than one and the reset value is 0x0 and indicates size of        256 bytes. When the number of Rx Queues is one  the field is read only and the        configured RX FIFO size in blocks of 256 bytes is reflected in the reset        value. The width of this field depends on the Rx memory size selected in your        configuration. For example  if the memory size is 2048  the width of        this field is 3 bits  LOG2 2048 256    LOG2 8    3 bits Value After Reset  0x0"]
    #[inline(always)]
    pub fn rqs(
        self,
    ) -> crate::common::RegisterField<
        20,
        0x1f,
        1,
        0,
        u8,
        MtlRxq1OperationMode_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            20,
            0x1f,
            1,
            0,
            u8,
            MtlRxq1OperationMode_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlRxq1OperationMode {
    #[inline(always)]
    fn default() -> MtlRxq1OperationMode {
        <crate::RegValueT<MtlRxq1OperationMode_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq2Control_SPEC;
impl crate::sealed::RegSpec for MtlRxq2Control_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Control Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq2Control = crate::RegValueT<MtlRxq2Control_SPEC>;

impl MtlRxq2Control {
    #[doc = "Receive Queue Weight   RXQ WEGT. This field indicates the weight assigned to the Rx Queue 0. The weight is used as the number of continuous PBL or packets requests  depending on the RXQ FRM ARBIT  allocated to the queue in one arbitration cycle. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxq_wegt(
        self,
    ) -> crate::common::RegisterField<0, 0x7, 1, 0, u8, MtlRxq2Control_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0x7,1,0,u8, MtlRxq2Control_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Queue Packet Arbitration   RXQ FRM ARBIT. When this bit is set  the DWC ether qos drives the packet data to the ARI interface such that the entire packet data of currently selected queue is transmitted before switching to other queue. When this bit is reset  the DWC ether qos drives the packet data to the ARI interface such that the following amount of data of currently selected queue is transmitted before switching to other queue  PBL amount of data  indicated by ari qN pbl i    or Complete data of a packet The status and the timestamp are not a part of the PBL data. Therefore  the DWC ether qos drives the complete status  including timestamp status  during first PBL request for the packet  in store and forward mode  or the last PBL request for the packet  in Threshold mode . Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxq_frm_arbit(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlRxq2Control_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MtlRxq2Control_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MtlRxq2Control {
    #[inline(always)]
    fn default() -> MtlRxq2Control {
        <crate::RegValueT<MtlRxq2Control_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq2Debug_SPEC;
impl crate::sealed::RegSpec for MtlRxq2Debug_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Debug Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq2Debug = crate::RegValueT<MtlRxq2Debug_SPEC>;

impl MtlRxq2Debug {
    #[doc = "MTL Rx Queue Write Controller Active Status   RWCSTS. When high  this bit indicates that the MTL Rx queue Write controller is        active  and it is transferring a received packet to the Rx Queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rwcsts(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlRxq2Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MtlRxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Rx Queue Read Controller State   RRCSTS. This field gives the state of the Rx queue Read controller  Value After Reset  0x0"]
    #[inline(always)]
    pub fn rrcsts(
        self,
    ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, MtlRxq2Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<1,0x3,1,0,u8, MtlRxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Rx Queue Fill Level Status   RXQSTS. This field gives the status of the fill level of the Rx Queue  Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxqsts(
        self,
    ) -> crate::common::RegisterField<4, 0x3, 1, 0, u8, MtlRxq2Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<4,0x3,1,0,u8, MtlRxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of Packets in Receive Queue   PRXQ. This field indicates the current number of packets in the Rx Queue. The theoretical maximum value for this field is 256KB 16B   16K Packets  that is  Max Queue Size Min Packet Size. Value After Reset  0x0"]
    #[inline(always)]
    pub fn prxq(
        self,
    ) -> crate::common::RegisterField<16, 0x3fff, 1, 0, u16, MtlRxq2Debug_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<16,0x3fff,1,0,u16, MtlRxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MtlRxq2Debug {
    #[inline(always)]
    fn default() -> MtlRxq2Debug {
        <crate::RegValueT<MtlRxq2Debug_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq2MissedPacketOverflowCnt_SPEC;
impl crate::sealed::RegSpec for MtlRxq2MissedPacketOverflowCnt_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Missed Packet and Overflow Counter Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq2MissedPacketOverflowCnt = crate::RegValueT<MtlRxq2MissedPacketOverflowCnt_SPEC>;

impl MtlRxq2MissedPacketOverflowCnt {
    #[doc = "Overflow Packet Counter   OVFPKTCNT. This field indicates the number of packets discarded by the DWC ether qos because of Receive queue overflow. This counter is incremented each time the DWC ether qos discards an incoming packet because of overflow. This counter is reset when this register is read with mci be i 0  at 1 b1. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ovfpktcnt(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x7ff,
        1,
        0,
        u16,
        MtlRxq2MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0x7ff,
            1,
            0,
            u16,
            MtlRxq2MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Overflow Counter Overflow Bit   OVFCNTOVF. When set  this bit indicates that the Rx Queue Overflow Packet Counter field crossed the maximum limit. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ovfcntovf(
        self,
    ) -> crate::common::RegisterFieldBool<
        11,
        1,
        0,
        MtlRxq2MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterFieldBool::<
            11,
            1,
            0,
            MtlRxq2MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Missed Packet Counter   MISPKTCNT. This field indicates the number of packets missed by the DWC ether qos because the application asserted ari pkt flush i   for this queue. This counter is reset when this register is read with mci be i 0  at 1b1. This counter is incremented by 1 when the DMA discards the packet because of buffer unavailability. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mispktcnt(
        self,
    ) -> crate::common::RegisterField<
        16,
        0x7ff,
        1,
        0,
        u16,
        MtlRxq2MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            16,
            0x7ff,
            1,
            0,
            u16,
            MtlRxq2MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Missed Packet Counter Overflow Bit   MISCNTOVF. When set  this bit indicates that the Rx Queue Missed Packet Counter crossed the maximum limit. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn miscntovf(
        self,
    ) -> crate::common::RegisterFieldBool<
        27,
        1,
        0,
        MtlRxq2MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterFieldBool::<
            27,
            1,
            0,
            MtlRxq2MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlRxq2MissedPacketOverflowCnt {
    #[inline(always)]
    fn default() -> MtlRxq2MissedPacketOverflowCnt {
        <crate::RegValueT<MtlRxq2MissedPacketOverflowCnt_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq2OperationMode_SPEC;
impl crate::sealed::RegSpec for MtlRxq2OperationMode_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Operation Mode Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq2OperationMode = crate::RegValueT<MtlRxq2OperationMode_SPEC>;

impl MtlRxq2OperationMode {
    #[doc = "Receive Queue Threshold Control   RTC. These bits control the threshold level of the MTL Rx queue  in bytes   The received packet is transferred to the application or DMA when the packet size within the MTL Rx queue is larger than the threshold. In addition  full packets with length less than the threshold are automatically transferred. This field is valid only when the RSF bit is zero. This field is ignored when the RSF bit is set to 1. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rtc(
        self,
    ) -> crate::common::RegisterField<0, 0x3, 1, 0, u8, MtlRxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0x3,1,0,u8, MtlRxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Forward Undersized Good Packets   FUP. When this bit is set  the Rx queue forwards the undersized good packets  packets with no error and length less than 64 bytes   including pad bytes and CRC. When this bit is reset  the Rx queue drops all packets of less than 64 bytes  unless a packet is already transferred because of the lower value of Rx Threshold  for example  RTC   01. Value After Reset  0x0"]
    #[inline(always)]
    pub fn fup(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlRxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<3,1,0,MtlRxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Forward Error Packets   FEP. When this bit is reset  the Rx queue drops packets with error status  CRC error  GMII ER  watchdog timeout  or overflow . However  if the start byte  write  pointer of a packet is already transferred to the read controller side  in Threshold mode   the packet is not dropped. When this bit is set  all packets except the runt error packets are forwarded to the application or DMA. If the RSF bit is set and the Rx queue overflows when a partial packet is written  the packet is dropped irrespective of the setting of this bit. However  if the RSF bit is reset and the Rx queue overflows when a partial packet is written  a partial packet may be forwarded to the application or DMA. Value After Reset  0x0"]
    #[inline(always)]
    pub fn fep(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MtlRxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<4,1,0,MtlRxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Queue Store and Forward   RSF. When this bit is set  the DWC ether qos reads a packet from the Rx queue only after the complete packet has been written to it  ignoring the RTC field of this register. When this bit is reset  the Rx queue operates in the Threshold  cut through  mode  subject to the threshold specified by the RTC field of this register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rsf(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MtlRxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<5,1,0,MtlRxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Disable Dropping of TCP IP Checksum Error Packets   DIS TCP EF. When this bit is set  the MAC does not drop the packets which only have the errors detected by the Receive Checksum Offload engine. Such packets have errors only in the encapsulated payload. There are no errors  including FCS error  in the Ethernet packet received by the MAC. When this bit is reset  all error packets are dropped if the FEP bit is reset. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dis_tcp_ef(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MtlRxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<6,1,0,MtlRxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Hardware Flow Control   EHFC. When this bit is set  the flow control signal operation  based on the fill level of Rx queue  is enabled. When reset  the flow control operation is disabled. This bit is not used  reserved and always reset  when the Rx queue is less than 4 KB. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ehfc(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MtlRxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<7,1,0,MtlRxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Threshold for Activating Flow Control  in half duplex and full duplex   RFA. These bits control the threshold  fill level of Rx queue  at which the flow control is activated  For more information on encoding for this field  see RFD. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rfa(
        self,
    ) -> crate::common::RegisterField<8, 0xf, 1, 0, u8, MtlRxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<8,0xf,1,0,u8, MtlRxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Threshold for Deactivating Flow Control  in half duplex and full duplex modes    RFD. These bits control the threshold  fill level of Rx queue  at which the flow control is de asserted after activation  LOST SEQUENCE DEFINITION The de assertion is effective only after flow control is asserted. Note  The value must be programmed in such a way to make sure that the threshold is a positive number. When the EHFC is set high  these values are applicable only when the Rx queue size determined by the RQS field of this register  is equal to or greater than 4 KB. For a given queue size  the values ranges between 0 and the encoding for FULL minus  QSIZE   0.5 KB  and all other values are illegal. Here the term FULL and QSIZE refers to the queue size determined by the RQS field of this register. The width of this field depends on RX FIFO size selected during the configuration. Remaining bits are reserved and read only. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rfd(
        self,
    ) -> crate::common::RegisterField<14, 0xf, 1, 0, u8, MtlRxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<
            14,
            0xf,
            1,
            0,
            u8,
            MtlRxq2OperationMode_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Receive Queue Size   RQS. This field indicates the size of the allocated Receive queues in blocks        of 256 bytes. The RQS field is read write only if the number of Rx        Queues more than one and the reset value is 0x0 and indicates size of        256 bytes. When the number of Rx Queues is one  the field is read only and the        configured RX FIFO size in blocks of 256 bytes is reflected in the reset        value. The width of this field depends on the Rx memory size selected in your        configuration. For example  if the memory size is 2048  the width of        this field is 3 bits  LOG2 2048 256    LOG2 8    3 bits Value After Reset  0x0"]
    #[inline(always)]
    pub fn rqs(
        self,
    ) -> crate::common::RegisterField<
        20,
        0x1f,
        1,
        0,
        u8,
        MtlRxq2OperationMode_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            20,
            0x1f,
            1,
            0,
            u8,
            MtlRxq2OperationMode_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlRxq2OperationMode {
    #[inline(always)]
    fn default() -> MtlRxq2OperationMode {
        <crate::RegValueT<MtlRxq2OperationMode_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq3Control_SPEC;
impl crate::sealed::RegSpec for MtlRxq3Control_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Control Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq3Control = crate::RegValueT<MtlRxq3Control_SPEC>;

impl MtlRxq3Control {
    #[doc = "Receive Queue Weight   RXQ WEGT. This field indicates the weight assigned to the Rx Queue 0. The weight is used as the number of continuous PBL or packets requests  depending on the RXQ FRM ARBIT  allocated to the queue in one arbitration cycle. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxq_wegt(
        self,
    ) -> crate::common::RegisterField<0, 0x7, 1, 0, u8, MtlRxq3Control_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0x7,1,0,u8, MtlRxq3Control_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Queue Packet Arbitration   RXQ FRM ARBIT. When this bit is set  the DWC ether qos drives the packet data to the ARI interface such that the entire packet data of currently selected queue is transmitted before switching to other queue. When this bit is reset  the DWC ether qos drives the packet data to the ARI interface such that the following amount of data of currently selected queue is transmitted before switching to other queue  PBL amount of data  indicated by ari qN pbl i    or Complete data of a packet The status and the timestamp are not a part of the PBL data. Therefore  the DWC ether qos drives the complete status  including timestamp status  during first PBL request for the packet  in store and forward mode  or the last PBL request for the packet  in Threshold mode . Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxq_frm_arbit(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlRxq3Control_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MtlRxq3Control_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MtlRxq3Control {
    #[inline(always)]
    fn default() -> MtlRxq3Control {
        <crate::RegValueT<MtlRxq3Control_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq3Debug_SPEC;
impl crate::sealed::RegSpec for MtlRxq3Debug_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Debug Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq3Debug = crate::RegValueT<MtlRxq3Debug_SPEC>;

impl MtlRxq3Debug {
    #[doc = "MTL Rx Queue Write Controller Active Status   RWCSTS. When high  this bit indicates that the MTL Rx queue Write controller is        active  and it is transferring a received packet to the Rx Queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rwcsts(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlRxq3Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MtlRxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Rx Queue Read Controller State   RRCSTS. This field gives the state of the Rx queue Read controller  Value After Reset  0x0"]
    #[inline(always)]
    pub fn rrcsts(
        self,
    ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, MtlRxq3Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<1,0x3,1,0,u8, MtlRxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Rx Queue Fill Level Status   RXQSTS. This field gives the status of the fill level of the Rx Queue  Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxqsts(
        self,
    ) -> crate::common::RegisterField<4, 0x3, 1, 0, u8, MtlRxq3Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<4,0x3,1,0,u8, MtlRxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of Packets in Receive Queue   PRXQ. This field indicates the current number of packets in the Rx Queue. The theoretical maximum value for this field is 256KB 16B   16K Packets  that is  Max Queue Size Min Packet Size. Value After Reset  0x0"]
    #[inline(always)]
    pub fn prxq(
        self,
    ) -> crate::common::RegisterField<16, 0x3fff, 1, 0, u16, MtlRxq3Debug_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<16,0x3fff,1,0,u16, MtlRxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MtlRxq3Debug {
    #[inline(always)]
    fn default() -> MtlRxq3Debug {
        <crate::RegValueT<MtlRxq3Debug_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq3MissedPacketOverflowCnt_SPEC;
impl crate::sealed::RegSpec for MtlRxq3MissedPacketOverflowCnt_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Missed Packet and Overflow Counter Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq3MissedPacketOverflowCnt = crate::RegValueT<MtlRxq3MissedPacketOverflowCnt_SPEC>;

impl MtlRxq3MissedPacketOverflowCnt {
    #[doc = "Overflow Packet Counter   OVFPKTCNT. This field indicates the number of packets discarded by the DWC ether qos because of Receive queue overflow. This counter is incremented each time the DWC ether qos discards an incoming packet because of overflow. This counter is reset when this register is read with mci be i 0  at 1 b1. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ovfpktcnt(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x7ff,
        1,
        0,
        u16,
        MtlRxq3MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0x7ff,
            1,
            0,
            u16,
            MtlRxq3MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Overflow Counter Overflow Bit   OVFCNTOVF. When set  this bit indicates that the Rx Queue Overflow Packet Counter field crossed the maximum limit. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ovfcntovf(
        self,
    ) -> crate::common::RegisterFieldBool<
        11,
        1,
        0,
        MtlRxq3MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterFieldBool::<
            11,
            1,
            0,
            MtlRxq3MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Missed Packet Counter   MISPKTCNT. This field indicates the number of packets missed by the DWC ether qos because the application asserted ari pkt flush i   for this queue. This counter is reset when this register is read with mci be i 0  at 1b1. This counter is incremented by 1 when the DMA discards the packet because of buffer unavailability. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn mispktcnt(
        self,
    ) -> crate::common::RegisterField<
        16,
        0x7ff,
        1,
        0,
        u16,
        MtlRxq3MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            16,
            0x7ff,
            1,
            0,
            u16,
            MtlRxq3MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
    #[doc = "Missed Packet Counter Overflow Bit   MISCNTOVF. When set  this bit indicates that the Rx Queue Missed Packet Counter crossed the maximum limit. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn miscntovf(
        self,
    ) -> crate::common::RegisterFieldBool<
        27,
        1,
        0,
        MtlRxq3MissedPacketOverflowCnt_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterFieldBool::<
            27,
            1,
            0,
            MtlRxq3MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlRxq3MissedPacketOverflowCnt {
    #[inline(always)]
    fn default() -> MtlRxq3MissedPacketOverflowCnt {
        <crate::RegValueT<MtlRxq3MissedPacketOverflowCnt_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq3OperationMode_SPEC;
impl crate::sealed::RegSpec for MtlRxq3OperationMode_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Receive Operation Mode Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxq3OperationMode = crate::RegValueT<MtlRxq3OperationMode_SPEC>;

impl MtlRxq3OperationMode {
    #[doc = "Receive Queue Threshold Control   RTC. These bits control the threshold level of the MTL Rx queue  in bytes   The received packet is transferred to the application or DMA when the packet size within the MTL Rx queue is larger than the threshold. In addition  full packets with length less than the threshold are automatically transferred. This field is valid only when the RSF bit is zero. This field is ignored when the RSF bit is set to 1. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rtc(
        self,
    ) -> crate::common::RegisterField<0, 0x3, 1, 0, u8, MtlRxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0x3,1,0,u8, MtlRxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Forward Undersized Good Packets   FUP. When this bit is set  the Rx queue forwards the undersized good packets  packets with no error and length less than 64 bytes   including pad bytes and CRC. When this bit is reset  the Rx queue drops all packets of less than 64 bytes  unless a packet is already transferred because of the lower value of Rx Threshold  for example  RTC   01. Value After Reset  0x0"]
    #[inline(always)]
    pub fn fup(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlRxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<3,1,0,MtlRxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Forward Error Packets   FEP. When this bit is reset  the Rx queue drops packets with error status  CRC error  GMII ER  watchdog timeout  or overflow . However  if the start byte  write  pointer of a packet is already transferred to the read controller side  in Threshold mode   the packet is not dropped. When this bit is set  all packets except the runt error packets are forwarded to the application or DMA. If the RSF bit is set and the Rx queue overflows when a partial packet is written  the packet is dropped irrespective of the setting of this bit. However  if the RSF bit is reset and the Rx queue overflows when a partial packet is written  a partial packet may be forwarded to the application or DMA. Value After Reset  0x0"]
    #[inline(always)]
    pub fn fep(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MtlRxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<4,1,0,MtlRxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Receive Queue Store and Forward   RSF. When this bit is set  the DWC ether qos reads a packet from the Rx queue only after the complete packet has been written to it  ignoring the RTC field of this register. When this bit is reset  the Rx queue operates in the Threshold  cut through  mode  subject to the threshold specified by the RTC field of this register. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rsf(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MtlRxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<5,1,0,MtlRxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Disable Dropping of TCP IP Checksum Error Packets   DIS TCP EF. When this bit is set  the MAC does not drop the packets which only have the errors detected by the Receive Checksum Offload engine. Such packets have errors only in the encapsulated payload. There are no errors  including FCS error  in the Ethernet packet received by the MAC. When this bit is reset  all error packets are dropped if the FEP bit is reset. Value After Reset  0x0"]
    #[inline(always)]
    pub fn dis_tcp_ef(
        self,
    ) -> crate::common::RegisterFieldBool<6, 1, 0, MtlRxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<6,1,0,MtlRxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Enable Hardware Flow Control   EHFC. When this bit is set  the flow control signal operation  based on the fill level of Rx queue  is enabled. When reset  the flow control operation is disabled. This bit is not used  reserved and always reset  when the Rx queue is less than 4 KB. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ehfc(
        self,
    ) -> crate::common::RegisterFieldBool<7, 1, 0, MtlRxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<7,1,0,MtlRxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Threshold for Activating Flow Control  in half duplex and full duplex   RFA. These bits control the threshold  fill level of Rx queue  at which the flow control is activated  For more information on encoding for this field  see RFD. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rfa(
        self,
    ) -> crate::common::RegisterField<8, 0xf, 1, 0, u8, MtlRxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<8,0xf,1,0,u8, MtlRxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Threshold for Deactivating Flow Control  in half duplex and full duplex modes    RFD. These bits control the threshold  fill level of Rx queue  at which the flow control is de asserted after activation  LOST SEQUENCE DEFINITION The de assertion is effective only after flow control is asserted. Note  The value must be programmed in such a way to make sure that the threshold is a positive number. When the EHFC is set high  these values are applicable only when the Rx queue size determined by the RQS field of this register  is equal to or greater than 4 KB. For a given queue size  the values ranges between 0 and the encoding for FULL minus  QSIZE   0.5 KB  and all other values are illegal. Here the term FULL and QSIZE refers to the queue size determined by the RQS field of this register. The width of this field depends on RX FIFO size selected during the configuration. Remaining bits are reserved and read only. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rfd(
        self,
    ) -> crate::common::RegisterField<14, 0xf, 1, 0, u8, MtlRxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<
            14,
            0xf,
            1,
            0,
            u8,
            MtlRxq3OperationMode_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
    #[doc = "Receive Queue Size   RQS. This field indicates the size of the allocated Receive queues in blocks        of 256 bytes. The RQS field is read write only if the number of Rx        Queues more than one and the reset value is 0x0 and indicates size of        256 bytes. When the number of Rx Queues is one  the field is read only and the        configured RX FIFO size in blocks of 256 bytes is reflected in the reset        value. The width of this field depends on the Rx memory size selected in your        configuration. For example  if the memory size is 2048  the width of        this field is 3 bits  LOG2 2048 256    LOG2 8    3 bits Value After Reset  0x0"]
    #[inline(always)]
    pub fn rqs(
        self,
    ) -> crate::common::RegisterField<
        20,
        0x1f,
        1,
        0,
        u8,
        MtlRxq3OperationMode_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            20,
            0x1f,
            1,
            0,
            u8,
            MtlRxq3OperationMode_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlRxq3OperationMode {
    #[inline(always)]
    fn default() -> MtlRxq3OperationMode {
        <crate::RegValueT<MtlRxq3OperationMode_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxqDmaMap0_SPEC;
impl crate::sealed::RegSpec for MtlRxqDmaMap0_SPEC {
    type DataType = u32;
}
#[doc = "MTL Receive Queue and DMA Channel Mapping 0 Register\n resetvalue={Application Reset:0x0}"]
pub type MtlRxqDmaMap0 = crate::RegValueT<MtlRxqDmaMap0_SPEC>;

impl MtlRxqDmaMap0 {
    #[doc = "Queue 0 Mapped to DMA Channel   Q0MDMACH. This field controls the routing of the packet received in Queue 0 to the DMA channel  This field is valid when the Q0DDMACH field is reset. The width of this field depends on the number of RX DMA channels and not all the values may be valid in some configurations. For example  if the number of RX DMA channels selected is 2  only 000 and 001 are valid  the other bits are reserved. Value After Reset  0x0"]
    #[inline(always)]
    pub fn q0mdmach(
        self,
    ) -> crate::common::RegisterField<0, 0x3, 1, 0, u8, MtlRxqDmaMap0_SPEC, crate::common::RW> {
        crate::common::RegisterField::<0,0x3,1,0,u8, MtlRxqDmaMap0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Queue 0 Enabled for DA based DMA Channel Selection   Q0DDMACH. When set  this bit indicates that the packets received in Queue 0 are routed to a particular DMA channel as decided in the MAC Receiver based on the DMA channel number programmed in the L3 L4 filter registers  or the Ethernet DA address. When reset  this bit indicates that the packets received in Queue 0 are routed to the DMA Channel programmed in the Q0MDMACH field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn q0ddmach(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MtlRxqDmaMap0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<4,1,0,MtlRxqDmaMap0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Queue 1 Mapped to DMA Channel   Q1MDMACH. This field controls the routing of the received packet in Queue 1 to the DMA channel  This field is valid when the Q1DDMACH field is reset. The width of this field depends on the number of RX DMA channels and not all the values may be valid in some configurations. For example  if the number of RX DMA channels selected is 2  only 000 and 001 are valid  the other bits are reserved. Value After Reset  0x0"]
    #[inline(always)]
    pub fn q1mdmach(
        self,
    ) -> crate::common::RegisterField<8, 0x3, 1, 0, u8, MtlRxqDmaMap0_SPEC, crate::common::RW> {
        crate::common::RegisterField::<8,0x3,1,0,u8, MtlRxqDmaMap0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Queue 1 Enabled for DA based DMA Channel Selection   Q1DDMACH. When set  this bit indicates that the packets received in Queue 1 are routed to a particular DMA channel as decided in the MAC Receiver based on the DMA channel number programmed in the L3 L4 filter registers  or the Ethernet DA address. When reset  this bit indicates that the packets received in Queue 1 are routed to the DMA Channel programmed in the Q1MDMACH field  Bits 10 8  . Value After Reset  0x0"]
    #[inline(always)]
    pub fn q1ddmach(
        self,
    ) -> crate::common::RegisterFieldBool<12, 1, 0, MtlRxqDmaMap0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<12,1,0,MtlRxqDmaMap0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Queue 2 Mapped to DMA Channel   Q2MDMACH. This field controls the routing of the received packet in Queue 2 to the DMA channel  This field is valid when the Q2DDMACH field is reset. Value After Reset  0x0"]
    #[inline(always)]
    pub fn q2mdmach(
        self,
    ) -> crate::common::RegisterField<16, 0x3, 1, 0, u8, MtlRxqDmaMap0_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0x3,1,0,u8, MtlRxqDmaMap0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Queue 2 Enabled for DA based DMA Channel Selection   Q2DDMACH. When set  this bit indicates that the packets received in Queue 2 are routed to a particular DMA channel as decided in the MAC Receiver based on the DMA channel number programmed in the L3 L4 filter registers  or the Ethernet DA address. When reset  this bit indicates that the packets received in Queue 2 are routed to the DMA Channel programmed in the Q2MDMACH field  Bits 18 16  . Value After Reset  0x0"]
    #[inline(always)]
    pub fn q2ddmach(
        self,
    ) -> crate::common::RegisterFieldBool<20, 1, 0, MtlRxqDmaMap0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<20,1,0,MtlRxqDmaMap0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Queue 3 Mapped to DMA Channel   Q3MDMACH. This field controls the routing of the received packet in Queue 3 to the DMA channel  This field is valid when the Q3DDMACH field is reset. The width of this field depends on the number of RX DMA channels and not all the values may be valid in some configurations. For example  if the number of RX DMA channels selected is 2  only 000 and 001 are valid  the others are reserved Value After Reset  0x0"]
    #[inline(always)]
    pub fn q3mdmach(
        self,
    ) -> crate::common::RegisterField<24, 0x3, 1, 0, u8, MtlRxqDmaMap0_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0x3,1,0,u8, MtlRxqDmaMap0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Queue 3 Enabled for Dynamic  per packet  DMA Channel Selection   Q3DDMACH. When set  this bit indicates that the packets received in Queue 3 are routed to a particular DMA channel as decided in the MAC Receiver based on the DMA channel number programmed in the L3 L4 filter registers  or the Ethernet DA address. When reset  this bit indicates that the packets received in Queue 3 are routed to the DMA Channel programmed in the Q3MDMACH field  Bits 26 24  . Value After Reset  0x0"]
    #[inline(always)]
    pub fn q3ddmach(
        self,
    ) -> crate::common::RegisterFieldBool<28, 1, 0, MtlRxqDmaMap0_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<28,1,0,MtlRxqDmaMap0_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MtlRxqDmaMap0 {
    #[inline(always)]
    fn default() -> MtlRxqDmaMap0 {
        <crate::RegValueT<MtlRxqDmaMap0_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq1Debug_SPEC;
impl crate::sealed::RegSpec for MtlTxq1Debug_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Debug Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq1Debug = crate::RegValueT<MtlTxq1Debug_SPEC>;

impl MtlTxq1Debug {
    #[doc = "Transmit Queue in Pause   TXQPAUSED. When this bit is high and the Rx flow control is enabled  it indicates that the Tx Queue is in the Pause condition  in the full duplex only mode  because of the following  Reception of the PFC packet for the priorities assigned to the Tx Queue when PFC is enabled Reception of 802.3x Pause packet when PFC is disabled Value After Reset  0x0"]
    #[inline(always)]
    pub fn txqpaused(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlTxq1Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MtlTxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Queue Read Controller Status   TRCSTS. This field indicates the state of the Tx Queue Read Controller  Value After Reset  0x0"]
    #[inline(always)]
    pub fn trcsts(
        self,
    ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, MtlTxq1Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<1,0x3,1,0,u8, MtlTxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Queue Write Controller Status   TWCSTS. When high  this bit indicates that the MTL Tx Queue Write Controller is active  and it is transferring the data to the Tx Queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn twcsts(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlTxq1Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MtlTxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Queue Not Empty Status   TXQSTS. When this bit is high  it indicates that the MTL Tx Queue is not empty and some data is left for transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txqsts(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MtlTxq1Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MtlTxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Status FIFO Full Status   TXSTSFSTS. When high  this bit indicates that the MTL Tx Status FIFO is full. Therefore  the MTL cannot accept any more packets for transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txstsfsts(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MtlTxq1Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MtlTxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of Packets in the Transmit Queue   PTXQ. This field indicates the current number of packets in the Tx Queue. When the DTXSTS bit of MTL Operation Mode register is set to 1  this field does not reflect the number of packets in the Transmit queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ptxq(
        self,
    ) -> crate::common::RegisterField<16, 0x7, 1, 0, u8, MtlTxq1Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<16,0x7,1,0,u8, MtlTxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of Status Words in Tx Status FIFO of Queue   STXSTSF. This field indicates the current number of status in the Tx Status FIFO of this queue. When the DTXSTS bit of MTL Operation Mode register is set to 1  this field does not reflect the number of status words in Tx Status FIFO. Value After Reset  0x0"]
    #[inline(always)]
    pub fn stxstsf(
        self,
    ) -> crate::common::RegisterField<20, 0x7, 1, 0, u8, MtlTxq1Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<20,0x7,1,0,u8, MtlTxq1Debug_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MtlTxq1Debug {
    #[inline(always)]
    fn default() -> MtlTxq1Debug {
        <crate::RegValueT<MtlTxq1Debug_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq1EtsControl_SPEC;
impl crate::sealed::RegSpec for MtlTxq1EtsControl_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit ETS Control Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq1EtsControl = crate::RegValueT<MtlTxq1EtsControl_SPEC>;

impl MtlTxq1EtsControl {
    #[doc = "AV Algorithm   AVALG. When Queue 1 is programmed for AV  this field configures the scheduling algorithm for this queue  This bit when set  indicates credit based shaper algorithm  CBS  is selected for Queue 1 traffic. When reset  strict priority is selected. Value After Reset  0x0"]
    #[inline(always)]
    pub fn avalg(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MtlTxq1EtsControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<2,1,0,MtlTxq1EtsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Credit Control   CC. When this bit is set  the accumulated credit parameter in the credit based shaper algorithm logic is not reset to zero when there is positive credit and no packet to transmit in Channel 1. The credit accumulates even when there is no packet waiting in Channel 1 and another channel is transmitting. When this bit is reset  the accumulated credit parameter in the credit based shaper algorithm logic is set to zero when there is positive credit and no packet to transmit in Channel 1. When there is no packet waiting in Channel 1 and other channel is transmitting  no credit is accumulated. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cc(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlTxq1EtsControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MtlTxq1EtsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Slot Count   SLC. If the credit based shaper algorithm is enabled  the software can        program the number of slots  of duration programmed in        DMA CH n  Slot Interval register if present or 125us  over which the        average transmitted bits per slot  provided in the MTL TxQ n  ETS Status        register  need to be computed for Queue. The encoding is as follows  101   111 Reserved Value After Reset  0x0"]
    #[inline(always)]
    pub fn slc(
        self,
    ) -> crate::common::RegisterField<4, 0x7, 1, 0, u8, MtlTxq1EtsControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<4,0x7,1,0,u8, MtlTxq1EtsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MtlTxq1EtsControl {
    #[inline(always)]
    fn default() -> MtlTxq1EtsControl {
        <crate::RegValueT<MtlTxq1EtsControl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq1EtsStatus_SPEC;
impl crate::sealed::RegSpec for MtlTxq1EtsStatus_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit ETS Status Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq1EtsStatus = crate::RegValueT<MtlTxq1EtsStatus_SPEC>;

impl MtlTxq1EtsStatus {
    #[doc = "Average Bits per Slot   ABS. This field contains the average transmitted bits per slot. If AV operation is enabled  this field is computed over number of slots         programmed in the SLC field of MTL TxQ n  ETS CONTROL register. When        Enable Slot Interval feature is selected  the maximum value of this        field is 0x6 4000 in 100 Mbps  0x3E 8000 in 1000 Mbps and 9C 4000 in        2500 Mbps mode respectively. Otherwise  the maximum value of this field        is 0x30D4 in 100 Mbs  0x1E848 in 1000 Mbps and 0x4C4B4 in 2500 Mbps        respectively. When the DCB operation is enabled for Queue  this field is        computed over every 10 million bit times slot  4 ms in 2500 Mbps  10 ms        in 1000 Mbps  100 ms in 100 Mbps . The maximum value is 0x989680. This        field is reserved in configurations with only one transmit queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn abs(
        self,
    ) -> crate::common::RegisterField<0, 0xffffff, 1, 0, u32, MtlTxq1EtsStatus_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<
            0,
            0xffffff,
            1,
            0,
            u32,
            MtlTxq1EtsStatus_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq1EtsStatus {
    #[inline(always)]
    fn default() -> MtlTxq1EtsStatus {
        <crate::RegValueT<MtlTxq1EtsStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq1Hicredit_SPEC;
impl crate::sealed::RegSpec for MtlTxq1Hicredit_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit HiCredit Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq1Hicredit = crate::RegValueT<MtlTxq1Hicredit_SPEC>;

impl MtlTxq1Hicredit {
    #[doc = "hiCredit Value   HC. When the AV feature is enabled  this field contains the hiCredit value required for the credit based shaper algorithm. This is the maximum value that can be accumulated in the credit parameter. This is specified in bits scaled by 1 024. The maximum value is maxInterferenceSize  that is  best effort maximum packet size  16 384 bytes or 131 072 bits . The value to be specified is 131 072   1 024   134 217 728 or 0x0800 0000. Value After Reset  0x0"]
    #[inline(always)]
    pub fn hc(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x1fffffff,
        1,
        0,
        u32,
        MtlTxq1Hicredit_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x1fffffff,
            1,
            0,
            u32,
            MtlTxq1Hicredit_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq1Hicredit {
    #[inline(always)]
    fn default() -> MtlTxq1Hicredit {
        <crate::RegValueT<MtlTxq1Hicredit_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq1Locredit_SPEC;
impl crate::sealed::RegSpec for MtlTxq1Locredit_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit LoCredit Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq1Locredit = crate::RegValueT<MtlTxq1Locredit_SPEC>;

impl MtlTxq1Locredit {
    #[doc = "loCredit Value   LC. When AV operation is enabled  this field contains the loCredit value required for the credit based shaper algorithm. This is the minimum value that can be accumulated in the credit parameter. This is specified in bits scaled by 1 024. The maximum value to be programmed corresponds to twice the maxFrameSize transmitted from this queue. If the maxFrameSize is 8192 bytes  then  8192 2    8   1024   134 217 728 or 0x0800 0000. Because it is a negative value  the programmed value is 2 s complement of the value  that is  0x1800 0000. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lc(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x1fffffff,
        1,
        0,
        u32,
        MtlTxq1Locredit_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x1fffffff,
            1,
            0,
            u32,
            MtlTxq1Locredit_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq1Locredit {
    #[inline(always)]
    fn default() -> MtlTxq1Locredit {
        <crate::RegValueT<MtlTxq1Locredit_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq1OperationMode_SPEC;
impl crate::sealed::RegSpec for MtlTxq1OperationMode_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Operation Mode Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq1OperationMode = crate::RegValueT<MtlTxq1OperationMode_SPEC>;

impl MtlTxq1OperationMode {
    #[doc = "Flush Transmit Queue   FTQ. When this bit is set  the Tx queue controller logic is reset to its default values. Therefore  all the data in the Tx queue is lost or flushed. This bit is internally reset when the flushing operation is complete. Until this bit is reset  you should not write to the MTL TxQ1 Operation Mode register. The data which is already accepted by the MAC transmitter is not flushed. It is scheduled for transmission and results in underflow and runt packet transmission. Note   The flush operation is complete only when the Tx queue is empty and the application has accepted the pending Tx Status of all transmitted packets. To complete this flush operation  the PHY Tx clock  clk tx i  should be active. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ftq(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlTxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<0,1,0,MtlTxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Store and Forward   TSF. When this bit is set  the transmission starts when a full packet resides in the MTL Tx queue. When this bit is set  the TTC values specified in Bits 6 4  of this register are ignored. This bit should be changed only when the transmission is stopped. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsf(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MtlTxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<1,1,0,MtlTxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Queue Enable   TXQEN. This field is used to enable disable the transmit queue 0. Note   In multiple Tx queues configuration  all the queues are disabled by default. Enable the Tx queue by programming this field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txqen(
        self,
    ) -> crate::common::RegisterField<2, 0x3, 1, 0, u8, MtlTxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<2,0x3,1,0,u8, MtlTxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Threshold Control   TTC. These bits control the threshold level of the MTL Tx Queue. The transmission starts when the packet size within the MTL Tx Queue is larger than the threshold. In addition  full packets with length less than the threshold are also transmitted. These bits are used only when the TSF bit is reset. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ttc(
        self,
    ) -> crate::common::RegisterField<4, 0x7, 1, 0, u8, MtlTxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<4,0x7,1,0,u8, MtlTxq1OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Queue Size   TQS. This field indicates the size of the allocated Transmit queues in blocks        of 256 bytes. The TQS field is read write only if the number of Tx        Queues more than one  the reset value is 0x0 and indicates size of 256        bytes. When the number of Tx Queues is one  the field is read only and        the configured TX FIFO size in blocks of 256 bytes is reflected in the        reset value. The width of this field depends on the Tx memory size        selected in your configuration. For example  if the memory size is 2048         the width of this field is 3 bits  LOG2 2048 256    LOG2 8    3 bits Value After Reset  0x0"]
    #[inline(always)]
    pub fn tqs(
        self,
    ) -> crate::common::RegisterField<16, 0xf, 1, 0, u8, MtlTxq1OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<
            16,
            0xf,
            1,
            0,
            u8,
            MtlTxq1OperationMode_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq1OperationMode {
    #[inline(always)]
    fn default() -> MtlTxq1OperationMode {
        <crate::RegValueT<MtlTxq1OperationMode_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq1QuantumWeight_SPEC;
impl crate::sealed::RegSpec for MtlTxq1QuantumWeight_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Quantum or Weights Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq1QuantumWeight = crate::RegValueT<MtlTxq1QuantumWeight_SPEC>;

impl MtlTxq1QuantumWeight {
    #[doc = "idleSlopeCredit  Quantum or Weights   ISCQW. idleSlopeCredit When AV feature is enabled  this field contains the idleSlopeCredit value required for the creditbased shaper algorithm for Queue 1. This is the rate of change of credit in bits per cycle  40 ns for 100 Mbps  8 ns for 1000 Mbps  3.2 ns for 2500 Mbps  when the credit is increasing. The software should program this field with computed credit in bits per cycle scaled by 1 024. The maximum value is portTransmitRate  that is  0x2000 in 1000 2500 Mbps mode and 0x1000 in 100 Mbps mode. Bits 20 14  must be written to zero. Quantum When the DCB operation is enabled with DWRR algorithm for Queue 1 traffic  this field contains the quantum value in bytes to be added to credit during every queue scanning cycle. The maximum value is 0x1312D0 bytes. Weights When DCB operation is enabled with WFQ algorithm for Queue 1 traffic  this field contains the weight for this queue. The maximum value is 0x3FFF where weight of 0 indicates 100  bandwidth. Bits 20 14  must be written to zero. The higher the programmed weights lesser the bandwidth allocated for the particular Transmit Queue. This is because the weights are used to compute the packet finish time  weights packet size . Lesser the finish time  higher the probability of the packet getting scheduled first and using more bandwidth. When DCB operation or generic queueing operation is enabled with WRR algorithm for Queue 1 traffic  this field contains the weight for this queue. The maximum value is 0x64. Bits  20 7  must be written to zero. Note 1  In multiple Queue configuration this field in respective per queue register must be programmed to some non zero value when multiple queues are enabled or single queue other than Q0 is enabled. This field need not be programmed when only Q0 is enabled. In general  when WRR algorithm is selected a non zero value must be programmed on both Receive and Transmit. In Receive  the register is MTL Operation Mode register. Note 2  For WFQ algorithm  higher the programmed weights lesser the bandwidth allocated for that Transmit Queue. The finish time is not a function of particular packet alone but it is as per the formula   previous finish time of particular Transmit Queue    weights packet size   Note 3  The weights programmed do not correspond to the number of packets but the fraction of bandwidth or time allocated for particular queue w.r.t. total BW or time. Value After Reset  0x0"]
    #[inline(always)]
    pub fn iscqw(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x1fffff,
        1,
        0,
        u32,
        MtlTxq1QuantumWeight_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x1fffff,
            1,
            0,
            u32,
            MtlTxq1QuantumWeight_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq1QuantumWeight {
    #[inline(always)]
    fn default() -> MtlTxq1QuantumWeight {
        <crate::RegValueT<MtlTxq1QuantumWeight_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq1Sendslopecredit_SPEC;
impl crate::sealed::RegSpec for MtlTxq1Sendslopecredit_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit SendSlopeCredit Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq1Sendslopecredit = crate::RegValueT<MtlTxq1Sendslopecredit_SPEC>;

impl MtlTxq1Sendslopecredit {
    #[doc = "sendSlopeCredit Value   SSC. When AV operation is enabled  this field contains the sendSlopeCredit        value required for credit based shaper algorithm for Queue 1. This is        the rate of change of credit in bits per cycle  40 ns for 100 Mbps and 8        ns 1000 Mbps  when the credit is decreasing. The software should program        this field with computed credit in bits per cycle scaled by 1 024. The        maximum value is portTransmitRate  that is  0x2000 in 1000 Mbps mode and        0x1000 in 100 Mbps mode. This field should be programmed with absolute        sendSlopeCredit value. The credit based shaper logic subtracts it from        the accumulated credit when Channel 1 is selected for transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ssc(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x3fff,
        1,
        0,
        u16,
        MtlTxq1Sendslopecredit_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x3fff,
            1,
            0,
            u16,
            MtlTxq1Sendslopecredit_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq1Sendslopecredit {
    #[inline(always)]
    fn default() -> MtlTxq1Sendslopecredit {
        <crate::RegValueT<MtlTxq1Sendslopecredit_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq1Underflow_SPEC;
impl crate::sealed::RegSpec for MtlTxq1Underflow_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Underflow Counter Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq1Underflow = crate::RegValueT<MtlTxq1Underflow_SPEC>;

impl MtlTxq1Underflow {
    #[doc = "Underflow Packet Counter   UFFRMCNT. This field indicates the number of packets aborted by the controller because of Tx Queue Underflow. This counter is incremented each time the MAC aborts outgoing packet because of underflow. The counter is cleared when this register is read with mci be i 0  at 1 b1. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn uffrmcnt(
        self,
    ) -> crate::common::RegisterField<0, 0x7ff, 1, 0, u16, MtlTxq1Underflow_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0x7ff,1,0,u16, MtlTxq1Underflow_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Overflow Bit for Underflow Packet Counter   UFCNTOVF. This bit is set every time the Tx queue Underflow Packet Counter field overflows  that is  it has crossed the maximum count. In such a scenario  the overflow packet counter is reset to all zeros and this bit indicates that the rollover happened. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ufcntovf(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MtlTxq1Underflow_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<11,1,0,MtlTxq1Underflow_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MtlTxq1Underflow {
    #[inline(always)]
    fn default() -> MtlTxq1Underflow {
        <crate::RegValueT<MtlTxq1Underflow_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq2Debug_SPEC;
impl crate::sealed::RegSpec for MtlTxq2Debug_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Debug Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq2Debug = crate::RegValueT<MtlTxq2Debug_SPEC>;

impl MtlTxq2Debug {
    #[doc = "Transmit Queue in Pause   TXQPAUSED. When this bit is high and the Rx flow control is enabled  it indicates that the Tx Queue is in the Pause condition  in the full duplex only mode  because of the following  Reception of the PFC packet for the priorities assigned to the Tx Queue when PFC is enabled Reception of 802.3x Pause packet when PFC is disabled Value After Reset  0x0"]
    #[inline(always)]
    pub fn txqpaused(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlTxq2Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MtlTxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Queue Read Controller Status   TRCSTS. This field indicates the state of the Tx Queue Read Controller  Value After Reset  0x0"]
    #[inline(always)]
    pub fn trcsts(
        self,
    ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, MtlTxq2Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<1,0x3,1,0,u8, MtlTxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Queue Write Controller Status   TWCSTS. When high  this bit indicates that the MTL Tx Queue Write Controller is active  and it is transferring the data to the Tx Queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn twcsts(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlTxq2Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MtlTxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Queue Not Empty Status   TXQSTS. When this bit is high  it indicates that the MTL Tx Queue is not empty and some data is left for transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txqsts(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MtlTxq2Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MtlTxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Status FIFO Full Status   TXSTSFSTS. When high  this bit indicates that the MTL Tx Status FIFO is full. Therefore  the MTL cannot accept any more packets for transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txstsfsts(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MtlTxq2Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MtlTxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of Packets in the Transmit Queue   PTXQ. This field indicates the current number of packets in the Tx Queue. When the DTXSTS bit of MTL Operation Mode register is set to 1  this field does not reflect the number of packets in the Transmit queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ptxq(
        self,
    ) -> crate::common::RegisterField<16, 0x7, 1, 0, u8, MtlTxq2Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<16,0x7,1,0,u8, MtlTxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of Status Words in Tx Status FIFO of Queue   STXSTSF. This field indicates the current number of status in the Tx Status FIFO of this queue. When the DTXSTS bit of MTL Operation Mode register is set to 1  this field does not reflect the number of status words in Tx Status FIFO. Value After Reset  0x0"]
    #[inline(always)]
    pub fn stxstsf(
        self,
    ) -> crate::common::RegisterField<20, 0x7, 1, 0, u8, MtlTxq2Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<20,0x7,1,0,u8, MtlTxq2Debug_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MtlTxq2Debug {
    #[inline(always)]
    fn default() -> MtlTxq2Debug {
        <crate::RegValueT<MtlTxq2Debug_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq2EtsControl_SPEC;
impl crate::sealed::RegSpec for MtlTxq2EtsControl_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit ETS Control Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq2EtsControl = crate::RegValueT<MtlTxq2EtsControl_SPEC>;

impl MtlTxq2EtsControl {
    #[doc = "AV Algorithm   AVALG. When Queue 1 is programmed for AV  this field configures the scheduling algorithm for this queue  This bit when set  indicates credit based shaper algorithm  CBS  is selected for Queue 1 traffic. When reset  strict priority is selected. Value After Reset  0x0"]
    #[inline(always)]
    pub fn avalg(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MtlTxq2EtsControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<2,1,0,MtlTxq2EtsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Credit Control   CC. When this bit is set  the accumulated credit parameter in the credit based shaper algorithm logic is not reset to zero when there is positive credit and no packet to transmit in Channel 1. The credit accumulates even when there is no packet waiting in Channel 1 and another channel is transmitting. When this bit is reset  the accumulated credit parameter in the credit based shaper algorithm logic is set to zero when there is positive credit and no packet to transmit in Channel 1. When there is no packet waiting in Channel 1 and other channel is transmitting  no credit is accumulated. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cc(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlTxq2EtsControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MtlTxq2EtsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Slot Count   SLC. If the credit based shaper algorithm is enabled  the software can        program the number of slots  of duration programmed in        DMA CH n  Slot Interval register if present or 125us  over which the        average transmitted bits per slot  provided in the MTL TxQ n  ETS Status        register  need to be computed for Queue. The encoding is as follows  101   111 Reserved Value After Reset  0x0"]
    #[inline(always)]
    pub fn slc(
        self,
    ) -> crate::common::RegisterField<4, 0x7, 1, 0, u8, MtlTxq2EtsControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<4,0x7,1,0,u8, MtlTxq2EtsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MtlTxq2EtsControl {
    #[inline(always)]
    fn default() -> MtlTxq2EtsControl {
        <crate::RegValueT<MtlTxq2EtsControl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq2EtsStatus_SPEC;
impl crate::sealed::RegSpec for MtlTxq2EtsStatus_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit ETS Status Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq2EtsStatus = crate::RegValueT<MtlTxq2EtsStatus_SPEC>;

impl MtlTxq2EtsStatus {
    #[doc = "Average Bits per Slot   ABS. This field contains the average transmitted bits per slot. If AV operation is enabled  this field is computed over number of slots         programmed in the SLC field of MTL TxQ n  ETS CONTROL register. When        Enable Slot Interval feature is selected  the maximum value of this        field is 0x6 4000 in 100 Mbps  0x3E 8000 in 1000 Mbps and 9C 4000 in        2500 Mbps mode respectively. Otherwise  the maximum value of this field        is 0x30D4 in 100 Mbs  0x1E848 in 1000 Mbps and 0x4C4B4 in 2500 Mbps        respectively. When the DCB operation is enabled for Queue  this field is        computed over every 10 million bit times slot  4 ms in 2500 Mbps  10 ms        in 1000 Mbps  100 ms in 100 Mbps . The maximum value is 0x989680. This        field is reserved in configurations with only one transmit queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn abs(
        self,
    ) -> crate::common::RegisterField<0, 0xffffff, 1, 0, u32, MtlTxq2EtsStatus_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<
            0,
            0xffffff,
            1,
            0,
            u32,
            MtlTxq2EtsStatus_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq2EtsStatus {
    #[inline(always)]
    fn default() -> MtlTxq2EtsStatus {
        <crate::RegValueT<MtlTxq2EtsStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq2Hicredit_SPEC;
impl crate::sealed::RegSpec for MtlTxq2Hicredit_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit HiCredit Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq2Hicredit = crate::RegValueT<MtlTxq2Hicredit_SPEC>;

impl MtlTxq2Hicredit {
    #[doc = "hiCredit Value   HC. When the AV feature is enabled  this field contains the hiCredit value required for the credit based shaper algorithm. This is the maximum value that can be accumulated in the credit parameter. This is specified in bits scaled by 1 024. The maximum value is maxInterferenceSize  that is  best effort maximum packet size  16 384 bytes or 131 072 bits . The value to be specified is 131 072   1 024   134 217 728 or 0x0800 0000. Value After Reset  0x0"]
    #[inline(always)]
    pub fn hc(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x1fffffff,
        1,
        0,
        u32,
        MtlTxq2Hicredit_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x1fffffff,
            1,
            0,
            u32,
            MtlTxq2Hicredit_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq2Hicredit {
    #[inline(always)]
    fn default() -> MtlTxq2Hicredit {
        <crate::RegValueT<MtlTxq2Hicredit_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq2Locredit_SPEC;
impl crate::sealed::RegSpec for MtlTxq2Locredit_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit LoCredit Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq2Locredit = crate::RegValueT<MtlTxq2Locredit_SPEC>;

impl MtlTxq2Locredit {
    #[doc = "loCredit Value   LC. When AV operation is enabled  this field contains the loCredit value required for the credit based shaper algorithm. This is the minimum value that can be accumulated in the credit parameter. This is specified in bits scaled by 1 024. The maximum value to be programmed corresponds to twice the maxFrameSize transmitted from this queue. If the maxFrameSize is 8192 bytes  then  8192 2    8   1024   134 217 728 or 0x0800 0000. Because it is a negative value  the programmed value is 2 s complement of the value  that is  0x1800 0000. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lc(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x1fffffff,
        1,
        0,
        u32,
        MtlTxq2Locredit_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x1fffffff,
            1,
            0,
            u32,
            MtlTxq2Locredit_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq2Locredit {
    #[inline(always)]
    fn default() -> MtlTxq2Locredit {
        <crate::RegValueT<MtlTxq2Locredit_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq2OperationMode_SPEC;
impl crate::sealed::RegSpec for MtlTxq2OperationMode_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Operation Mode Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq2OperationMode = crate::RegValueT<MtlTxq2OperationMode_SPEC>;

impl MtlTxq2OperationMode {
    #[doc = "Flush Transmit Queue   FTQ. When this bit is set  the Tx queue controller logic is reset to its default values. Therefore  all the data in the Tx queue is lost or flushed. This bit is internally reset when the flushing operation is complete. Until this bit is reset  you should not write to the MTL TxQ1 Operation Mode register. The data which is already accepted by the MAC transmitter is not flushed. It is scheduled for transmission and results in underflow and runt packet transmission. Note   The flush operation is complete only when the Tx queue is empty and the application has accepted the pending Tx Status of all transmitted packets. To complete this flush operation  the PHY Tx clock  clk tx i  should be active. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ftq(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlTxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<0,1,0,MtlTxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Store and Forward   TSF. When this bit is set  the transmission starts when a full packet resides in the MTL Tx queue. When this bit is set  the TTC values specified in Bits 6 4  of this register are ignored. This bit should be changed only when the transmission is stopped. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsf(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MtlTxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<1,1,0,MtlTxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Queue Enable   TXQEN. This field is used to enable disable the transmit queue 0. Note   In multiple Tx queues configuration  all the queues are disabled by default. Enable the Tx queue by programming this field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txqen(
        self,
    ) -> crate::common::RegisterField<2, 0x3, 1, 0, u8, MtlTxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<2,0x3,1,0,u8, MtlTxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Threshold Control   TTC. These bits control the threshold level of the MTL Tx Queue. The transmission starts when the packet size within the MTL Tx Queue is larger than the threshold. In addition  full packets with length less than the threshold are also transmitted. These bits are used only when the TSF bit is reset. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ttc(
        self,
    ) -> crate::common::RegisterField<4, 0x7, 1, 0, u8, MtlTxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<4,0x7,1,0,u8, MtlTxq2OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Queue Size   TQS. This field indicates the size of the allocated Transmit queues in blocks        of 256 bytes. The TQS field is read write only if the number of Tx        Queues more than one  the reset value is 0x0 and indicates size of 256        bytes. When the number of Tx Queues is one  the field is read only and        the configured TX FIFO size in blocks of 256 bytes is reflected in the        reset value. The width of this field depends on the Tx memory size        selected in your configuration. For example  if the memory size is 2048         the width of this field is 3 bits  LOG2 2048 256    LOG2 8    3 bits Value After Reset  0x0"]
    #[inline(always)]
    pub fn tqs(
        self,
    ) -> crate::common::RegisterField<16, 0xf, 1, 0, u8, MtlTxq2OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<
            16,
            0xf,
            1,
            0,
            u8,
            MtlTxq2OperationMode_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq2OperationMode {
    #[inline(always)]
    fn default() -> MtlTxq2OperationMode {
        <crate::RegValueT<MtlTxq2OperationMode_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq2QuantumWeight_SPEC;
impl crate::sealed::RegSpec for MtlTxq2QuantumWeight_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Quantum or Weights Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq2QuantumWeight = crate::RegValueT<MtlTxq2QuantumWeight_SPEC>;

impl MtlTxq2QuantumWeight {
    #[doc = "idleSlopeCredit  Quantum or Weights   ISCQW. idleSlopeCredit When AV feature is enabled  this field contains the idleSlopeCredit value required for the creditbased shaper algorithm for Queue 1. This is the rate of change of credit in bits per cycle  40 ns for 100 Mbps  8 ns for 1000 Mbps  3.2 ns for 2500 Mbps  when the credit is increasing. The software should program this field with computed credit in bits per cycle scaled by 1 024. The maximum value is portTransmitRate  that is  0x2000 in 1000 2500 Mbps mode and 0x1000 in 100 Mbps mode. Bits 20 14  must be written to zero. Quantum When the DCB operation is enabled with DWRR algorithm for Queue 1 traffic  this field contains the quantum value in bytes to be added to credit during every queue scanning cycle. The maximum value is 0x1312D0 bytes. Weights When DCB operation is enabled with WFQ algorithm for Queue 1 traffic  this field contains the weight for this queue. The maximum value is 0x3FFF where weight of 0 indicates 100  bandwidth. Bits 20 14  must be written to zero. The higher the programmed weights lesser the bandwidth allocated for the particular Transmit Queue. This is because the weights are used to compute the packet finish time  weights packet size . Lesser the finish time  higher the probability of the packet getting scheduled first and using more bandwidth. When DCB operation or generic queueing operation is enabled with WRR algorithm for Queue 1 traffic  this field contains the weight for this queue. The maximum value is 0x64. Bits  20 7  must be written to zero. Note 1  In multiple Queue configuration this field in respective per queue register must be programmed to some non zero value when multiple queues are enabled or single queue other than Q0 is enabled. This field need not be programmed when only Q0 is enabled. In general  when WRR algorithm is selected a non zero value must be programmed on both Receive and Transmit. In Receive  the register is MTL Operation Mode register. Note 2  For WFQ algorithm  higher the programmed weights lesser the bandwidth allocated for that Transmit Queue. The finish time is not a function of particular packet alone but it is as per the formula   previous finish time of particular Transmit Queue    weights packet size   Note 3  The weights programmed do not correspond to the number of packets but the fraction of bandwidth or time allocated for particular queue w.r.t. total BW or time. Value After Reset  0x0"]
    #[inline(always)]
    pub fn iscqw(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x1fffff,
        1,
        0,
        u32,
        MtlTxq2QuantumWeight_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x1fffff,
            1,
            0,
            u32,
            MtlTxq2QuantumWeight_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq2QuantumWeight {
    #[inline(always)]
    fn default() -> MtlTxq2QuantumWeight {
        <crate::RegValueT<MtlTxq2QuantumWeight_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq2Sendslopecredit_SPEC;
impl crate::sealed::RegSpec for MtlTxq2Sendslopecredit_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit SendSlopeCredit Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq2Sendslopecredit = crate::RegValueT<MtlTxq2Sendslopecredit_SPEC>;

impl MtlTxq2Sendslopecredit {
    #[doc = "sendSlopeCredit Value   SSC. When AV operation is enabled  this field contains the sendSlopeCredit        value required for credit based shaper algorithm for Queue 1. This is        the rate of change of credit in bits per cycle  40 ns for 100 Mbps and 8        ns 1000 Mbps  when the credit is decreasing. The software should program        this field with computed credit in bits per cycle scaled by 1 024. The        maximum value is portTransmitRate  that is  0x2000 in 1000 Mbps mode and        0x1000 in 100 Mbps mode. This field should be programmed with absolute        sendSlopeCredit value. The credit based shaper logic subtracts it from        the accumulated credit when Channel 1 is selected for transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ssc(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x3fff,
        1,
        0,
        u16,
        MtlTxq2Sendslopecredit_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x3fff,
            1,
            0,
            u16,
            MtlTxq2Sendslopecredit_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq2Sendslopecredit {
    #[inline(always)]
    fn default() -> MtlTxq2Sendslopecredit {
        <crate::RegValueT<MtlTxq2Sendslopecredit_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq2Underflow_SPEC;
impl crate::sealed::RegSpec for MtlTxq2Underflow_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Underflow Counter Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq2Underflow = crate::RegValueT<MtlTxq2Underflow_SPEC>;

impl MtlTxq2Underflow {
    #[doc = "Underflow Packet Counter   UFFRMCNT. This field indicates the number of packets aborted by the controller because of Tx Queue Underflow. This counter is incremented each time the MAC aborts outgoing packet because of underflow. The counter is cleared when this register is read with mci be i 0  at 1 b1. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn uffrmcnt(
        self,
    ) -> crate::common::RegisterField<0, 0x7ff, 1, 0, u16, MtlTxq2Underflow_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0x7ff,1,0,u16, MtlTxq2Underflow_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Overflow Bit for Underflow Packet Counter   UFCNTOVF. This bit is set every time the Tx queue Underflow Packet Counter field overflows  that is  it has crossed the maximum count. In such a scenario  the overflow packet counter is reset to all zeros and this bit indicates that the rollover happened. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ufcntovf(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MtlTxq2Underflow_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<11,1,0,MtlTxq2Underflow_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MtlTxq2Underflow {
    #[inline(always)]
    fn default() -> MtlTxq2Underflow {
        <crate::RegValueT<MtlTxq2Underflow_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq3Debug_SPEC;
impl crate::sealed::RegSpec for MtlTxq3Debug_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Debug Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq3Debug = crate::RegValueT<MtlTxq3Debug_SPEC>;

impl MtlTxq3Debug {
    #[doc = "Transmit Queue in Pause   TXQPAUSED. When this bit is high and the Rx flow control is enabled  it indicates that the Tx Queue is in the Pause condition  in the full duplex only mode  because of the following  Reception of the PFC packet for the priorities assigned to the Tx Queue when PFC is enabled Reception of 802.3x Pause packet when PFC is disabled Value After Reset  0x0"]
    #[inline(always)]
    pub fn txqpaused(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlTxq3Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<0,1,0,MtlTxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Queue Read Controller Status   TRCSTS. This field indicates the state of the Tx Queue Read Controller  Value After Reset  0x0"]
    #[inline(always)]
    pub fn trcsts(
        self,
    ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, MtlTxq3Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<1,0x3,1,0,u8, MtlTxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Queue Write Controller Status   TWCSTS. When high  this bit indicates that the MTL Tx Queue Write Controller is active  and it is transferring the data to the Tx Queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn twcsts(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlTxq3Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<3,1,0,MtlTxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Queue Not Empty Status   TXQSTS. When this bit is high  it indicates that the MTL Tx Queue is not empty and some data is left for transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txqsts(
        self,
    ) -> crate::common::RegisterFieldBool<4, 1, 0, MtlTxq3Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<4,1,0,MtlTxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "MTL Tx Status FIFO Full Status   TXSTSFSTS. When high  this bit indicates that the MTL Tx Status FIFO is full. Therefore  the MTL cannot accept any more packets for transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txstsfsts(
        self,
    ) -> crate::common::RegisterFieldBool<5, 1, 0, MtlTxq3Debug_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<5,1,0,MtlTxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of Packets in the Transmit Queue   PTXQ. This field indicates the current number of packets in the Tx Queue. When the DTXSTS bit of MTL Operation Mode register is set to 1  this field does not reflect the number of packets in the Transmit queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ptxq(
        self,
    ) -> crate::common::RegisterField<16, 0x7, 1, 0, u8, MtlTxq3Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<16,0x7,1,0,u8, MtlTxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Number of Status Words in Tx Status FIFO of Queue   STXSTSF. This field indicates the current number of status in the Tx Status FIFO of this queue. When the DTXSTS bit of MTL Operation Mode register is set to 1  this field does not reflect the number of status words in Tx Status FIFO. Value After Reset  0x0"]
    #[inline(always)]
    pub fn stxstsf(
        self,
    ) -> crate::common::RegisterField<20, 0x7, 1, 0, u8, MtlTxq3Debug_SPEC, crate::common::R> {
        crate::common::RegisterField::<20,0x7,1,0,u8, MtlTxq3Debug_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MtlTxq3Debug {
    #[inline(always)]
    fn default() -> MtlTxq3Debug {
        <crate::RegValueT<MtlTxq3Debug_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq3EtsControl_SPEC;
impl crate::sealed::RegSpec for MtlTxq3EtsControl_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit ETS Control Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq3EtsControl = crate::RegValueT<MtlTxq3EtsControl_SPEC>;

impl MtlTxq3EtsControl {
    #[doc = "AV Algorithm   AVALG. When Queue 1 is programmed for AV  this field configures the scheduling algorithm for this queue  This bit when set  indicates credit based shaper algorithm  CBS  is selected for Queue 1 traffic. When reset  strict priority is selected. Value After Reset  0x0"]
    #[inline(always)]
    pub fn avalg(
        self,
    ) -> crate::common::RegisterFieldBool<2, 1, 0, MtlTxq3EtsControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<2,1,0,MtlTxq3EtsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Credit Control   CC. When this bit is set  the accumulated credit parameter in the credit based shaper algorithm logic is not reset to zero when there is positive credit and no packet to transmit in Channel 1. The credit accumulates even when there is no packet waiting in Channel 1 and another channel is transmitting. When this bit is reset  the accumulated credit parameter in the credit based shaper algorithm logic is set to zero when there is positive credit and no packet to transmit in Channel 1. When there is no packet waiting in Channel 1 and other channel is transmitting  no credit is accumulated. Value After Reset  0x0"]
    #[inline(always)]
    pub fn cc(
        self,
    ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlTxq3EtsControl_SPEC, crate::common::RW> {
        crate::common::RegisterFieldBool::<3,1,0,MtlTxq3EtsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Slot Count   SLC. If the credit based shaper algorithm is enabled  the software can        program the number of slots  of duration programmed in        DMA CH n  Slot Interval register if present or 125us  over which the        average transmitted bits per slot  provided in the MTL TxQ n  ETS Status        register  need to be computed for Queue. The encoding is as follows  101   111 Reserved Value After Reset  0x0"]
    #[inline(always)]
    pub fn slc(
        self,
    ) -> crate::common::RegisterField<4, 0x7, 1, 0, u8, MtlTxq3EtsControl_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<4,0x7,1,0,u8, MtlTxq3EtsControl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for MtlTxq3EtsControl {
    #[inline(always)]
    fn default() -> MtlTxq3EtsControl {
        <crate::RegValueT<MtlTxq3EtsControl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq3EtsStatus_SPEC;
impl crate::sealed::RegSpec for MtlTxq3EtsStatus_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit ETS Status Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq3EtsStatus = crate::RegValueT<MtlTxq3EtsStatus_SPEC>;

impl MtlTxq3EtsStatus {
    #[doc = "Average Bits per Slot   ABS. This field contains the average transmitted bits per slot. If AV operation is enabled  this field is computed over number of slots         programmed in the SLC field of MTL TxQ n  ETS CONTROL register. When        Enable Slot Interval feature is selected  the maximum value of this        field is 0x6 4000 in 100 Mbps  0x3E 8000 in 1000 Mbps and 9C 4000 in        2500 Mbps mode respectively. Otherwise  the maximum value of this field        is 0x30D4 in 100 Mbs  0x1E848 in 1000 Mbps and 0x4C4B4 in 2500 Mbps        respectively. When the DCB operation is enabled for Queue  this field is        computed over every 10 million bit times slot  4 ms in 2500 Mbps  10 ms        in 1000 Mbps  100 ms in 100 Mbps . The maximum value is 0x989680. This        field is reserved in configurations with only one transmit queue. Value After Reset  0x0"]
    #[inline(always)]
    pub fn abs(
        self,
    ) -> crate::common::RegisterField<0, 0xffffff, 1, 0, u32, MtlTxq3EtsStatus_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<
            0,
            0xffffff,
            1,
            0,
            u32,
            MtlTxq3EtsStatus_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq3EtsStatus {
    #[inline(always)]
    fn default() -> MtlTxq3EtsStatus {
        <crate::RegValueT<MtlTxq3EtsStatus_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq3Hicredit_SPEC;
impl crate::sealed::RegSpec for MtlTxq3Hicredit_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit HiCredit Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq3Hicredit = crate::RegValueT<MtlTxq3Hicredit_SPEC>;

impl MtlTxq3Hicredit {
    #[doc = "hiCredit Value   HC. When the AV feature is enabled  this field contains the hiCredit value required for the credit based shaper algorithm. This is the maximum value that can be accumulated in the credit parameter. This is specified in bits scaled by 1 024. The maximum value is maxInterferenceSize  that is  best effort maximum packet size  16 384 bytes or 131 072 bits . The value to be specified is 131 072   1 024   134 217 728 or 0x0800 0000. Value After Reset  0x0"]
    #[inline(always)]
    pub fn hc(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x1fffffff,
        1,
        0,
        u32,
        MtlTxq3Hicredit_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x1fffffff,
            1,
            0,
            u32,
            MtlTxq3Hicredit_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq3Hicredit {
    #[inline(always)]
    fn default() -> MtlTxq3Hicredit {
        <crate::RegValueT<MtlTxq3Hicredit_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq3Locredit_SPEC;
impl crate::sealed::RegSpec for MtlTxq3Locredit_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit LoCredit Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq3Locredit = crate::RegValueT<MtlTxq3Locredit_SPEC>;

impl MtlTxq3Locredit {
    #[doc = "loCredit Value   LC. When AV operation is enabled  this field contains the loCredit value required for the credit based shaper algorithm. This is the minimum value that can be accumulated in the credit parameter. This is specified in bits scaled by 1 024. The maximum value to be programmed corresponds to twice the maxFrameSize transmitted from this queue. If the maxFrameSize is 8192 bytes  then  8192 2    8   1024   134 217 728 or 0x0800 0000. Because it is a negative value  the programmed value is 2 s complement of the value  that is  0x1800 0000. Value After Reset  0x0"]
    #[inline(always)]
    pub fn lc(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x1fffffff,
        1,
        0,
        u32,
        MtlTxq3Locredit_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x1fffffff,
            1,
            0,
            u32,
            MtlTxq3Locredit_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq3Locredit {
    #[inline(always)]
    fn default() -> MtlTxq3Locredit {
        <crate::RegValueT<MtlTxq3Locredit_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq3OperationMode_SPEC;
impl crate::sealed::RegSpec for MtlTxq3OperationMode_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Operation Mode Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq3OperationMode = crate::RegValueT<MtlTxq3OperationMode_SPEC>;

impl MtlTxq3OperationMode {
    #[doc = "Flush Transmit Queue   FTQ. When this bit is set  the Tx queue controller logic is reset to its default values. Therefore  all the data in the Tx queue is lost or flushed. This bit is internally reset when the flushing operation is complete. Until this bit is reset  you should not write to the MTL TxQ1 Operation Mode register. The data which is already accepted by the MAC transmitter is not flushed. It is scheduled for transmission and results in underflow and runt packet transmission. Note   The flush operation is complete only when the Tx queue is empty and the application has accepted the pending Tx Status of all transmitted packets. To complete this flush operation  the PHY Tx clock  clk tx i  should be active. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ftq(
        self,
    ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlTxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<0,1,0,MtlTxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Store and Forward   TSF. When this bit is set  the transmission starts when a full packet resides in the MTL Tx queue. When this bit is set  the TTC values specified in Bits 6 4  of this register are ignored. This bit should be changed only when the transmission is stopped. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tsf(
        self,
    ) -> crate::common::RegisterFieldBool<1, 1, 0, MtlTxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterFieldBool::<1,1,0,MtlTxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Queue Enable   TXQEN. This field is used to enable disable the transmit queue 0. Note   In multiple Tx queues configuration  all the queues are disabled by default. Enable the Tx queue by programming this field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txqen(
        self,
    ) -> crate::common::RegisterField<2, 0x3, 1, 0, u8, MtlTxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<2,0x3,1,0,u8, MtlTxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Threshold Control   TTC. These bits control the threshold level of the MTL Tx Queue. The transmission starts when the packet size within the MTL Tx Queue is larger than the threshold. In addition  full packets with length less than the threshold are also transmitted. These bits are used only when the TSF bit is reset. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ttc(
        self,
    ) -> crate::common::RegisterField<4, 0x7, 1, 0, u8, MtlTxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<4,0x7,1,0,u8, MtlTxq3OperationMode_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Transmit Queue Size   TQS. This field indicates the size of the allocated Transmit queues in blocks        of 256 bytes. The TQS field is read write only if the number of Tx        Queues more than one  the reset value is 0x0 and indicates size of 256        bytes. When the number of Tx Queues is one  the field is read only and        the configured TX FIFO size in blocks of 256 bytes is reflected in the        reset value. The width of this field depends on the Tx memory size        selected in your configuration. For example  if the memory size is 2048         the width of this field is 3 bits  LOG2 2048 256    LOG2 8    3 bits Value After Reset  0x0"]
    #[inline(always)]
    pub fn tqs(
        self,
    ) -> crate::common::RegisterField<16, 0xf, 1, 0, u8, MtlTxq3OperationMode_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<
            16,
            0xf,
            1,
            0,
            u8,
            MtlTxq3OperationMode_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq3OperationMode {
    #[inline(always)]
    fn default() -> MtlTxq3OperationMode {
        <crate::RegValueT<MtlTxq3OperationMode_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq3QuantumWeight_SPEC;
impl crate::sealed::RegSpec for MtlTxq3QuantumWeight_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Quantum or Weights Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq3QuantumWeight = crate::RegValueT<MtlTxq3QuantumWeight_SPEC>;

impl MtlTxq3QuantumWeight {
    #[doc = "idleSlopeCredit  Quantum or Weights   ISCQW. idleSlopeCredit When AV feature is enabled  this field contains the idleSlopeCredit value required for the creditbased shaper algorithm for Queue 1. This is the rate of change of credit in bits per cycle  40 ns for 100 Mbps  8 ns for 1000 Mbps  3.2 ns for 2500 Mbps  when the credit is increasing. The software should program this field with computed credit in bits per cycle scaled by 1 024. The maximum value is portTransmitRate  that is  0x2000 in 1000 2500 Mbps mode and 0x1000 in 100 Mbps mode. Bits 20 14  must be written to zero. Quantum When the DCB operation is enabled with DWRR algorithm for Queue 1 traffic  this field contains the quantum value in bytes to be added to credit during every queue scanning cycle. The maximum value is 0x1312D0 bytes. Weights When DCB operation is enabled with WFQ algorithm for Queue 1 traffic  this field contains the weight for this queue. The maximum value is 0x3FFF where weight of 0 indicates 100  bandwidth. Bits 20 14  must be written to zero. The higher the programmed weights lesser the bandwidth allocated for the particular Transmit Queue. This is because the weights are used to compute the packet finish time  weights packet size . Lesser the finish time  higher the probability of the packet getting scheduled first and using more bandwidth. When DCB operation or generic queueing operation is enabled with WRR algorithm for Queue 1 traffic  this field contains the weight for this queue. The maximum value is 0x64. Bits  20 7  must be written to zero. Note 1  In multiple Queue configuration this field in respective per queue register must be programmed to some non zero value when multiple queues are enabled or single queue other than Q0 is enabled. This field need not be programmed when only Q0 is enabled. In general  when WRR algorithm is selected a non zero value must be programmed on both Receive and Transmit. In Receive  the register is MTL Operation Mode register. Note 2  For WFQ algorithm  higher the programmed weights lesser the bandwidth allocated for that Transmit Queue. The finish time is not a function of particular packet alone but it is as per the formula   previous finish time of particular Transmit Queue    weights packet size   Note 3  The weights programmed do not correspond to the number of packets but the fraction of bandwidth or time allocated for particular queue w.r.t. total BW or time. Value After Reset  0x0"]
    #[inline(always)]
    pub fn iscqw(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x1fffff,
        1,
        0,
        u32,
        MtlTxq3QuantumWeight_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x1fffff,
            1,
            0,
            u32,
            MtlTxq3QuantumWeight_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq3QuantumWeight {
    #[inline(always)]
    fn default() -> MtlTxq3QuantumWeight {
        <crate::RegValueT<MtlTxq3QuantumWeight_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq3Sendslopecredit_SPEC;
impl crate::sealed::RegSpec for MtlTxq3Sendslopecredit_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit SendSlopeCredit Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq3Sendslopecredit = crate::RegValueT<MtlTxq3Sendslopecredit_SPEC>;

impl MtlTxq3Sendslopecredit {
    #[doc = "sendSlopeCredit Value   SSC. When AV operation is enabled  this field contains the sendSlopeCredit        value required for credit based shaper algorithm for Queue 1. This is        the rate of change of credit in bits per cycle  40 ns for 100 Mbps and 8        ns 1000 Mbps  when the credit is decreasing. The software should program        this field with computed credit in bits per cycle scaled by 1 024. The        maximum value is portTransmitRate  that is  0x2000 in 1000 Mbps mode and        0x1000 in 100 Mbps mode. This field should be programmed with absolute        sendSlopeCredit value. The credit based shaper logic subtracts it from        the accumulated credit when Channel 1 is selected for transmission. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ssc(
        self,
    ) -> crate::common::RegisterField<
        0,
        0x3fff,
        1,
        0,
        u16,
        MtlTxq3Sendslopecredit_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0x3fff,
            1,
            0,
            u16,
            MtlTxq3Sendslopecredit_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for MtlTxq3Sendslopecredit {
    #[inline(always)]
    fn default() -> MtlTxq3Sendslopecredit {
        <crate::RegValueT<MtlTxq3Sendslopecredit_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq3Underflow_SPEC;
impl crate::sealed::RegSpec for MtlTxq3Underflow_SPEC {
    type DataType = u32;
}
#[doc = "MTL Queue 3 Transmit Underflow Counter Register\n resetvalue={Application Reset:0x0}"]
pub type MtlTxq3Underflow = crate::RegValueT<MtlTxq3Underflow_SPEC>;

impl MtlTxq3Underflow {
    #[doc = "Underflow Packet Counter   UFFRMCNT. This field indicates the number of packets aborted by the controller because of Tx Queue Underflow. This counter is incremented each time the MAC aborts outgoing packet because of underflow. The counter is cleared when this register is read with mci be i 0  at 1 b1. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn uffrmcnt(
        self,
    ) -> crate::common::RegisterField<0, 0x7ff, 1, 0, u16, MtlTxq3Underflow_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0x7ff,1,0,u16, MtlTxq3Underflow_SPEC,crate::common::R>::from_register(self,0)
    }
    #[doc = "Overflow Bit for Underflow Packet Counter   UFCNTOVF. This bit is set every time the Tx queue Underflow Packet Counter field overflows  that is  it has crossed the maximum count. In such a scenario  the overflow packet counter is reset to all zeros and this bit indicates that the rollover happened. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
    #[inline(always)]
    pub fn ufcntovf(
        self,
    ) -> crate::common::RegisterFieldBool<11, 1, 0, MtlTxq3Underflow_SPEC, crate::common::R> {
        crate::common::RegisterFieldBool::<11,1,0,MtlTxq3Underflow_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for MtlTxq3Underflow {
    #[inline(always)]
    fn default() -> MtlTxq3Underflow {
        <crate::RegValueT<MtlTxq3Underflow_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RwkFilterByteMaskI_SPEC;
impl crate::sealed::RegSpec for RwkFilterByteMaskI_SPEC {
    type DataType = u32;
}
#[doc = "MAC Wake up Filter Byte Mask register\n resetvalue={Application Reset:0x0}"]
pub type RwkFilterByteMaskI = crate::RegValueT<RwkFilterByteMaskI_SPEC>;

impl RwkFilterByteMaskI {
    #[doc = "Filter 32 bit Mask   Filteri Byte Mask. Each bit in this mask corresponds to one byte in the detected packet. If        the bit is 1   the corresponding byte is taken into the CRC16        calculation. Value After Reset  0x0"]
    #[inline(always)]
    pub fn filteri_byte_mask(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        RwkFilterByteMaskI_SPEC,
        crate::common::RW,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            RwkFilterByteMaskI_SPEC,
            crate::common::RW,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RwkFilterByteMaskI {
    #[inline(always)]
    fn default() -> RwkFilterByteMaskI {
        <crate::RegValueT<RwkFilterByteMaskI_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RwkFilterCommand0_SPEC;
impl crate::sealed::RegSpec for RwkFilterCommand0_SPEC {
    type DataType = u32;
}
#[doc = "MAC Wake up Filter Command 0 Register\n resetvalue={Application Reset:0x0}"]
pub type RwkFilterCommand0 = crate::RegValueT<RwkFilterCommand0_SPEC>;

impl RwkFilterCommand0 {
    #[doc = "Filter0 Command. The 4 bit filter command controls the filter operation. Bit 3 specifies the address type  defining the destination address type of the pattern. When the bit is set  the pattern applies to only multicast packets  when the bit is reset  the pattern applies only to unicast packet. Bit 2  Inverse Mode   when set  reverses the logic of the CRC16 hash function signal  to reject a packet with matching CRC 16 value. Bit 2  along with Bit 1  allows a MAC to reject a subset of remote wake up packets by creating filter logic such as  Pattern 1 AND NOT Pattern 2 . Bit 1  And Previous  implements the Boolean logic. When set  the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two  three  or four filters. This depends on the number of filters that have the And Previous bit set. Bit 0 is the enable for filter. If Bit 0 is not set  filter is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn filter0_command(
        self,
    ) -> crate::common::RegisterField<0, 0xf, 1, 0, u8, RwkFilterCommand0_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xf,1,0,u8, RwkFilterCommand0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Filter1 Command. The 4 bit filter command controls the filter operation. Bit 3 specifies the address type  defining the destination address type of the pattern. When the bit is set  the pattern applies to only multicast packets  when the bit is reset  the pattern applies only to unicast packet. Bit 2  Inverse Mode   when set  reverses the logic of the CRC16 hash function signal  to reject a packet with matching CRC 16 value. Bit 2  along with Bit 1  allows a MAC to reject a subset of remote wake up packets by creating filter logic such as  Pattern 1 AND NOT Pattern 2 . Bit 1  And Previous  implements the Boolean logic. When set  the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two  three  or four filters. This depends on the number of filters that have the And Previous bit set. Bit 0 is the enable for filter. If Bit 0 is not set  filter is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn filter1_command(
        self,
    ) -> crate::common::RegisterField<8, 0xf, 1, 0, u8, RwkFilterCommand0_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<8,0xf,1,0,u8, RwkFilterCommand0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Filter2 Command. The 4 bit filter command controls the filter operation. Bit 3 specifies the address type  defining the destination address type of the pattern. When the bit is set  the pattern applies to only multicast packets  when the bit is reset  the pattern applies only to unicast packet. Bit 2  Inverse Mode   when set  reverses the logic of the CRC16 hash function signal  to reject a packet with matching CRC 16 value. Bit 2  along with Bit 1  allows a MAC to reject a subset of remote wake up packets by creating filter logic such as  Pattern 1 AND NOT Pattern 2 . Bit 1  And Previous  implements the Boolean logic. When set  the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two  three  or four filters. This depends on the number of filters that have the And Previous bit set. Bit 0 is the enable for filter. If Bit 0 is not set  filter is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn filter2_command(
        self,
    ) -> crate::common::RegisterField<16, 0xf, 1, 0, u8, RwkFilterCommand0_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0xf,1,0,u8, RwkFilterCommand0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Filter3 Command. The 4 bit filter command controls the filter operation. Bit 3 specifies the address type  defining the destination address type of the pattern. When the bit is set  the pattern applies to only multicast packets  when the bit is reset  the pattern applies only to unicast packet. Bit 2  Inverse Mode   when set  reverses the logic of the CRC16 hash function signal  to reject a packet with matching CRC 16 value. Bit 2  along with Bit 1  allows a MAC to reject a subset of remote wake up packets by creating filter logic such as  Pattern 1 AND NOT Pattern 2 . Bit 1  And Previous  implements the Boolean logic. When set  the result of the current entry is logically ANDed with the result of the previous filter. This AND logic allows a filter pattern longer than 32 bytes by splitting the mask among two  three  or four filters. This depends on the number of filters that have the And Previous bit set. Bit 0 is the enable for filter. If Bit 0 is not set  filter is disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn filter3_command(
        self,
    ) -> crate::common::RegisterField<24, 0xf, 1, 0, u8, RwkFilterCommand0_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0xf,1,0,u8, RwkFilterCommand0_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for RwkFilterCommand0 {
    #[inline(always)]
    fn default() -> RwkFilterCommand0 {
        <crate::RegValueT<RwkFilterCommand0_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RwkFilterCrcI_SPEC;
impl crate::sealed::RegSpec for RwkFilterCrcI_SPEC {
    type DataType = u32;
}
#[doc = "MAC Wake up Filter CRC Register\n resetvalue={Application Reset:0x0}"]
pub type RwkFilterCrcI = crate::RegValueT<RwkFilterCrcI_SPEC>;

impl RwkFilterCrcI {
    #[doc = "Filter0 CRC. This filter CRC 16 contains the CRC 16 value of the pattern. The 16 bit CRC calculation uses the following polynomial  G x    x 16   x 15   x 2   1 Value After Reset  0x0"]
    #[inline(always)]
    pub fn filter0_crc(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RwkFilterCrcI_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, RwkFilterCrcI_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Filter1 CRC. This filter CRC 16 contains the CRC 16 value of the pattern. The 16 bit CRC calculation uses the following polynomial  G x    x 16   x 15   x 2   1 Value After Reset  0x0"]
    #[inline(always)]
    pub fn filter1_crc(
        self,
    ) -> crate::common::RegisterField<16, 0xffff, 1, 0, u16, RwkFilterCrcI_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0xffff,1,0,u16, RwkFilterCrcI_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for RwkFilterCrcI {
    #[inline(always)]
    fn default() -> RwkFilterCrcI {
        <crate::RegValueT<RwkFilterCrcI_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RwkFilterOffset0_SPEC;
impl crate::sealed::RegSpec for RwkFilterOffset0_SPEC {
    type DataType = u32;
}
#[doc = "MAC Wake up Filter Offset 0 Register\n resetvalue={Application Reset:0x0}"]
pub type RwkFilterOffset0 = crate::RegValueT<RwkFilterOffset0_SPEC>;

impl RwkFilterOffset0 {
    #[doc = "Filter0 Offset. This filter offset defines the offset  within the packet  from which the filter examines the packets. This 8 bit pattern offset is the offset for the filter first byte to be examined. The minimum allowed offset is 12  which refers to the 13th byte of the packet. The offset value 0 refers to the first byte of the packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn filter0_offset(
        self,
    ) -> crate::common::RegisterField<0, 0xff, 1, 0, u8, RwkFilterOffset0_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<0,0xff,1,0,u8, RwkFilterOffset0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Filter1 Offset. This filter offset defines the offset  within the packet  from which the filter examines the packets. This 8 bit pattern offset is the offset for the filter first byte to be examined. The minimum allowed offset is 12  which refers to the 13th byte of the packet. The offset value 0 refers to the first byte of the packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn filter1_offset(
        self,
    ) -> crate::common::RegisterField<8, 0xff, 1, 0, u8, RwkFilterOffset0_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<8,0xff,1,0,u8, RwkFilterOffset0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Filter2 Offset. This filter offset defines the offset  within the packet  from which the filter examines the packets. This 8 bit pattern offset is the offset for the filter first byte to be examined. The minimum allowed offset is 12  which refers to the 13th byte of the packet. The offset value 0 refers to the first byte of the packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn filter2_offset(
        self,
    ) -> crate::common::RegisterField<16, 0xff, 1, 0, u8, RwkFilterOffset0_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<16,0xff,1,0,u8, RwkFilterOffset0_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "Filter3 Offset. This filter offset defines the offset  within the packet  from which the filter examines the packets. This 8 bit pattern offset is the offset for the filter first byte to be examined. The minimum allowed offset is 12  which refers to the 13th byte of the packet. The offset value 0 refers to the first byte of the packet. Value After Reset  0x0"]
    #[inline(always)]
    pub fn filter3_offset(
        self,
    ) -> crate::common::RegisterField<24, 0xff, 1, 0, u8, RwkFilterOffset0_SPEC, crate::common::RW>
    {
        crate::common::RegisterField::<24,0xff,1,0,u8, RwkFilterOffset0_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for RwkFilterOffset0 {
    #[inline(always)]
    fn default() -> RwkFilterOffset0 {
        <crate::RegValueT<RwkFilterOffset0_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxicmpErrorOctets_SPEC;
impl crate::sealed::RegSpec for RxicmpErrorOctets_SPEC {
    type DataType = u32;
}
#[doc = "Received ICMP Error Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxicmpErrorOctets = crate::RegValueT<RxicmpErrorOctets_SPEC>;

impl RxicmpErrorOctets {
    #[doc = "RxICMP Error Octets   RXICMPERROCT. This field indicates the number of bytes received in a ICMP segment that had checksum errors. This counter does not count IP header bytes. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmperroct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        RxicmpErrorOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            RxicmpErrorOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxicmpErrorOctets {
    #[inline(always)]
    fn default() -> RxicmpErrorOctets {
        <crate::RegValueT<RxicmpErrorOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxicmpErrorPackets_SPEC;
impl crate::sealed::RegSpec for RxicmpErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received ICMP Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxicmpErrorPackets = crate::RegValueT<RxicmpErrorPackets_SPEC>;

impl RxicmpErrorPackets {
    #[doc = "RxICMP Error Packets   RXICMPERRPKT. This field indicates the number of good IP datagrams received whose ICMP payload has a checksum error. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmperrpkt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxicmpErrorPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxicmpErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxicmpErrorPackets {
    #[inline(always)]
    fn default() -> RxicmpErrorPackets {
        <crate::RegValueT<RxicmpErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxicmpGoodOctets_SPEC;
impl crate::sealed::RegSpec for RxicmpGoodOctets_SPEC {
    type DataType = u32;
}
#[doc = "Good Received ICMP Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxicmpGoodOctets = crate::RegValueT<RxicmpGoodOctets_SPEC>;

impl RxicmpGoodOctets {
    #[doc = "RxICMP Good Octets   RXICMPGDOCT. This field indicates the number of bytes received in a good ICMP segment. This counter does not count IP header bytes. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmpgdoct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        RxicmpGoodOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            RxicmpGoodOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxicmpGoodOctets {
    #[inline(always)]
    fn default() -> RxicmpGoodOctets {
        <crate::RegValueT<RxicmpGoodOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxicmpGoodPackets_SPEC;
impl crate::sealed::RegSpec for RxicmpGoodPackets_SPEC {
    type DataType = u32;
}
#[doc = "Good Received ICMP Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxicmpGoodPackets = crate::RegValueT<RxicmpGoodPackets_SPEC>;

impl RxicmpGoodPackets {
    #[doc = "RxICMP Good Packets   RXICMPGDPKT. This field indicates the number of good IP datagrams received with a good ICMP payload. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxicmpgdpkt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxicmpGoodPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, RxicmpGoodPackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for RxicmpGoodPackets {
    #[inline(always)]
    fn default() -> RxicmpGoodPackets {
        <crate::RegValueT<RxicmpGoodPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv4FragmentedOctets_SPEC;
impl crate::sealed::RegSpec for Rxipv4FragmentedOctets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPV4 Fragmented Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv4FragmentedOctets = crate::RegValueT<Rxipv4FragmentedOctets_SPEC>;

impl Rxipv4FragmentedOctets {
    #[doc = "RxIPv4 Fragmented Octets   RXIPV4FRAGOCT. This field indicates the number of bytes received in fragmented IPv4 datagrams. The value in the Length field of IPv4 header is used to update this counter.  Ethernet header  FCS  pad  or IP pad bytes are not included in this counter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4fragoct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        Rxipv4FragmentedOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            Rxipv4FragmentedOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv4FragmentedOctets {
    #[inline(always)]
    fn default() -> Rxipv4FragmentedOctets {
        <crate::RegValueT<Rxipv4FragmentedOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv4FragmentedPackets_SPEC;
impl crate::sealed::RegSpec for Rxipv4FragmentedPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPv4 Fragmented Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv4FragmentedPackets = crate::RegValueT<Rxipv4FragmentedPackets_SPEC>;

impl Rxipv4FragmentedPackets {
    #[doc = "RxIPv4 Fragmented Packets   RXIPV4FRAGPKT. This field indicates the number of good IPv4 datagrams received with fragmentation. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4fragpkt(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rxipv4FragmentedPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rxipv4FragmentedPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv4FragmentedPackets {
    #[inline(always)]
    fn default() -> Rxipv4FragmentedPackets {
        <crate::RegValueT<Rxipv4FragmentedPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv4GoodOctets_SPEC;
impl crate::sealed::RegSpec for Rxipv4GoodOctets_SPEC {
    type DataType = u32;
}
#[doc = "Good Received IPV4 Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv4GoodOctets = crate::RegValueT<Rxipv4GoodOctets_SPEC>;

impl Rxipv4GoodOctets {
    #[doc = "RxIPv4 Good Octets   RXIPV4GDOCT. This field indicates the number of bytes received in good IPv4 datagrams encapsulating TCP  UDP  or ICMP data.  Ethernet header  FCS  pad  or IP pad bytes are not included in this counter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4gdoct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        Rxipv4GoodOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            Rxipv4GoodOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv4GoodOctets {
    #[inline(always)]
    fn default() -> Rxipv4GoodOctets {
        <crate::RegValueT<Rxipv4GoodOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv4GoodPackets_SPEC;
impl crate::sealed::RegSpec for Rxipv4GoodPackets_SPEC {
    type DataType = u32;
}
#[doc = "Good Received RxIPv4 Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv4GoodPackets = crate::RegValueT<Rxipv4GoodPackets_SPEC>;

impl Rxipv4GoodPackets {
    #[doc = "RxIPv4 Good Packets   RXIPV4GDPKT. This field indicates the number of good IPv4 datagrams received with the TCP  UDP  or ICMP payload. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4gdpkt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, Rxipv4GoodPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, Rxipv4GoodPackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for Rxipv4GoodPackets {
    #[inline(always)]
    fn default() -> Rxipv4GoodPackets {
        <crate::RegValueT<Rxipv4GoodPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv4HeaderErrorOctets_SPEC;
impl crate::sealed::RegSpec for Rxipv4HeaderErrorOctets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPV4 Header Error Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv4HeaderErrorOctets = crate::RegValueT<Rxipv4HeaderErrorOctets_SPEC>;

impl Rxipv4HeaderErrorOctets {
    #[doc = "RxIPv4 Header Error Octets   RXIPV4HDRERROCT. This field indicates the number of bytes received in IPv4 datagrams with header errors  checksum  length  version mismatch . The value in the Length field of IPv4 header is used to update this counter.  Ethernet header  FCS  pad  or IP pad bytes are not included in this counter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4hdrerroct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        Rxipv4HeaderErrorOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            Rxipv4HeaderErrorOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv4HeaderErrorOctets {
    #[inline(always)]
    fn default() -> Rxipv4HeaderErrorOctets {
        <crate::RegValueT<Rxipv4HeaderErrorOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv4HeaderErrorPackets_SPEC;
impl crate::sealed::RegSpec for Rxipv4HeaderErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPv4 Header Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv4HeaderErrorPackets = crate::RegValueT<Rxipv4HeaderErrorPackets_SPEC>;

impl Rxipv4HeaderErrorPackets {
    #[doc = "RxIPv4 Header Error Packets   RXIPV4HDRERRPKT. This field indicates the number of IPv4 datagrams received with header  checksum  length  or version mismatch  errors. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4hdrerrpkt(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rxipv4HeaderErrorPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rxipv4HeaderErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv4HeaderErrorPackets {
    #[inline(always)]
    fn default() -> Rxipv4HeaderErrorPackets {
        <crate::RegValueT<Rxipv4HeaderErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv4NoPayloadOctets_SPEC;
impl crate::sealed::RegSpec for Rxipv4NoPayloadOctets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPV4 No Payload Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv4NoPayloadOctets = crate::RegValueT<Rxipv4NoPayloadOctets_SPEC>;

impl Rxipv4NoPayloadOctets {
    #[doc = "RxIPv4 Payload Octets   RXIPV4NOPAYOCT. This field indicates the number of bytes received in IPv4 datagrams that did not have a TCP  UDP  or ICMP payload. The value in the Length field of IPv4 header is used to update this counter.  Ethernet header  FCS  pad  or IP pad bytes are not included in this counter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4nopayoct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        Rxipv4NoPayloadOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            Rxipv4NoPayloadOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv4NoPayloadOctets {
    #[inline(always)]
    fn default() -> Rxipv4NoPayloadOctets {
        <crate::RegValueT<Rxipv4NoPayloadOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv4NoPayloadPackets_SPEC;
impl crate::sealed::RegSpec for Rxipv4NoPayloadPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPv4 No Payload Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv4NoPayloadPackets = crate::RegValueT<Rxipv4NoPayloadPackets_SPEC>;

impl Rxipv4NoPayloadPackets {
    #[doc = "RxIPv4 Payload Packets   RXIPV4NOPAYPKT. This field indicates the number of IPv4 datagram packets received that did not have a TCP  UDP  or ICMP payload. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4nopaypkt(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rxipv4NoPayloadPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rxipv4NoPayloadPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv4NoPayloadPackets {
    #[inline(always)]
    fn default() -> Rxipv4NoPayloadPackets {
        <crate::RegValueT<Rxipv4NoPayloadPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv4UdpChecksumDisabledPackets_SPEC;
impl crate::sealed::RegSpec for Rxipv4UdpChecksumDisabledPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPv4 UPD Checksum Disabled Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv4UdpChecksumDisabledPackets = crate::RegValueT<Rxipv4UdpChecksumDisabledPackets_SPEC>;

impl Rxipv4UdpChecksumDisabledPackets {
    #[doc = "RxIPv4 UDP Checksum Disabled Packets   RXIPV4UDSBLPKT. This field indicates the number of good IPv4 datagrams received that had a UDP payload with checksum disabled. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4udsblpkt(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rxipv4UdpChecksumDisabledPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rxipv4UdpChecksumDisabledPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv4UdpChecksumDisabledPackets {
    #[inline(always)]
    fn default() -> Rxipv4UdpChecksumDisabledPackets {
        <crate::RegValueT<Rxipv4UdpChecksumDisabledPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv4UdpChecksumDisableOctets_SPEC;
impl crate::sealed::RegSpec for Rxipv4UdpChecksumDisableOctets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPV4 UPD Checksum Disabled Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv4UdpChecksumDisableOctets = crate::RegValueT<Rxipv4UdpChecksumDisableOctets_SPEC>;

impl Rxipv4UdpChecksumDisableOctets {
    #[doc = "RxIPv4 UDP Checksum Disable Octets   RXIPV4UDSBLOCT. This field indicates the number of bytes received in a UDP segment that had the UDP checksum disabled. This counter does not count IP Header bytes.  Ethernet header  FCS  pad  or IP pad bytes are not included in this counter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv4udsbloct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        Rxipv4UdpChecksumDisableOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            Rxipv4UdpChecksumDisableOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv4UdpChecksumDisableOctets {
    #[inline(always)]
    fn default() -> Rxipv4UdpChecksumDisableOctets {
        <crate::RegValueT<Rxipv4UdpChecksumDisableOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv6GoodOctets_SPEC;
impl crate::sealed::RegSpec for Rxipv6GoodOctets_SPEC {
    type DataType = u32;
}
#[doc = "Good Received IPV6 Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv6GoodOctets = crate::RegValueT<Rxipv6GoodOctets_SPEC>;

impl Rxipv6GoodOctets {
    #[doc = "RxIPv6 Good Octets   RXIPV6GDOCT. This field indicates the number of bytes received in good IPv6 datagrams encapsulating TCP  UDP  or ICMP data.  Ethernet header  FCS  pad  or IP pad bytes are not included in this counter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6gdoct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        Rxipv6GoodOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            Rxipv6GoodOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv6GoodOctets {
    #[inline(always)]
    fn default() -> Rxipv6GoodOctets {
        <crate::RegValueT<Rxipv6GoodOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv6GoodPackets_SPEC;
impl crate::sealed::RegSpec for Rxipv6GoodPackets_SPEC {
    type DataType = u32;
}
#[doc = "Good Received RxIPv6 Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv6GoodPackets = crate::RegValueT<Rxipv6GoodPackets_SPEC>;

impl Rxipv6GoodPackets {
    #[doc = "RxIPv6 Good Packets   RXIPV6GDPKT. This field indicates the number of good IPv6 datagrams received with the TCP  UDP  or ICMP payload. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6gdpkt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, Rxipv6GoodPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, Rxipv6GoodPackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for Rxipv6GoodPackets {
    #[inline(always)]
    fn default() -> Rxipv6GoodPackets {
        <crate::RegValueT<Rxipv6GoodPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv6HeaderErrorOctets_SPEC;
impl crate::sealed::RegSpec for Rxipv6HeaderErrorOctets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPV6 Header Error Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv6HeaderErrorOctets = crate::RegValueT<Rxipv6HeaderErrorOctets_SPEC>;

impl Rxipv6HeaderErrorOctets {
    #[doc = "RxIPv6 Header Error Octets   RXIPV6HDRERROCT. This field indicates the number of bytes received in IPv6 datagrams with header errors  length  version mismatch . The value in the Length field of IPv6 header is used to update this counter.  Ethernet header  FCS  pad  or IP pad bytes are not included in this counter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6hdrerroct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        Rxipv6HeaderErrorOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            Rxipv6HeaderErrorOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv6HeaderErrorOctets {
    #[inline(always)]
    fn default() -> Rxipv6HeaderErrorOctets {
        <crate::RegValueT<Rxipv6HeaderErrorOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv6HeaderErrorPackets_SPEC;
impl crate::sealed::RegSpec for Rxipv6HeaderErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPv6 Header Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv6HeaderErrorPackets = crate::RegValueT<Rxipv6HeaderErrorPackets_SPEC>;

impl Rxipv6HeaderErrorPackets {
    #[doc = "RxIPv6 Header Error Packets   RXIPV6HDRERRPKT. This field indicates the number of IPv6 datagrams received with header  length or version mismatch  errors. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6hdrerrpkt(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rxipv6HeaderErrorPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rxipv6HeaderErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv6HeaderErrorPackets {
    #[inline(always)]
    fn default() -> Rxipv6HeaderErrorPackets {
        <crate::RegValueT<Rxipv6HeaderErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv6NoPayloadOctets_SPEC;
impl crate::sealed::RegSpec for Rxipv6NoPayloadOctets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPV6 No Payload Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv6NoPayloadOctets = crate::RegValueT<Rxipv6NoPayloadOctets_SPEC>;

impl Rxipv6NoPayloadOctets {
    #[doc = "RxIPv6 Payload Octets   RXIPV6NOPAYOCT. This field indicates the number of bytes received in IPv6 datagrams that did not have a TCP  UDP  or ICMP payload. The value in the Length field of IPv6 header is used to update this counter.  Ethernet header  FCS  pad  or IP pad bytes are not included in this counter. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6nopayoct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        Rxipv6NoPayloadOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            Rxipv6NoPayloadOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv6NoPayloadOctets {
    #[inline(always)]
    fn default() -> Rxipv6NoPayloadOctets {
        <crate::RegValueT<Rxipv6NoPayloadOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rxipv6NoPayloadPackets_SPEC;
impl crate::sealed::RegSpec for Rxipv6NoPayloadPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received IPv6 No Payload Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rxipv6NoPayloadPackets = crate::RegValueT<Rxipv6NoPayloadPackets_SPEC>;

impl Rxipv6NoPayloadPackets {
    #[doc = "RxIPv6 Payload Packets   RXIPV6NOPAYPKT. This field indicates the number of IPv6 datagram packets received that did not have a TCP  UDP  or ICMP payload. This includes all IPv6 datagrams with fragmentation or security extension headers. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxipv6nopaypkt(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rxipv6NoPayloadPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rxipv6NoPayloadPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rxipv6NoPayloadPackets {
    #[inline(always)]
    fn default() -> Rxipv6NoPayloadPackets {
        <crate::RegValueT<Rxipv6NoPayloadPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxtcpErrorOctets_SPEC;
impl crate::sealed::RegSpec for RxtcpErrorOctets_SPEC {
    type DataType = u32;
}
#[doc = "Received TCP Error Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxtcpErrorOctets = crate::RegValueT<RxtcpErrorOctets_SPEC>;

impl RxtcpErrorOctets {
    #[doc = "RxTCP Error Octets   RXTCPERROCT. This field indicates the number of bytes received in a TCP segment that had checksum errors. This counter does not count IP header bytes. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcperroct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        RxtcpErrorOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            RxtcpErrorOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxtcpErrorOctets {
    #[inline(always)]
    fn default() -> RxtcpErrorOctets {
        <crate::RegValueT<RxtcpErrorOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxtcpErrorPackets_SPEC;
impl crate::sealed::RegSpec for RxtcpErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received TCP Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxtcpErrorPackets = crate::RegValueT<RxtcpErrorPackets_SPEC>;

impl RxtcpErrorPackets {
    #[doc = "RxTCP Error Packets   RXTCPERRPKT. This field indicates the number of good IP datagrams received whose TCP payload has a checksum error. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcperrpkt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxtcpErrorPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, RxtcpErrorPackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for RxtcpErrorPackets {
    #[inline(always)]
    fn default() -> RxtcpErrorPackets {
        <crate::RegValueT<RxtcpErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxtcpGoodOctets_SPEC;
impl crate::sealed::RegSpec for RxtcpGoodOctets_SPEC {
    type DataType = u32;
}
#[doc = "Good Received TCP Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxtcpGoodOctets = crate::RegValueT<RxtcpGoodOctets_SPEC>;

impl RxtcpGoodOctets {
    #[doc = "RxTCP Good Octets   RXTCPGDOCT. This field indicates the number of bytes received in a good TCP segment. This counter does not count IP header bytes. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcpgdoct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        RxtcpGoodOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            RxtcpGoodOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxtcpGoodOctets {
    #[inline(always)]
    fn default() -> RxtcpGoodOctets {
        <crate::RegValueT<RxtcpGoodOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxtcpGoodPackets_SPEC;
impl crate::sealed::RegSpec for RxtcpGoodPackets_SPEC {
    type DataType = u32;
}
#[doc = "Good Received TCP Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxtcpGoodPackets = crate::RegValueT<RxtcpGoodPackets_SPEC>;

impl RxtcpGoodPackets {
    #[doc = "RxTCP Good Packets   RXTCPGDPKT. This field indicates the number of good IP datagrams received with a good TCP payload. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxtcpgdpkt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxtcpGoodPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, RxtcpGoodPackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for RxtcpGoodPackets {
    #[inline(always)]
    fn default() -> RxtcpGoodPackets {
        <crate::RegValueT<RxtcpGoodPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxudpErrorOctets_SPEC;
impl crate::sealed::RegSpec for RxudpErrorOctets_SPEC {
    type DataType = u32;
}
#[doc = "Received UDP Error Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxudpErrorOctets = crate::RegValueT<RxudpErrorOctets_SPEC>;

impl RxudpErrorOctets {
    #[doc = "RxUDP Error Octets   RXUDPERROCT. This field indicates the number of bytes received in a UDP segment that had checksum errors. This counter does not count IP header bytes. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudperroct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        RxudpErrorOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            RxudpErrorOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxudpErrorOctets {
    #[inline(always)]
    fn default() -> RxudpErrorOctets {
        <crate::RegValueT<RxudpErrorOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxudpErrorPackets_SPEC;
impl crate::sealed::RegSpec for RxudpErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received UDP Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxudpErrorPackets = crate::RegValueT<RxudpErrorPackets_SPEC>;

impl RxudpErrorPackets {
    #[doc = "RxUDP Error Packets   RXUDPERRPKT. This field indicates the number of good IP datagrams received whose UDP payload has a checksum error. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudperrpkt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxudpErrorPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, RxudpErrorPackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for RxudpErrorPackets {
    #[inline(always)]
    fn default() -> RxudpErrorPackets {
        <crate::RegValueT<RxudpErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxudpGoodOctets_SPEC;
impl crate::sealed::RegSpec for RxudpGoodOctets_SPEC {
    type DataType = u32;
}
#[doc = "Good Received UDP Octets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxudpGoodOctets = crate::RegValueT<RxudpGoodOctets_SPEC>;

impl RxudpGoodOctets {
    #[doc = "RxUDP Good Octets   RXUDPGDOCT. This field indicates the number of bytes received in a good UDP segment. This counter does not count IP header bytes. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudpgdoct(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        RxudpGoodOctets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            RxudpGoodOctets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxudpGoodOctets {
    #[inline(always)]
    fn default() -> RxudpGoodOctets {
        <crate::RegValueT<RxudpGoodOctets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxudpGoodPackets_SPEC;
impl crate::sealed::RegSpec for RxudpGoodPackets_SPEC {
    type DataType = u32;
}
#[doc = "Good Received UDP Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxudpGoodPackets = crate::RegValueT<RxudpGoodPackets_SPEC>;

impl RxudpGoodPackets {
    #[doc = "RxUDP Good Packets   RXUDPGDPKT. This field indicates the number of good IP datagrams received with a good UDP payload. This counter is not updated when the RxIPv4 UDP Checksum Disabled Packets counter is incremented. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxudpgdpkt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxudpGoodPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, RxudpGoodPackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for RxudpGoodPackets {
    #[inline(always)]
    fn default() -> RxudpGoodPackets {
        <crate::RegValueT<RxudpGoodPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rx1024TomaxoctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Rx1024TomaxoctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 1024toMax Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rx1024TomaxoctetsPacketsGoodBad = crate::RegValueT<Rx1024TomaxoctetsPacketsGoodBad_SPEC>;

impl Rx1024TomaxoctetsPacketsGoodBad {
    #[doc = "Rx 1024 Max Octets Good Bad   RX1024 MAXOCTGB. This field indicates the number of good and bad packets received with length between 1024 and maxsize  inclusive  bytes  exclusive of the preamble. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx1024_maxoctgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rx1024TomaxoctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rx1024TomaxoctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rx1024TomaxoctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Rx1024TomaxoctetsPacketsGoodBad {
        <crate::RegValueT<Rx1024TomaxoctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rx128To255OctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Rx128To255OctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 128to255 Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rx128To255OctetsPacketsGoodBad = crate::RegValueT<Rx128To255OctetsPacketsGoodBad_SPEC>;

impl Rx128To255OctetsPacketsGoodBad {
    #[doc = "Rx 128 255 Octets Packets Good Bad   RX128 255OCTGB. This field indicates the number of good and bad packets received with length between 128 and 255  inclusive  bytes  exclusive of the preamble. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx128_255octgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rx128To255OctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rx128To255OctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rx128To255OctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Rx128To255OctetsPacketsGoodBad {
        <crate::RegValueT<Rx128To255OctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rx256To511OctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Rx256To511OctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 256to511 Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rx256To511OctetsPacketsGoodBad = crate::RegValueT<Rx256To511OctetsPacketsGoodBad_SPEC>;

impl Rx256To511OctetsPacketsGoodBad {
    #[doc = "Rx 256 511 Octets Packets Good Bad   RX256 511OCTGB. This field indicates the number of good and bad packets received with length between 256 and 511  inclusive  bytes  exclusive of the preamble. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx256_511octgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rx256To511OctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rx256To511OctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rx256To511OctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Rx256To511OctetsPacketsGoodBad {
        <crate::RegValueT<Rx256To511OctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rx512To1023OctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Rx512To1023OctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 512to1023 Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rx512To1023OctetsPacketsGoodBad = crate::RegValueT<Rx512To1023OctetsPacketsGoodBad_SPEC>;

impl Rx512To1023OctetsPacketsGoodBad {
    #[doc = "RX 512 1023 Octets Packets Good Bad   RX512 1023OCTGB. This field indicates the number of good and bad packets received with length between 512 and 1023  inclusive  bytes  exclusive of the preamble. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx512_1023octgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rx512To1023OctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rx512To1023OctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rx512To1023OctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Rx512To1023OctetsPacketsGoodBad {
        <crate::RegValueT<Rx512To1023OctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rx64OctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Rx64OctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 64 Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rx64OctetsPacketsGoodBad = crate::RegValueT<Rx64OctetsPacketsGoodBad_SPEC>;

impl Rx64OctetsPacketsGoodBad {
    #[doc = "Rx 64 Octets Packets Good Bad   RX64OCTGB. This field indicates the number of good and bad packets received with length 64 bytes  exclusive of the preamble. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx64octgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rx64OctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rx64OctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rx64OctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Rx64OctetsPacketsGoodBad {
        <crate::RegValueT<Rx64OctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Rx65To127OctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Rx65To127OctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 65to127 Octets Packets Received Count Register\n resetvalue={Application Reset:0x0}"]
pub type Rx65To127OctetsPacketsGoodBad = crate::RegValueT<Rx65To127OctetsPacketsGoodBad_SPEC>;

impl Rx65To127OctetsPacketsGoodBad {
    #[doc = "Rx 65 127 Octets Packets Good Bad   RX65 127OCTGB. This field indicates the number of good and bad packets received with length between 65 and 127  inclusive  bytes  exclusive of the preamble. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rx65_127octgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Rx65To127OctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Rx65To127OctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Rx65To127OctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Rx65To127OctetsPacketsGoodBad {
        <crate::RegValueT<Rx65To127OctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxAlignmentErrorPackets_SPEC;
impl crate::sealed::RegSpec for RxAlignmentErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received Alignment Error Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxAlignmentErrorPackets = crate::RegValueT<RxAlignmentErrorPackets_SPEC>;

impl RxAlignmentErrorPackets {
    #[doc = "Rx Alignment Error Packets   RXALGNERR. This field indicates the number of packets received with alignment  dribble  error. It is valid only in 10 100 mode. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxalgnerr(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxAlignmentErrorPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxAlignmentErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxAlignmentErrorPackets {
    #[inline(always)]
    fn default() -> RxAlignmentErrorPackets {
        <crate::RegValueT<RxAlignmentErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxBroadcastPacketsGood_SPEC;
impl crate::sealed::RegSpec for RxBroadcastPacketsGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Received Broadcast Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxBroadcastPacketsGood = crate::RegValueT<RxBroadcastPacketsGood_SPEC>;

impl RxBroadcastPacketsGood {
    #[doc = "Rx Broadcast Packets Good   RXBCASTG. This field indicates the number of good broadcast packets received. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxbcastg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxBroadcastPacketsGood_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxBroadcastPacketsGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxBroadcastPacketsGood {
    #[inline(always)]
    fn default() -> RxBroadcastPacketsGood {
        <crate::RegValueT<RxBroadcastPacketsGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxControlPacketsGood_SPEC;
impl crate::sealed::RegSpec for RxControlPacketsGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Received Control Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxControlPacketsGood = crate::RegValueT<RxControlPacketsGood_SPEC>;

impl RxControlPacketsGood {
    #[doc = "Rx Control Packets Good   RXCTRLG. This field indicates the number of good control packets received. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxctrlg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxControlPacketsGood_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxControlPacketsGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxControlPacketsGood {
    #[inline(always)]
    fn default() -> RxControlPacketsGood {
        <crate::RegValueT<RxControlPacketsGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxCrcErrorPackets_SPEC;
impl crate::sealed::RegSpec for RxCrcErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received CRC Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxCrcErrorPackets = crate::RegValueT<RxCrcErrorPackets_SPEC>;

impl RxCrcErrorPackets {
    #[doc = "Rx CRC Error Packets   RXCRCERR. This field indicates the number of packets received with CRC error. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxcrcerr(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxCrcErrorPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, RxCrcErrorPackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for RxCrcErrorPackets {
    #[inline(always)]
    fn default() -> RxCrcErrorPackets {
        <crate::RegValueT<RxCrcErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxFifoOverflowPackets_SPEC;
impl crate::sealed::RegSpec for RxFifoOverflowPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received FIFO Overflow Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxFifoOverflowPackets = crate::RegValueT<RxFifoOverflowPackets_SPEC>;

impl RxFifoOverflowPackets {
    #[doc = "Rx FIFO Overflow Packets   RXFIFOOVFL. This field indicates the number of missed received packets because of FIFO overflow. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxfifoovfl(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxFifoOverflowPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxFifoOverflowPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxFifoOverflowPackets {
    #[inline(always)]
    fn default() -> RxFifoOverflowPackets {
        <crate::RegValueT<RxFifoOverflowPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxJabberErrorPackets_SPEC;
impl crate::sealed::RegSpec for RxJabberErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received Jabber Error Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxJabberErrorPackets = crate::RegValueT<RxJabberErrorPackets_SPEC>;

impl RxJabberErrorPackets {
    #[doc = "Rx Jabber Error Packets   RXJABERR. This field indicates the number of giant packets received with length  including CRC  greater than 1 518 bytes  1 522 bytes for VLAN tagged  and with CRC error. If Jumbo Packet mode is enabled  packets of length greater than 9 018 bytes  9 022 bytes for VLAN tagged  are considered as giant packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxjaberr(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxJabberErrorPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxJabberErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxJabberErrorPackets {
    #[inline(always)]
    fn default() -> RxJabberErrorPackets {
        <crate::RegValueT<RxJabberErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxLengthErrorPackets_SPEC;
impl crate::sealed::RegSpec for RxLengthErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received Length Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxLengthErrorPackets = crate::RegValueT<RxLengthErrorPackets_SPEC>;

impl RxLengthErrorPackets {
    #[doc = "Rx Length Error Packets   RXLENERR. This field indicates the number of packets received with length error  Length Type field not equal to packet size   for all packets with valid length field. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxlenerr(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxLengthErrorPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxLengthErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxLengthErrorPackets {
    #[inline(always)]
    fn default() -> RxLengthErrorPackets {
        <crate::RegValueT<RxLengthErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxLpiTranCntr_SPEC;
impl crate::sealed::RegSpec for RxLpiTranCntr_SPEC {
    type DataType = u32;
}
#[doc = "Received LPI Transition Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxLpiTranCntr = crate::RegValueT<RxLpiTranCntr_SPEC>;

impl RxLpiTranCntr {
    #[doc = "Rx LPI Transition counter   RXLPITRC. This field indicates the number of times Rx LPI Entry has occurred. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxlpitrc(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxLpiTranCntr_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, RxLpiTranCntr_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for RxLpiTranCntr {
    #[inline(always)]
    fn default() -> RxLpiTranCntr {
        <crate::RegValueT<RxLpiTranCntr_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxLpiUsecCntr_SPEC;
impl crate::sealed::RegSpec for RxLpiUsecCntr_SPEC {
    type DataType = u32;
}
#[doc = "Received Microseconds LPI Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxLpiUsecCntr = crate::RegValueT<RxLpiUsecCntr_SPEC>;

impl RxLpiUsecCntr {
    #[doc = "Rx LPI Microseconds Counter   RXLPIUSC. This field indicates the number of microseconds Rx LPI is asserted. For every Rx LPI Entry and Exit  the Timer value can have an error of     1 microsecond. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxlpiusc(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxLpiUsecCntr_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, RxLpiUsecCntr_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for RxLpiUsecCntr {
    #[inline(always)]
    fn default() -> RxLpiUsecCntr {
        <crate::RegValueT<RxLpiUsecCntr_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxMulticastPacketsGood_SPEC;
impl crate::sealed::RegSpec for RxMulticastPacketsGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Received Multicast Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxMulticastPacketsGood = crate::RegValueT<RxMulticastPacketsGood_SPEC>;

impl RxMulticastPacketsGood {
    #[doc = "Rx Multicast Packets Good   RXMCASTG. This field indicates the number of good multicast packets received. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxmcastg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxMulticastPacketsGood_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxMulticastPacketsGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxMulticastPacketsGood {
    #[inline(always)]
    fn default() -> RxMulticastPacketsGood {
        <crate::RegValueT<RxMulticastPacketsGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxOctetCountGood_SPEC;
impl crate::sealed::RegSpec for RxOctetCountGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Received Octet Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxOctetCountGood = crate::RegValueT<RxOctetCountGood_SPEC>;

impl RxOctetCountGood {
    #[doc = "Rx Octet Count Good   RXOCTG. This field indicates the number of bytes received  exclusive of preamble  only in good packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxoctg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        RxOctetCountGood_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            RxOctetCountGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxOctetCountGood {
    #[inline(always)]
    fn default() -> RxOctetCountGood {
        <crate::RegValueT<RxOctetCountGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxOctetCountGoodBad_SPEC;
impl crate::sealed::RegSpec for RxOctetCountGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad Received Octet Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxOctetCountGoodBad = crate::RegValueT<RxOctetCountGoodBad_SPEC>;

impl RxOctetCountGoodBad {
    #[doc = "Rx Octet Count Good Bad   RXOCTGB. This field indicates the number of bytes received  exclusive of preamble  in good and bad packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxoctgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        RxOctetCountGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            RxOctetCountGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxOctetCountGoodBad {
    #[inline(always)]
    fn default() -> RxOctetCountGoodBad {
        <crate::RegValueT<RxOctetCountGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxOutOfRangeTypePackets_SPEC;
impl crate::sealed::RegSpec for RxOutOfRangeTypePackets_SPEC {
    type DataType = u32;
}
#[doc = "Received Out Of Range Type Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxOutOfRangeTypePackets = crate::RegValueT<RxOutOfRangeTypePackets_SPEC>;

impl RxOutOfRangeTypePackets {
    #[doc = "Rx Out of Range Type Packet   RXOUTOFRNG. This field indicates the number of packets received with length field not equal to the valid packet size  greater than 1 500 but less than 1 536 . Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxoutofrng(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxOutOfRangeTypePackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxOutOfRangeTypePackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxOutOfRangeTypePackets {
    #[inline(always)]
    fn default() -> RxOutOfRangeTypePackets {
        <crate::RegValueT<RxOutOfRangeTypePackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxOversizePacketsGood_SPEC;
impl crate::sealed::RegSpec for RxOversizePacketsGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Received Oversized Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxOversizePacketsGood = crate::RegValueT<RxOversizePacketsGood_SPEC>;

impl RxOversizePacketsGood {
    #[doc = "Rx Oversize Packets Good   RXOVERSZG. This field indicates the number of packets received without errors  with length greater than the maxsize  1 518 bytes or 1 522 bytes for VLAN tagged packets  2000 bytes if enabled in the S2KP bit of the MAC Configuration register . Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxoverszg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxOversizePacketsGood_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxOversizePacketsGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxOversizePacketsGood {
    #[inline(always)]
    fn default() -> RxOversizePacketsGood {
        <crate::RegValueT<RxOversizePacketsGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxPacketsCountGoodBad_SPEC;
impl crate::sealed::RegSpec for RxPacketsCountGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad Received Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxPacketsCountGoodBad = crate::RegValueT<RxPacketsCountGoodBad_SPEC>;

impl RxPacketsCountGoodBad {
    #[doc = "Rx Packets Count Good Bad   RXPKTGB. This field indicates the number of good and bad packets received. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxpktgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxPacketsCountGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxPacketsCountGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxPacketsCountGoodBad {
    #[inline(always)]
    fn default() -> RxPacketsCountGoodBad {
        <crate::RegValueT<RxPacketsCountGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxPausePackets_SPEC;
impl crate::sealed::RegSpec for RxPausePackets_SPEC {
    type DataType = u32;
}
#[doc = "Received Pause Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxPausePackets = crate::RegValueT<RxPausePackets_SPEC>;

impl RxPausePackets {
    #[doc = "Rx Pause Packets   RXPAUSEPKT. This field indicates the number of good and valid Pause packets received. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxpausepkt(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxPausePackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, RxPausePackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for RxPausePackets {
    #[inline(always)]
    fn default() -> RxPausePackets {
        <crate::RegValueT<RxPausePackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxReceiveErrorPackets_SPEC;
impl crate::sealed::RegSpec for RxReceiveErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received Receive Error Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxReceiveErrorPackets = crate::RegValueT<RxReceiveErrorPackets_SPEC>;

impl RxReceiveErrorPackets {
    #[doc = "Rx Receive Error Packets   RXRCVERR. This field indicates the number of packets received with Receive error or Packet Extension error on the GMII or MII interface. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxrcverr(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxReceiveErrorPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxReceiveErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxReceiveErrorPackets {
    #[inline(always)]
    fn default() -> RxReceiveErrorPackets {
        <crate::RegValueT<RxReceiveErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxRuntErrorPackets_SPEC;
impl crate::sealed::RegSpec for RxRuntErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received Runtime Error Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxRuntErrorPackets = crate::RegValueT<RxRuntErrorPackets_SPEC>;

impl RxRuntErrorPackets {
    #[doc = "Rx Runt Error Packets   RXRUNTERR. This field indicates the number of packets received with runt  length less than 64 bytes and CRC error  error. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxrunterr(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, RxRuntErrorPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxRuntErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxRuntErrorPackets {
    #[inline(always)]
    fn default() -> RxRuntErrorPackets {
        <crate::RegValueT<RxRuntErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxUndersizePacketsGood_SPEC;
impl crate::sealed::RegSpec for RxUndersizePacketsGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Received Undersized Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxUndersizePacketsGood = crate::RegValueT<RxUndersizePacketsGood_SPEC>;

impl RxUndersizePacketsGood {
    #[doc = "Rx Undersize Packets Good   RXUNDERSZG. This field indicates the number of packets received with length less than 64 bytes  without any errors. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxunderszg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxUndersizePacketsGood_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxUndersizePacketsGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxUndersizePacketsGood {
    #[inline(always)]
    fn default() -> RxUndersizePacketsGood {
        <crate::RegValueT<RxUndersizePacketsGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxUnicastPacketsGood_SPEC;
impl crate::sealed::RegSpec for RxUnicastPacketsGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Received Unicat Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxUnicastPacketsGood = crate::RegValueT<RxUnicastPacketsGood_SPEC>;

impl RxUnicastPacketsGood {
    #[doc = "Rx Unicast Packets Good   RXUCASTG. This field indicates the number of good unicast packets received. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxucastg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxUnicastPacketsGood_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxUnicastPacketsGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxUnicastPacketsGood {
    #[inline(always)]
    fn default() -> RxUnicastPacketsGood {
        <crate::RegValueT<RxUnicastPacketsGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxVlanPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for RxVlanPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad Received VLAN Packets Count Registerv\n resetvalue={Application Reset:0x0}"]
pub type RxVlanPacketsGoodBad = crate::RegValueT<RxVlanPacketsGoodBad_SPEC>;

impl RxVlanPacketsGoodBad {
    #[doc = "Rx VLAN Packets Good Bad   RXVLANPKTGB. This field indicates the number of good and bad VLAN packets received. Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxvlanpktgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxVlanPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxVlanPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxVlanPacketsGoodBad {
    #[inline(always)]
    fn default() -> RxVlanPacketsGoodBad {
        <crate::RegValueT<RxVlanPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct RxWatchdogErrorPackets_SPEC;
impl crate::sealed::RegSpec for RxWatchdogErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Received Watchdog Error Count Register\n resetvalue={Application Reset:0x0}"]
pub type RxWatchdogErrorPackets = crate::RegValueT<RxWatchdogErrorPackets_SPEC>;

impl RxWatchdogErrorPackets {
    #[doc = "Rx Watchdog Error Packets   RXWDGERR. This field indicates the number of packets received with error because of watchdog timeout error  packets with a data load larger than 2 048 bytes  when JE and WD bits are reset in MAC Configuration register   10 240 bytes  when JE bit is set and WD bit is reset in MAC Configuration register   16 384 bytes  when WD bit is set in MAC Configuration register  or the value programmed in the MAC Watchdog Timeout register . Value After Reset  0x0"]
    #[inline(always)]
    pub fn rxwdgerr(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        RxWatchdogErrorPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            RxWatchdogErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for RxWatchdogErrorPackets {
    #[inline(always)]
    fn default() -> RxWatchdogErrorPackets {
        <crate::RegValueT<RxWatchdogErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Skewctl_SPEC;
impl crate::sealed::RegSpec for Skewctl_SPEC {
    type DataType = u32;
}
#[doc = "Skew Control Register\n resetvalue={Application Reset:0x0}"]
pub type Skewctl = crate::RegValueT<Skewctl_SPEC>;

impl Skewctl {
    #[doc = "TX Clock delay control for RGMII Mode   TXCFG. Used to specify the receive timing skew in RGMII mode using integrated        delay generation on TXCLK. In MII and RMII mode  this is not active.        Skew is  TXCFG   222 22  ps. If cleared  skew is 0  default  skew        generation switched off ."]
    #[inline(always)]
    pub fn txcfg(
        self,
    ) -> crate::common::RegisterField<0, 0xf, 1, 0, u8, Skewctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<0,0xf,1,0,u8, Skewctl_SPEC,crate::common::RW>::from_register(self,0)
    }
    #[doc = "RX Clock delay control for RGMII Mode   RXCFG. Used to specify the receive timing skew in RGMII mode using integrated        delay generation on RXCLK. In MII and RMII mode  this is not active.        Skew is  RXCFG   222 22  ps. If cleared  skew is 0  default  skew        generation switched off ."]
    #[inline(always)]
    pub fn rxcfg(
        self,
    ) -> crate::common::RegisterField<8, 0xf, 1, 0, u8, Skewctl_SPEC, crate::common::RW> {
        crate::common::RegisterField::<8,0xf,1,0,u8, Skewctl_SPEC,crate::common::RW>::from_register(self,0)
    }
}
impl core::default::Default for Skewctl {
    #[inline(always)]
    fn default() -> Skewctl {
        <crate::RegValueT<Skewctl_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Tx1024TomaxoctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Tx1024TomaxoctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 1024toMax Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
pub type Tx1024TomaxoctetsPacketsGoodBad = crate::RegValueT<Tx1024TomaxoctetsPacketsGoodBad_SPEC>;

impl Tx1024TomaxoctetsPacketsGoodBad {
    #[doc = "Tx 1024ToMaxOctets Packets Good Bad   TX1024 MAXOCTGB. This field indicates the number of good and bad packets transmitted with length between 1024 and maxsize  inclusive  bytes  exclusive of preamble and retried packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx1024_maxoctgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Tx1024TomaxoctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Tx1024TomaxoctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Tx1024TomaxoctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Tx1024TomaxoctetsPacketsGoodBad {
        <crate::RegValueT<Tx1024TomaxoctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Tx128To255OctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Tx128To255OctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 128to255 Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
pub type Tx128To255OctetsPacketsGoodBad = crate::RegValueT<Tx128To255OctetsPacketsGoodBad_SPEC>;

impl Tx128To255OctetsPacketsGoodBad {
    #[doc = "Tx 128To255Octets Packets Good Bad   TX128 255OCTGB. This field indicates the number of good and bad packets transmitted with length between 128 and 255  inclusive  bytes  exclusive of preamble and retried packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx128_255octgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Tx128To255OctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Tx128To255OctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Tx128To255OctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Tx128To255OctetsPacketsGoodBad {
        <crate::RegValueT<Tx128To255OctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Tx256To511OctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Tx256To511OctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 256to511 Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
pub type Tx256To511OctetsPacketsGoodBad = crate::RegValueT<Tx256To511OctetsPacketsGoodBad_SPEC>;

impl Tx256To511OctetsPacketsGoodBad {
    #[doc = "Tx 256To511Octets Packets Good Bad   TX256 511OCTGB. This field indicates the number of good and bad packets transmitted with length between 256 and 511  inclusive  bytes  exclusive of preamble and retried packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx256_511octgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Tx256To511OctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Tx256To511OctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Tx256To511OctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Tx256To511OctetsPacketsGoodBad {
        <crate::RegValueT<Tx256To511OctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Tx512To1023OctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Tx512To1023OctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 512to1023 Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
pub type Tx512To1023OctetsPacketsGoodBad = crate::RegValueT<Tx512To1023OctetsPacketsGoodBad_SPEC>;

impl Tx512To1023OctetsPacketsGoodBad {
    #[doc = "Tx 512To1023Octets Packets Good Bad   TX512 1023OCTGB. This field indicates the number of good and bad packets transmitted with length between 512 and 1023  inclusive  bytes  exclusive of preamble and retried packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx512_1023octgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Tx512To1023OctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Tx512To1023OctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Tx512To1023OctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Tx512To1023OctetsPacketsGoodBad {
        <crate::RegValueT<Tx512To1023OctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Tx64OctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Tx64OctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 64 Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
pub type Tx64OctetsPacketsGoodBad = crate::RegValueT<Tx64OctetsPacketsGoodBad_SPEC>;

impl Tx64OctetsPacketsGoodBad {
    #[doc = "Tx 64Octets Packets Good Bad   TX64OCTGB. This field indicates the number of good and bad packets transmitted with length 64 bytes  exclusive of preamble and retried packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx64octgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Tx64OctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Tx64OctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Tx64OctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Tx64OctetsPacketsGoodBad {
        <crate::RegValueT<Tx64OctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Tx65To127OctetsPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for Tx65To127OctetsPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad 65to127 Octets Packets Transmitted Count Register\n resetvalue={Application Reset:0x0}"]
pub type Tx65To127OctetsPacketsGoodBad = crate::RegValueT<Tx65To127OctetsPacketsGoodBad_SPEC>;

impl Tx65To127OctetsPacketsGoodBad {
    #[doc = "Tx 65To127Octets Packets Good Bad   TX65 127OCTGB. This field indicates the number of good and bad packets transmitted with length between 65 and 127  inclusive  bytes  exclusive of preamble and retried packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn tx65_127octgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        Tx65To127OctetsPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            Tx65To127OctetsPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for Tx65To127OctetsPacketsGoodBad {
    #[inline(always)]
    fn default() -> Tx65To127OctetsPacketsGoodBad {
        <crate::RegValueT<Tx65To127OctetsPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxBroadcastPacketsGood_SPEC;
impl crate::sealed::RegSpec for TxBroadcastPacketsGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Transmitted Broadcast Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxBroadcastPacketsGood = crate::RegValueT<TxBroadcastPacketsGood_SPEC>;

impl TxBroadcastPacketsGood {
    #[doc = "Tx Broadcast Packets Good   TXBCASTG. This field indicates the number of good broadcast packets transmitted. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txbcastg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxBroadcastPacketsGood_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxBroadcastPacketsGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxBroadcastPacketsGood {
    #[inline(always)]
    fn default() -> TxBroadcastPacketsGood {
        <crate::RegValueT<TxBroadcastPacketsGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxBroadcastPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for TxBroadcastPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad Transmitted Broadcast Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxBroadcastPacketsGoodBad = crate::RegValueT<TxBroadcastPacketsGoodBad_SPEC>;

impl TxBroadcastPacketsGoodBad {
    #[doc = "Tx Broadcast Packets Good Bad   TXBCASTGB. This field indicates the number of good and bad broadcast packets transmitted. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txbcastgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxBroadcastPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxBroadcastPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxBroadcastPacketsGoodBad {
    #[inline(always)]
    fn default() -> TxBroadcastPacketsGoodBad {
        <crate::RegValueT<TxBroadcastPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxCarrierErrorPackets_SPEC;
impl crate::sealed::RegSpec for TxCarrierErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Transmitted Carrier Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxCarrierErrorPackets = crate::RegValueT<TxCarrierErrorPackets_SPEC>;

impl TxCarrierErrorPackets {
    #[doc = "Tx Carrier Error Packets   TXCARR. This field indicates the number of packets aborted because of carrier sense error  no carrier or loss of carrier . Value After Reset  0x0"]
    #[inline(always)]
    pub fn txcarr(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxCarrierErrorPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxCarrierErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxCarrierErrorPackets {
    #[inline(always)]
    fn default() -> TxCarrierErrorPackets {
        <crate::RegValueT<TxCarrierErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxDeferredPackets_SPEC;
impl crate::sealed::RegSpec for TxDeferredPackets_SPEC {
    type DataType = u32;
}
#[doc = "Transmitted Deferred Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxDeferredPackets = crate::RegValueT<TxDeferredPackets_SPEC>;

impl TxDeferredPackets {
    #[doc = "Tx Deferred Packets   TXDEFRD. This field indicates the number of successfully transmitted after a deferral in the half duplex mode. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txdefrd(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, TxDeferredPackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, TxDeferredPackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for TxDeferredPackets {
    #[inline(always)]
    fn default() -> TxDeferredPackets {
        <crate::RegValueT<TxDeferredPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxExcessiveCollisionPackets_SPEC;
impl crate::sealed::RegSpec for TxExcessiveCollisionPackets_SPEC {
    type DataType = u32;
}
#[doc = "Transmitted Excessive Collision Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxExcessiveCollisionPackets = crate::RegValueT<TxExcessiveCollisionPackets_SPEC>;

impl TxExcessiveCollisionPackets {
    #[doc = "Tx Excessive Collision Packets   TXEXSCOL. This field indicates the number of packets aborted because of excessive  16  collision errors. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txexscol(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxExcessiveCollisionPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxExcessiveCollisionPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxExcessiveCollisionPackets {
    #[inline(always)]
    fn default() -> TxExcessiveCollisionPackets {
        <crate::RegValueT<TxExcessiveCollisionPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxExcessiveDeferralError_SPEC;
impl crate::sealed::RegSpec for TxExcessiveDeferralError_SPEC {
    type DataType = u32;
}
#[doc = "Transmitted Excessive Deferral Error Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxExcessiveDeferralError = crate::RegValueT<TxExcessiveDeferralError_SPEC>;

impl TxExcessiveDeferralError {
    #[doc = "Tx Excessive Deferral Error   TXEXSDEF. This field indicates the number of packets aborted because of excessive deferral error  deferred for more than two max sized packet times . Value After Reset  0x0"]
    #[inline(always)]
    pub fn txexsdef(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxExcessiveDeferralError_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxExcessiveDeferralError_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxExcessiveDeferralError {
    #[inline(always)]
    fn default() -> TxExcessiveDeferralError {
        <crate::RegValueT<TxExcessiveDeferralError_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxLateCollisionPackets_SPEC;
impl crate::sealed::RegSpec for TxLateCollisionPackets_SPEC {
    type DataType = u32;
}
#[doc = "Transmitted Late Collision Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxLateCollisionPackets = crate::RegValueT<TxLateCollisionPackets_SPEC>;

impl TxLateCollisionPackets {
    #[doc = "Tx Late Collision Packets   TXLATECOL. This field indicates the number of packets aborted because of late collision error. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txlatecol(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxLateCollisionPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxLateCollisionPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxLateCollisionPackets {
    #[inline(always)]
    fn default() -> TxLateCollisionPackets {
        <crate::RegValueT<TxLateCollisionPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxLpiTranCntr_SPEC;
impl crate::sealed::RegSpec for TxLpiTranCntr_SPEC {
    type DataType = u32;
}
#[doc = "Transmitted LPI Transition Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxLpiTranCntr = crate::RegValueT<TxLpiTranCntr_SPEC>;

impl TxLpiTranCntr {
    #[doc = "Tx LPI Transition counter   TXLPITRC. This field indicates the number of times Tx LPI Entry has occurred. Even if Tx LPI Entry occurs in Automate Mode  because of LPITXA bit set in the LPI Control and Status register   the counter will increment. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txlpitrc(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, TxLpiTranCntr_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, TxLpiTranCntr_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for TxLpiTranCntr {
    #[inline(always)]
    fn default() -> TxLpiTranCntr {
        <crate::RegValueT<TxLpiTranCntr_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxLpiUsecCntr_SPEC;
impl crate::sealed::RegSpec for TxLpiUsecCntr_SPEC {
    type DataType = u32;
}
#[doc = "Transmitted LPI Microseconds Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxLpiUsecCntr = crate::RegValueT<TxLpiUsecCntr_SPEC>;

impl TxLpiUsecCntr {
    #[doc = "Tx LPI Microseconds Counter   TXLPIUSC. This field indicates the number of microseconds Tx LPI is asserted. For every Tx LPI Entry and Exit  the Timer value can have an error of     1 microsecond. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txlpiusc(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, TxLpiUsecCntr_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, TxLpiUsecCntr_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for TxLpiUsecCntr {
    #[inline(always)]
    fn default() -> TxLpiUsecCntr {
        <crate::RegValueT<TxLpiUsecCntr_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxMulticastPacketsGood_SPEC;
impl crate::sealed::RegSpec for TxMulticastPacketsGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Transmitted Multicast Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxMulticastPacketsGood = crate::RegValueT<TxMulticastPacketsGood_SPEC>;

impl TxMulticastPacketsGood {
    #[doc = "Tx Multicast Packets Good   TXMCASTG. This field indicates the number of good multicast packets transmitted. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txmcastg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxMulticastPacketsGood_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxMulticastPacketsGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxMulticastPacketsGood {
    #[inline(always)]
    fn default() -> TxMulticastPacketsGood {
        <crate::RegValueT<TxMulticastPacketsGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxMulticastPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for TxMulticastPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad Transmitted Multicast Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxMulticastPacketsGoodBad = crate::RegValueT<TxMulticastPacketsGoodBad_SPEC>;

impl TxMulticastPacketsGoodBad {
    #[doc = "Tx Multicast Packets Good Bad   TXMCASTGB. This field indicates the number of good and bad multicast packets transmitted. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txmcastgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxMulticastPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxMulticastPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxMulticastPacketsGoodBad {
    #[inline(always)]
    fn default() -> TxMulticastPacketsGoodBad {
        <crate::RegValueT<TxMulticastPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxMultipleCollisionGoodPackets_SPEC;
impl crate::sealed::RegSpec for TxMultipleCollisionGoodPackets_SPEC {
    type DataType = u32;
}
#[doc = "Transmitted Multiple Collision Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxMultipleCollisionGoodPackets = crate::RegValueT<TxMultipleCollisionGoodPackets_SPEC>;

impl TxMultipleCollisionGoodPackets {
    #[doc = "Tx Multiple Collision Good Packets   TXMULTCOLG. This field indicates the number of successfully transmitted packets after multiple collisions in the half duplex mode. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txmultcolg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxMultipleCollisionGoodPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxMultipleCollisionGoodPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxMultipleCollisionGoodPackets {
    #[inline(always)]
    fn default() -> TxMultipleCollisionGoodPackets {
        <crate::RegValueT<TxMultipleCollisionGoodPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxOctetCountGood_SPEC;
impl crate::sealed::RegSpec for TxOctetCountGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Transmitted Octet Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxOctetCountGood = crate::RegValueT<TxOctetCountGood_SPEC>;

impl TxOctetCountGood {
    #[doc = "Tx Octet Count Good   TXOCTG. This field indicates the number of bytes transmitted  exclusive of preamble  only in good packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txoctg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        TxOctetCountGood_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            TxOctetCountGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxOctetCountGood {
    #[inline(always)]
    fn default() -> TxOctetCountGood {
        <crate::RegValueT<TxOctetCountGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxOctetCountGoodBad_SPEC;
impl crate::sealed::RegSpec for TxOctetCountGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad Transmitted Octet Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxOctetCountGoodBad = crate::RegValueT<TxOctetCountGoodBad_SPEC>;

impl TxOctetCountGoodBad {
    #[doc = "Tx Octet Count Good Bad   TXOCTGB. This field indicates the number of bytes transmitted  exclusive of preamble and retried bytes  in good and bad packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txoctgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffffffff,
        1,
        0,
        u32,
        TxOctetCountGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffffffff,
            1,
            0,
            u32,
            TxOctetCountGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxOctetCountGoodBad {
    #[inline(always)]
    fn default() -> TxOctetCountGoodBad {
        <crate::RegValueT<TxOctetCountGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxOsizePacketsGood_SPEC;
impl crate::sealed::RegSpec for TxOsizePacketsGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Transmitted Osize Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxOsizePacketsGood = crate::RegValueT<TxOsizePacketsGood_SPEC>;

impl TxOsizePacketsGood {
    #[doc = "Tx OSize Packets Good   TXOSIZG. This field indicates the number of packets transmitted without errors and with length greater than the maxsize  1 518 or 1 522 bytes for VLAN tagged packets  2000 bytes if enabled in S2KP bit of the MAC Configuration register . Value After Reset  0x0"]
    #[inline(always)]
    pub fn txosizg(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, TxOsizePacketsGood_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxOsizePacketsGood_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxOsizePacketsGood {
    #[inline(always)]
    fn default() -> TxOsizePacketsGood {
        <crate::RegValueT<TxOsizePacketsGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxPacketCountGood_SPEC;
impl crate::sealed::RegSpec for TxPacketCountGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Transmitted Packet Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxPacketCountGood = crate::RegValueT<TxPacketCountGood_SPEC>;

impl TxPacketCountGood {
    #[doc = "Tx Packet Count Good   TXPKTG. This field indicates the number of good packets transmitted. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txpktg(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, TxPacketCountGood_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, TxPacketCountGood_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for TxPacketCountGood {
    #[inline(always)]
    fn default() -> TxPacketCountGood {
        <crate::RegValueT<TxPacketCountGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxPacketCountGoodBad_SPEC;
impl crate::sealed::RegSpec for TxPacketCountGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good And Bad Transmitted Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxPacketCountGoodBad = crate::RegValueT<TxPacketCountGoodBad_SPEC>;

impl TxPacketCountGoodBad {
    #[doc = "Tx Packet Count Good Bad   TXPKTGB. This field indicates the number of good and bad packets transmitted  exclusive of retried packets. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txpktgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxPacketCountGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxPacketCountGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxPacketCountGoodBad {
    #[inline(always)]
    fn default() -> TxPacketCountGoodBad {
        <crate::RegValueT<TxPacketCountGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxPausePackets_SPEC;
impl crate::sealed::RegSpec for TxPausePackets_SPEC {
    type DataType = u32;
}
#[doc = "Transmitted Pause Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxPausePackets = crate::RegValueT<TxPausePackets_SPEC>;

impl TxPausePackets {
    #[doc = "Tx Pause Packets   TXPAUSE. This field indicates the number of good Pause packets transmitted. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txpause(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, TxPausePackets_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, TxPausePackets_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for TxPausePackets {
    #[inline(always)]
    fn default() -> TxPausePackets {
        <crate::RegValueT<TxPausePackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxSingleCollisionGoodPackets_SPEC;
impl crate::sealed::RegSpec for TxSingleCollisionGoodPackets_SPEC {
    type DataType = u32;
}
#[doc = "Good Transmitted Single Collision Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxSingleCollisionGoodPackets = crate::RegValueT<TxSingleCollisionGoodPackets_SPEC>;

impl TxSingleCollisionGoodPackets {
    #[doc = "Tx Single Collision Good Packets   TXSNGLCOLG. This field indicates the number of successfully transmitted packets after a single collision in the half duplex mode. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txsnglcolg(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxSingleCollisionGoodPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxSingleCollisionGoodPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxSingleCollisionGoodPackets {
    #[inline(always)]
    fn default() -> TxSingleCollisionGoodPackets {
        <crate::RegValueT<TxSingleCollisionGoodPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxUnderflowErrorPackets_SPEC;
impl crate::sealed::RegSpec for TxUnderflowErrorPackets_SPEC {
    type DataType = u32;
}
#[doc = "Transmitted Underflow Error Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxUnderflowErrorPackets = crate::RegValueT<TxUnderflowErrorPackets_SPEC>;

impl TxUnderflowErrorPackets {
    #[doc = "Tx Underflow Error Packets   TXUNDRFLW. This field indicates the number of packets aborted because of packets underflow error. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txundrflw(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxUnderflowErrorPackets_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxUnderflowErrorPackets_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxUnderflowErrorPackets {
    #[inline(always)]
    fn default() -> TxUnderflowErrorPackets {
        <crate::RegValueT<TxUnderflowErrorPackets_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxUnicastPacketsGoodBad_SPEC;
impl crate::sealed::RegSpec for TxUnicastPacketsGoodBad_SPEC {
    type DataType = u32;
}
#[doc = "Good Transmitted Unicat Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxUnicastPacketsGoodBad = crate::RegValueT<TxUnicastPacketsGoodBad_SPEC>;

impl TxUnicastPacketsGoodBad {
    #[doc = "Tx Unicast Packets Good Bad   TXUCASTGB. This field indicates the number of good and bad unicast packets transmitted. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txucastgb(
        self,
    ) -> crate::common::RegisterField<
        0,
        0xffff,
        1,
        0,
        u16,
        TxUnicastPacketsGoodBad_SPEC,
        crate::common::R,
    > {
        crate::common::RegisterField::<
            0,
            0xffff,
            1,
            0,
            u16,
            TxUnicastPacketsGoodBad_SPEC,
            crate::common::R,
        >::from_register(self, 0)
    }
}
impl core::default::Default for TxUnicastPacketsGoodBad {
    #[inline(always)]
    fn default() -> TxUnicastPacketsGoodBad {
        <crate::RegValueT<TxUnicastPacketsGoodBad_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc(hidden)]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct TxVlanPacketsGood_SPEC;
impl crate::sealed::RegSpec for TxVlanPacketsGood_SPEC {
    type DataType = u32;
}
#[doc = "Good Transmitted VLAN Packets Count Register\n resetvalue={Application Reset:0x0}"]
pub type TxVlanPacketsGood = crate::RegValueT<TxVlanPacketsGood_SPEC>;

impl TxVlanPacketsGood {
    #[doc = "Tx VLAN Packets Good   TXVLANG. This field provides the number of good VLAN packets transmitted. Value After Reset  0x0"]
    #[inline(always)]
    pub fn txvlang(
        self,
    ) -> crate::common::RegisterField<0, 0xffff, 1, 0, u16, TxVlanPacketsGood_SPEC, crate::common::R>
    {
        crate::common::RegisterField::<0,0xffff,1,0,u16, TxVlanPacketsGood_SPEC,crate::common::R>::from_register(self,0)
    }
}
impl core::default::Default for TxVlanPacketsGood {
    #[inline(always)]
    fn default() -> TxVlanPacketsGood {
        <crate::RegValueT<TxVlanPacketsGood_SPEC> as RegisterValue<_>>::new(0)
    }
}

#[doc = "ACCEND"]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct Accend(pub(super) *mut u8);
unsafe impl core::marker::Send for Accend {}
unsafe impl core::marker::Sync for Accend {}
impl Accend {
    #[doc = "Access Enable Register 0 for DMA0\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    #[inline(always)]
    pub const fn accen0dx(&self) -> crate::common::Reg<accend::Accen0Dx_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(0usize)) }
    }
}
pub mod accend {
    #[allow(unused_imports)]
    use crate::common::*;
    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Accen0Dx_SPEC;
    impl crate::sealed::RegSpec for Accen0Dx_SPEC {
        type DataType = u32;
    }
    #[doc = "Access Enable Register 0 for DMA0\n resetvalue={Application Reset:0x0FFFFFFFF}"]
    pub type Accen0Dx = crate::RegValueT<Accen0Dx_SPEC>;

    impl Accen0Dx {
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en0(
            self,
        ) -> crate::common::RegisterFieldBool<0, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<0,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en1(
            self,
        ) -> crate::common::RegisterFieldBool<1, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<1,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en2(
            self,
        ) -> crate::common::RegisterFieldBool<2, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<2,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en3(
            self,
        ) -> crate::common::RegisterFieldBool<3, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<3,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en4(
            self,
        ) -> crate::common::RegisterFieldBool<4, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<4,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en5(
            self,
        ) -> crate::common::RegisterFieldBool<5, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<5,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en6(
            self,
        ) -> crate::common::RegisterFieldBool<6, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<6,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en7(
            self,
        ) -> crate::common::RegisterFieldBool<7, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<7,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en8(
            self,
        ) -> crate::common::RegisterFieldBool<8, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<8,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en9(
            self,
        ) -> crate::common::RegisterFieldBool<9, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<9,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en10(
            self,
        ) -> crate::common::RegisterFieldBool<10, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<10,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en11(
            self,
        ) -> crate::common::RegisterFieldBool<11, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<11,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en12(
            self,
        ) -> crate::common::RegisterFieldBool<12, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<12,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en13(
            self,
        ) -> crate::common::RegisterFieldBool<13, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<13,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en14(
            self,
        ) -> crate::common::RegisterFieldBool<14, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<14,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en15(
            self,
        ) -> crate::common::RegisterFieldBool<15, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<15,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en16(
            self,
        ) -> crate::common::RegisterFieldBool<16, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<16,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en17(
            self,
        ) -> crate::common::RegisterFieldBool<17, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<17,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en18(
            self,
        ) -> crate::common::RegisterFieldBool<18, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<18,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en19(
            self,
        ) -> crate::common::RegisterFieldBool<19, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<19,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en20(
            self,
        ) -> crate::common::RegisterFieldBool<20, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<20,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en21(
            self,
        ) -> crate::common::RegisterFieldBool<21, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<21,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en22(
            self,
        ) -> crate::common::RegisterFieldBool<22, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<22,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en23(
            self,
        ) -> crate::common::RegisterFieldBool<23, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<23,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en24(
            self,
        ) -> crate::common::RegisterFieldBool<24, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<24,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en25(
            self,
        ) -> crate::common::RegisterFieldBool<25, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<25,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en26(
            self,
        ) -> crate::common::RegisterFieldBool<26, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<26,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en27(
            self,
        ) -> crate::common::RegisterFieldBool<27, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<27,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en28(
            self,
        ) -> crate::common::RegisterFieldBool<28, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<28,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en29(
            self,
        ) -> crate::common::RegisterFieldBool<29, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<29,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en30(
            self,
        ) -> crate::common::RegisterFieldBool<30, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<30,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Access Enable for Master TAG ID 31   EN31. This bit enables write access to the module kernel addresses for        transactions with the Master TAG ID n If the I O Test Mode of RGMII interface is active  i.e. TEN bit in        MAC TEST register is set to   8217 1  8217    write access to all ACCEN0Dx registers        and from all master TAG IDs will be permanently enabled  including those        which are controlled by ACCENx registers . In this case the ACCEN0Dx        register bits will be reused to define the RGMII TD RD loop test        sequence as follows  ACCEN0D0.bit 15 0   16 bit test sequence for TXD0   gt  RXD0        ACCEN0D0.bit 31 16   16 bit test sequence for TXD1   gt  RXD1        ACCEN0D1.bit 15 0   16 bit test sequence for TXD2   gt  RXD2        ACCEN0D1.bit 31 16   16 bit test sequence for TXD3   gt  RXD3        ACCEN0D2.bit 15 0   16 bit test sequence for TXCLK   gt  RXCLK        ACCEN0D2.bit 31 16   16 bit test sequence for TCTL   gt  RCTL        ACCEN0D3.bit 15 0   no function ACCEN0D3.bit 31 16   no function LSB value will be applied first  MSB last in the 16 bit test data test        sequence. The value of all ACCEND0x registers shall remain stable while a RGMII IF        test operation is underway  i.e. if MAC TEST.BUSY is set to  1  ."]
        #[inline(always)]
        pub fn en31(
            self,
        ) -> crate::common::RegisterFieldBool<31, 1, 0, Accen0Dx_SPEC, crate::common::RW> {
            crate::common::RegisterFieldBool::<31,1,0,Accen0Dx_SPEC,crate::common::RW>::from_register(self,0)
        }
    }
    impl core::default::Default for Accen0Dx {
        #[inline(always)]
        fn default() -> Accen0Dx {
            <crate::RegValueT<Accen0Dx_SPEC> as RegisterValue<_>>::new(4294967295)
        }
    }
}
#[doc = "DMA CH"]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct DmaCh(pub(super) *mut u8);
unsafe impl core::marker::Send for DmaCh {}
unsafe impl core::marker::Sync for DmaCh {}
impl DmaCh {
    #[doc = "DMA Channel 0 Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_control(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiControl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(0usize)) }
    }
    #[doc = "DMA Channel 0 Current Application Receive Buffer Address Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_current_app_rxbuffer(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiCurrentAppRxbuffer_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(92usize)) }
    }
    #[doc = "DMA Channel 0 Current Application Receive Descriptor Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_current_app_rxdesc(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiCurrentAppRxdesc_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(76usize)) }
    }
    #[doc = "DMA Channel 0 Current Application Transmit Buffer Address Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_current_app_txbuffer(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiCurrentAppTxbuffer_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(84usize)) }
    }
    #[doc = "DMA Channel 0 Current Application Transmit Descriptor Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_current_app_txdesc(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiCurrentAppTxdesc_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(68usize)) }
    }
    #[doc = "DMA Channel 0 Interrupt Enable Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_interrupt_enable(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiInterruptEnable_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(52usize)) }
    }
    #[doc = "DMA Channel 0 Missed Frames Count Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_miss_frame_cnt(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiMissFrameCnt_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(100usize)) }
    }
    #[doc = "DMA Channel 0 Receive Descriptor List Address Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_rxdesc_list_address(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiRxdescListAddress_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(28usize)) }
    }
    #[doc = "DMA Channel 0 Recieve Descriptor Ring Length Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_rxdesc_ring_length(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiRxdescRingLength_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(48usize)) }
    }
    #[doc = "DMA Channel 0 Recieve Descriptor Tail Pointer Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_rxdesc_tail_pointer(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiRxdescTailPointer_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(40usize)) }
    }
    #[doc = "DMA Channel 0 Receive Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_rx_control(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiRxControl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8usize)) }
    }
    #[doc = "DMA Channel 0 Recieve Interrupt Watchdog Timer Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_rx_interrupt_watchdog_timer(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiRxInterruptWatchdogTimer_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(56usize)) }
    }
    #[doc = "DMA Channel 0 Slot Function Control and Status Register\n resetvalue={Application Reset:0x7C0}"]
    #[inline(always)]
    pub const fn dma_chi_slot_function_control_status(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiSlotFunctionControlStatus_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(60usize)) }
    }
    #[doc = "DMA Channel 0 Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_status(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiStatus_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(96usize)) }
    }
    #[doc = "DMA Channel 0 Transmit Descriptor List Address Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_txdesc_list_address(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiTxdescListAddress_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(20usize)) }
    }
    #[doc = "DMA Channel 0 Transmit Descriptor Ring Length Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_txdesc_ring_length(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiTxdescRingLength_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(44usize)) }
    }
    #[doc = "DMA Channel 0 Transmit Descriptor Tail Pointer Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_txdesc_tail_pointer(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiTxdescTailPointer_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(32usize)) }
    }
    #[doc = "DMA Channel 0 Transmit Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn dma_chi_tx_control(
        &self,
    ) -> crate::common::Reg<dma_ch::DmaCHiTxControl_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(4usize)) }
    }
}
pub mod dma_ch {
    #[allow(unused_imports)]
    use crate::common::*;
    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiControl_SPEC;
    impl crate::sealed::RegSpec for DmaCHiControl_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Control Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiControl = crate::RegValueT<DmaCHiControl_SPEC>;

    impl DmaCHiControl {
        #[doc = "8xPBL mode   PBLx8. When this bit is set  the PBL value programmed in Bits 21 16  in        DMA CH0 Tx Control and Bits 21 16  in DMA CH0 Rx Control is multiplied        by eight times. Therefore  the DMA transfers the data in 8  16  32  64         128  and 256 beats depending on the PBL value. Value After Reset  0x0"]
        #[inline(always)]
        pub fn pblx8(
            self,
        ) -> crate::common::RegisterFieldBool<16, 1, 0, DmaCHiControl_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<16,1,0,DmaCHiControl_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Descriptor Skip Length   DSL. This bit specifies the Word  Dword  or Lword number  depending on the 32 bit  64 bit  or 128 bit bus  to skip between two unchained descriptors. The address skipping starts from the end of the current descriptor to the start of the next descriptor. When the DSL value is equal to zero  the DMA takes the descriptor table as contiguous. Value After Reset  0x0"]
        #[inline(always)]
        pub fn dsl(
            self,
        ) -> crate::common::RegisterField<18, 0x7, 1, 0, u8, DmaCHiControl_SPEC, crate::common::RW>
        {
            crate::common::RegisterField::<18,0x7,1,0,u8, DmaCHiControl_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Split Headers   SPH. When this bit is set  the DMA splits the header and payload in the Receive path. The DMA writes the header to the Buffer Address1 of RDES0. The DMA writes the payload to the buffer to which the Buffer Address2 is pointing. The software must ensure that the header fits into the Receive buffers. If the header length exceeds the receive buffer size  the DMA does not split the header and payload. This bit is available only if Enable Split Header Structure option is selected. Value After Reset  0x0"]
        #[inline(always)]
        pub fn sph(
            self,
        ) -> crate::common::RegisterFieldBool<24, 1, 0, DmaCHiControl_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<24,1,0,DmaCHiControl_SPEC,crate::common::RW>::from_register(self,0)
        }
    }
    impl core::default::Default for DmaCHiControl {
        #[inline(always)]
        fn default() -> DmaCHiControl {
            <crate::RegValueT<DmaCHiControl_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiCurrentAppRxbuffer_SPEC;
    impl crate::sealed::RegSpec for DmaCHiCurrentAppRxbuffer_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Current Application Receive Buffer Address Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiCurrentAppRxbuffer = crate::RegValueT<DmaCHiCurrentAppRxbuffer_SPEC>;

    impl DmaCHiCurrentAppRxbuffer {
        #[doc = "Application Receive Buffer Address Pointer   CURRBUFAPTR. The DMA updates this pointer during Rx operation. This pointer is cleared on reset. Value After Reset  0x0"]
        #[inline(always)]
        pub fn currbufaptr(
            self,
        ) -> crate::common::RegisterField<
            0,
            0xffffffff,
            1,
            0,
            u32,
            DmaCHiCurrentAppRxbuffer_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterField::<
                0,
                0xffffffff,
                1,
                0,
                u32,
                DmaCHiCurrentAppRxbuffer_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiCurrentAppRxbuffer {
        #[inline(always)]
        fn default() -> DmaCHiCurrentAppRxbuffer {
            <crate::RegValueT<DmaCHiCurrentAppRxbuffer_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiCurrentAppRxdesc_SPEC;
    impl crate::sealed::RegSpec for DmaCHiCurrentAppRxdesc_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Current Application Receive Descriptor Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiCurrentAppRxdesc = crate::RegValueT<DmaCHiCurrentAppRxdesc_SPEC>;

    impl DmaCHiCurrentAppRxdesc {
        #[doc = "Application Receive Descriptor Address Pointer   CURRDESAPTR. The DMA updates this pointer during Rx operation. This pointer is cleared on reset. Value After Reset  0x0"]
        #[inline(always)]
        pub fn currdesaptr(
            self,
        ) -> crate::common::RegisterField<
            0,
            0xffffffff,
            1,
            0,
            u32,
            DmaCHiCurrentAppRxdesc_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterField::<
                0,
                0xffffffff,
                1,
                0,
                u32,
                DmaCHiCurrentAppRxdesc_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiCurrentAppRxdesc {
        #[inline(always)]
        fn default() -> DmaCHiCurrentAppRxdesc {
            <crate::RegValueT<DmaCHiCurrentAppRxdesc_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiCurrentAppTxbuffer_SPEC;
    impl crate::sealed::RegSpec for DmaCHiCurrentAppTxbuffer_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Current Application Transmit Buffer Address Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiCurrentAppTxbuffer = crate::RegValueT<DmaCHiCurrentAppTxbuffer_SPEC>;

    impl DmaCHiCurrentAppTxbuffer {
        #[doc = "Application Transmit Buffer Address Pointer   CURTBUFAPTR. The DMA updates this pointer during Tx operation. This pointer is cleared on reset. Value After Reset  0x0"]
        #[inline(always)]
        pub fn curtbufaptr(
            self,
        ) -> crate::common::RegisterField<
            0,
            0xffffffff,
            1,
            0,
            u32,
            DmaCHiCurrentAppTxbuffer_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterField::<
                0,
                0xffffffff,
                1,
                0,
                u32,
                DmaCHiCurrentAppTxbuffer_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiCurrentAppTxbuffer {
        #[inline(always)]
        fn default() -> DmaCHiCurrentAppTxbuffer {
            <crate::RegValueT<DmaCHiCurrentAppTxbuffer_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiCurrentAppTxdesc_SPEC;
    impl crate::sealed::RegSpec for DmaCHiCurrentAppTxdesc_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Current Application Transmit Descriptor Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiCurrentAppTxdesc = crate::RegValueT<DmaCHiCurrentAppTxdesc_SPEC>;

    impl DmaCHiCurrentAppTxdesc {
        #[doc = "Application Transmit Descriptor Address Pointer   CURTDESAPTR. The DMA updates this pointer during Tx operation. This pointer is cleared on reset. Value After Reset  0x0"]
        #[inline(always)]
        pub fn curtdesaptr(
            self,
        ) -> crate::common::RegisterField<
            0,
            0xffffffff,
            1,
            0,
            u32,
            DmaCHiCurrentAppTxdesc_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterField::<
                0,
                0xffffffff,
                1,
                0,
                u32,
                DmaCHiCurrentAppTxdesc_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiCurrentAppTxdesc {
        #[inline(always)]
        fn default() -> DmaCHiCurrentAppTxdesc {
            <crate::RegValueT<DmaCHiCurrentAppTxdesc_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiInterruptEnable_SPEC;
    impl crate::sealed::RegSpec for DmaCHiInterruptEnable_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Interrupt Enable Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiInterruptEnable = crate::RegValueT<DmaCHiInterruptEnable_SPEC>;

    impl DmaCHiInterruptEnable {
        #[doc = "Transmit Interrupt Enable   TIE. When this bit is set along with the NIE bit  the Transmit Interrupt is        enabled. When this bit is reset  the Transmit Interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn tie(
            self,
        ) -> crate::common::RegisterFieldBool<0, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<0,1,0,DmaCHiInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Transmit Stopped Enable   TXSE. When this bit is set along with the AIE bit  the Transmission Stopped interrupt is enabled. When this bit is reset  the Transmission Stopped interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn txse(
            self,
        ) -> crate::common::RegisterFieldBool<1, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<1,1,0,DmaCHiInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Transmit Buffer Unavailable Enable   TBUE. When this bit is set along with the NIE bit  the Transmit Buffer Unavailable interrupt is enabled. When this bit is reset  the Transmit Buffer Unavailable interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn tbue(
            self,
        ) -> crate::common::RegisterFieldBool<2, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<2,1,0,DmaCHiInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Interrupt Enable   RIE. When this bit is set along with the NIE bit  the Receive Interrupt is enabled. When this bit is reset  the Receive Interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rie(
            self,
        ) -> crate::common::RegisterFieldBool<6, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<6,1,0,DmaCHiInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Buffer Unavailable Enable   RBUE. When this bit is set along with the AIE bit  the Receive Buffer Unavailable interrupt is enabled. When this bit is reset  the Receive Buffer Unavailable interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rbue(
            self,
        ) -> crate::common::RegisterFieldBool<7, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<7,1,0,DmaCHiInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Stopped Enable   RSE. When this bit is set along with the AIE bit  the Receive Stopped Interrupt is enabled. When this bit is reset  the Receive Stopped interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rse(
            self,
        ) -> crate::common::RegisterFieldBool<8, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<8,1,0,DmaCHiInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Watchdog Timeout Enable   RWTE. When this bit is set along with the AIE bit  the Receive Watchdog Timeout interrupt is enabled. When this bit is reset  the Receive Watchdog Timeout interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rwte(
            self,
        ) -> crate::common::RegisterFieldBool<9, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<9,1,0,DmaCHiInterruptEnable_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Early Transmit Interrupt Enable   ETIE. When this bit is set along with the AIE bit  the Early Transmit interrupt is enabled. When this bit is reset  the Early Transmit interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn etie(
            self,
        ) -> crate::common::RegisterFieldBool<10, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<
                10,
                1,
                0,
                DmaCHiInterruptEnable_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Early Receive Interrupt Enable   ERIE. When this bit is set along with the NIE bit  the Early Receive interrupt is enabled. When this bit is reset  the Early Receive interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn erie(
            self,
        ) -> crate::common::RegisterFieldBool<11, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<
                11,
                1,
                0,
                DmaCHiInterruptEnable_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Fatal Bus Error Enable   FBEE. When this bit is set along with the AIE bit  the Fatal Bus error interrupt is enabled. When this bit is reset  the Fatal Bus Error error interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn fbee(
            self,
        ) -> crate::common::RegisterFieldBool<12, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<
                12,
                1,
                0,
                DmaCHiInterruptEnable_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Context Descriptor Error Enable   CDEE. When this bit is set along with the AIE bit  the Context Descriptor        error interrupt is enabled. When this bit is reset  the Context        Descriptor error interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn cdee(
            self,
        ) -> crate::common::RegisterFieldBool<13, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<
                13,
                1,
                0,
                DmaCHiInterruptEnable_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Abnormal Interrupt Summary Enable   AIE. When this bit is set  the abnormal interrupt summary is enabled. This bit enables the following interrupts in the DMA CH0 Status register  Bit 1  Transmit Process Stopped Bit 7  Rx Buffer Unavailable Bit 8  Receive Process Stopped Bit 9  Receive Watchdog Timeout Bit 10  Early Transmit Interrupt Bit 12  Fatal Bus Error Bit 13  Context Descriptor Error When this bit is reset  the abnormal interrupt summary is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn aie(
            self,
        ) -> crate::common::RegisterFieldBool<14, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<
                14,
                1,
                0,
                DmaCHiInterruptEnable_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Normal Interrupt Summary Enable   NIE. When this bit is set  the normal interrupt summary is enabled. This bit enables the following interrupts in the DMA CH0 Status register  Bit 0  Transmit Interrupt Bit 2  Transmit Buffer Unavailable Bit 6  Receive Interrupt Bit 11  Early Receive Interrupt When this bit is reset  the normal interrupt summary is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn nie(
            self,
        ) -> crate::common::RegisterFieldBool<15, 1, 0, DmaCHiInterruptEnable_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<
                15,
                1,
                0,
                DmaCHiInterruptEnable_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiInterruptEnable {
        #[inline(always)]
        fn default() -> DmaCHiInterruptEnable {
            <crate::RegValueT<DmaCHiInterruptEnable_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiMissFrameCnt_SPEC;
    impl crate::sealed::RegSpec for DmaCHiMissFrameCnt_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Missed Frames Count Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiMissFrameCnt = crate::RegValueT<DmaCHiMissFrameCnt_SPEC>;

    impl DmaCHiMissFrameCnt {
        #[doc = "Dropped Packet Counters   MFC. This counter indicates the number of packet counters that are dropped by the DMA either because of bus error or because of programing RPF field in DMA CHx RX CONTROL register. The counter gets cleared when this register is read. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
        #[inline(always)]
        pub fn mfc(
            self,
        ) -> crate::common::RegisterField<
            0,
            0x7ff,
            1,
            0,
            u16,
            DmaCHiMissFrameCnt_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterField::<
                0,
                0x7ff,
                1,
                0,
                u16,
                DmaCHiMissFrameCnt_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
        #[doc = "Overflow status of the MFC Counter   MFCO. When this bit is set then the MFC counter does not get incremented further. The bit gets cleared when this register is read. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
        #[inline(always)]
        pub fn mfco(
            self,
        ) -> crate::common::RegisterFieldBool<15, 1, 0, DmaCHiMissFrameCnt_SPEC, crate::common::R>
        {
            crate::common::RegisterFieldBool::<15,1,0,DmaCHiMissFrameCnt_SPEC,crate::common::R>::from_register(self,0)
        }
    }
    impl core::default::Default for DmaCHiMissFrameCnt {
        #[inline(always)]
        fn default() -> DmaCHiMissFrameCnt {
            <crate::RegValueT<DmaCHiMissFrameCnt_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiRxdescListAddress_SPEC;
    impl crate::sealed::RegSpec for DmaCHiRxdescListAddress_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Receive Descriptor List Address Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiRxdescListAddress = crate::RegValueT<DmaCHiRxdescListAddress_SPEC>;

    impl DmaCHiRxdescListAddress {
        #[doc = "Start of Receive List   RDESLA. This field contains the base address of the first descriptor in the Rx Descriptor list. The DMA ignores the LSB bits  1 0  2 0  or 3 0  for 32 bit  64 bit  or 128 bit bus width and internally takes these bits as all zero. Therefore  these LSB bits are read only  RO . The width of this field depends on the configuration  31 2 for 32 bit configuration 31 3 for 64 bit configuration 31 4 for 128 bit configuration Value After Reset  0x0"]
        #[inline(always)]
        pub fn rdesla(
            self,
        ) -> crate::common::RegisterField<
            2,
            0x3fffffff,
            1,
            0,
            u32,
            DmaCHiRxdescListAddress_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                2,
                0x3fffffff,
                1,
                0,
                u32,
                DmaCHiRxdescListAddress_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiRxdescListAddress {
        #[inline(always)]
        fn default() -> DmaCHiRxdescListAddress {
            <crate::RegValueT<DmaCHiRxdescListAddress_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiRxdescRingLength_SPEC;
    impl crate::sealed::RegSpec for DmaCHiRxdescRingLength_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Recieve Descriptor Ring Length Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiRxdescRingLength = crate::RegValueT<DmaCHiRxdescRingLength_SPEC>;

    impl DmaCHiRxdescRingLength {
        #[doc = "Receive Descriptor Ring Length   RDRL. This register sets the maximum number of Rx descriptors in the circular        descriptor ring. The maximum number of descriptors is limited to 1K        descriptors. For example  You can program any value up to 0x3FF in this        field. This field is 10 bits wide  if you program 0x3FF  you can have        1024 descriptors. If you want to have 10 descriptors  program it to a        value of 0x9. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rdrl(
            self,
        ) -> crate::common::RegisterField<
            0,
            0x3ff,
            1,
            0,
            u16,
            DmaCHiRxdescRingLength_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                0,
                0x3ff,
                1,
                0,
                u16,
                DmaCHiRxdescRingLength_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiRxdescRingLength {
        #[inline(always)]
        fn default() -> DmaCHiRxdescRingLength {
            <crate::RegValueT<DmaCHiRxdescRingLength_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiRxdescTailPointer_SPEC;
    impl crate::sealed::RegSpec for DmaCHiRxdescTailPointer_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Recieve Descriptor Tail Pointer Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiRxdescTailPointer = crate::RegValueT<DmaCHiRxdescTailPointer_SPEC>;

    impl DmaCHiRxdescTailPointer {
        #[doc = "Receive Descriptor Tail Pointer   RDTP. This field contains the tail pointer for the Rx descriptor ring. The software writes the tail pointer to add more descriptors to the Rx channel. The hardware tries to write all received packets to the descriptors referenced between the head and the tail pointer registers. The width of this field depends on the configuration  31 2 for 32 bit configuration 31 3 for 64 bit configuration 31 4 for 128 bit configuration Value After Reset  0x0"]
        #[inline(always)]
        pub fn rdtp(
            self,
        ) -> crate::common::RegisterField<
            2,
            0x3fffffff,
            1,
            0,
            u32,
            DmaCHiRxdescTailPointer_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                2,
                0x3fffffff,
                1,
                0,
                u32,
                DmaCHiRxdescTailPointer_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiRxdescTailPointer {
        #[inline(always)]
        fn default() -> DmaCHiRxdescTailPointer {
            <crate::RegValueT<DmaCHiRxdescTailPointer_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiRxControl_SPEC;
    impl crate::sealed::RegSpec for DmaCHiRxControl_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Receive Control Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiRxControl = crate::RegValueT<DmaCHiRxControl_SPEC>;

    impl DmaCHiRxControl {
        #[doc = "Start or Stop Receive   SR. When this bit is set  the DMA tries to acquire the descriptor from the        Receive list and processes the incoming packets. The DMA tries to acquire descriptor from either of the following        positions  The current position in the list This is the address set by the DMA CH0 RxDesc List Address register. The position at which the Rx process was previously stopped If the DMA does not own the current descriptor  the reception is        suspended and the RBU bit of the DMA CH0 Status register is set. The        Start Receive command is effective only when the reception is stopped.        If the command is issued before setting the DMA CH0 RxDesc List Address        register  the DMA behavior is unpredictable. When this bit is reset  the Rx DMA operation is stopped after the        transfer of the current packet. The next descriptor position in the        Receive list is saved  and it becomes the current position after the Rx        process is restarted. The Stop Receive command is effective only when        the Rx process is in the Running  waiting for Rx packet  or Suspended        state. Value After Reset  0x0"]
        #[inline(always)]
        pub fn sr(
            self,
        ) -> crate::common::RegisterFieldBool<0, 1, 0, DmaCHiRxControl_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<0,1,0,DmaCHiRxControl_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Buffer size Low   RBSZ x 0. RBSZ 13 0  is split into two fields RBSZ 13 y and RBSZ x 0. The RBSZ x 0        is the lower field whose width is based on data bus width of the        configuration. This field is of width 2  3  or 4 bits for 32 bit         64 bit  or 128 bit data bus width respectively. This field is read only         RO . Value After Reset  0x0"]
        #[inline(always)]
        pub fn rbsz_x_0(
            self,
        ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, DmaCHiRxControl_SPEC, crate::common::R>
        {
            crate::common::RegisterField::<1,0x3,1,0,u8, DmaCHiRxControl_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "Receive Buffer size High   RBSZ 13 y. RBSZ 13 0  is split into two fields higher RBSZ 13 y and lower RBSZ x 0.        The RBSZ 13 0  field indicates the size of the Rx buffers specified in        bytes. The maximum buffer size is limited to 16K bytes. The buffer size        is applicable to payload buffers when split headers are enabled. Note   The buffer size must be a multiple of        4  8  or 16 depending on the data bus widths  32 bit  64 bit  or 128 bit        respectively . This is required even if the value of buffer address        pointer is not aligned to data bus width. Hence the lower RBSZ x 0 bits        are read only and the value is considered as allzero. Thus the RBSZ 13 y        indicates the buffer size in terms of locations  with the width same as        bus width . Value After Reset  0x0"]
        #[inline(always)]
        pub fn rbsz_13_y(
            self,
        ) -> crate::common::RegisterField<
            3,
            0xfff,
            1,
            0,
            u16,
            DmaCHiRxControl_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                3,
                0xfff,
                1,
                0,
                u16,
                DmaCHiRxControl_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Receive Programmable Burst Length   RxPBL. These bits indicate the maximum number of beats to be transferred in one        DMA block data transfer. The DMA always attempts max burst as specified        in PBL each time it starts a burst transfer on the application bus. You        can program PBL with any of the following values  1  2  4  8  16  or 32.        Any other value results in undefined behavior. To transfer more than 32 beats  perform the following steps  1. Set the 8xPBL mode in the DMA CH0 Control register. 2. Set the RxPBL. Note  The maximum value of RxPBL must be less than or equal to half the        Rx Queue size  RQS field of MTL RxQ n  Operation Mode register  in terms        of beats. This is required so that the Rx Queue has space to store at        least another Rx PBL worth of data while the Rx DMA is transferring a        block of data. For example  in 64 bit data width configurations the        total locations in Rx Queue of size 512 bytes is 64  so RxPBL and 8xPBL        needs to be programmed to less than or equal to 32. Value After Reset         0x0"]
        #[inline(always)]
        pub fn rxpbl(
            self,
        ) -> crate::common::RegisterField<16, 0x3f, 1, 0, u8, DmaCHiRxControl_SPEC, crate::common::RW>
        {
            crate::common::RegisterField::<
                16,
                0x3f,
                1,
                0,
                u8,
                DmaCHiRxControl_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "DMA Rx Channel0 Packet Flush   RPF. When this bit is set to 1  then DWC ether qos automatically flushes the packet from the Rx Queues destined to this DMA Rx Channel  when it is stopped. When this bit remains set and the DMA is re started by the software driver  the packets residing in the Rx Queues that were received when this RxDMA was stopped  get flushed out. The packets that are received by the MAC after the RxDMA is re started are routed to the RxDMA. The flushing happens on the Read side of the Rx Queue. When this bit is set to 0  the DWC ether qos not flush the packet in the Rx Queue destined to this RxDMA Channel when it is STOP state. This may in turn cause head of line blocking in the corresponding RxQueue. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rpf(
            self,
        ) -> crate::common::RegisterFieldBool<31, 1, 0, DmaCHiRxControl_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<31,1,0,DmaCHiRxControl_SPEC,crate::common::RW>::from_register(self,0)
        }
    }
    impl core::default::Default for DmaCHiRxControl {
        #[inline(always)]
        fn default() -> DmaCHiRxControl {
            <crate::RegValueT<DmaCHiRxControl_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiRxInterruptWatchdogTimer_SPEC;
    impl crate::sealed::RegSpec for DmaCHiRxInterruptWatchdogTimer_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Recieve Interrupt Watchdog Timer Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiRxInterruptWatchdogTimer = crate::RegValueT<DmaCHiRxInterruptWatchdogTimer_SPEC>;

    impl DmaCHiRxInterruptWatchdogTimer {
        #[doc = "Receive Interrupt Watchdog Timer Count   RWT. This field indicates the number of system clock cycles  multiplied by factor indicated in RWTU field  for which the watchdog timer is set. The watchdog timer is triggered with the programmed value after the Rx DMA completes the transfer of a packet for which the RI bit is not set in the DMA CH0 Status register  because of the setting of Interrupt Enable bit in the corresponding descriptor RDES3 30 . When the watchdog timer runs out  the RI bit is set and the timer is stopped. The watchdog timer is reset when the RI bit is set high because of automatic setting of RI as per the Interrupt Enable bit RDES3 30  of any received packet. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rwt(
            self,
        ) -> crate::common::RegisterField<
            0,
            0xff,
            1,
            0,
            u8,
            DmaCHiRxInterruptWatchdogTimer_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                0,
                0xff,
                1,
                0,
                u8,
                DmaCHiRxInterruptWatchdogTimer_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Receive Interrupt Watchdog Timer Count Units   RWTU. This fields indicates the number of system clock cycles corresponding to one unit in RWT field. For example  when RWT 2 and RWTU 1  the watchdog timer is set for 2 512 1024 system clock cycles. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rwtu(
            self,
        ) -> crate::common::RegisterField<
            16,
            0x3,
            1,
            0,
            u8,
            DmaCHiRxInterruptWatchdogTimer_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                16,
                0x3,
                1,
                0,
                u8,
                DmaCHiRxInterruptWatchdogTimer_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiRxInterruptWatchdogTimer {
        #[inline(always)]
        fn default() -> DmaCHiRxInterruptWatchdogTimer {
            <crate::RegValueT<DmaCHiRxInterruptWatchdogTimer_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiSlotFunctionControlStatus_SPEC;
    impl crate::sealed::RegSpec for DmaCHiSlotFunctionControlStatus_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Slot Function Control and Status Register\n resetvalue={Application Reset:0x7C0}"]
    pub type DmaCHiSlotFunctionControlStatus =
        crate::RegValueT<DmaCHiSlotFunctionControlStatus_SPEC>;

    impl DmaCHiSlotFunctionControlStatus {
        #[doc = "Enable Slot Comparison   ESC. When set  this bit enables the checking of the slot numbers programmed in the Tx descriptor with the current reference given in the RSN field. The DMA fetches the data from the corresponding buffer only when the slot number is equal to the reference slot number or ahead of the reference slot number by one slot When reset  this bit disables the checking of the slot numbers. The DMA fetches the data immediately after the descriptor is processed. Value After Reset  0x0"]
        #[inline(always)]
        pub fn esc(
            self,
        ) -> crate::common::RegisterFieldBool<
            0,
            1,
            0,
            DmaCHiSlotFunctionControlStatus_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterFieldBool::<
                0,
                1,
                0,
                DmaCHiSlotFunctionControlStatus_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Advance Slot Check   ASC. When set  this bit enables the DMA to fetch the data from the buffer        when the slot number  SLOTNUM  programmed in the Tx descriptor is equal to the reference slot number given in the RSN field or ahead of the reference slot number by up to two slots This bit is applicable only when the ESC bit is set. Value After Reset  0x0"]
        #[inline(always)]
        pub fn asc(
            self,
        ) -> crate::common::RegisterFieldBool<
            1,
            1,
            0,
            DmaCHiSlotFunctionControlStatus_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterFieldBool::<
                1,
                1,
                0,
                DmaCHiSlotFunctionControlStatus_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Slot Interval Value   SIV. This field controls the period of the slot interval in which the TxDMA        fetches the scheduled packets. A value of 0 specifies the slot interval        of 1 us while the maximum value 4095 specifies the slot interval of        4096us. The default  reset value is 0x07C which corresponds to slot        interval of 125us. Value After Reset  0x7c"]
        #[inline(always)]
        pub fn siv(
            self,
        ) -> crate::common::RegisterField<
            4,
            0xfff,
            1,
            0,
            u16,
            DmaCHiSlotFunctionControlStatus_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                4,
                0xfff,
                1,
                0,
                u16,
                DmaCHiSlotFunctionControlStatus_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Reference Slot Number   RSN. This field gives the current value of the reference slot number in the        DMA. It is used for slot comparison. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rsn(
            self,
        ) -> crate::common::RegisterField<
            16,
            0xf,
            1,
            0,
            u8,
            DmaCHiSlotFunctionControlStatus_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterField::<
                16,
                0xf,
                1,
                0,
                u8,
                DmaCHiSlotFunctionControlStatus_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiSlotFunctionControlStatus {
        #[inline(always)]
        fn default() -> DmaCHiSlotFunctionControlStatus {
            <crate::RegValueT<DmaCHiSlotFunctionControlStatus_SPEC> as RegisterValue<_>>::new(1984)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiStatus_SPEC;
    impl crate::sealed::RegSpec for DmaCHiStatus_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Status Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiStatus = crate::RegValueT<DmaCHiStatus_SPEC>;

    impl DmaCHiStatus {
        #[doc = "Transmit Interrupt   TI. This bit indicates that the packet transmission is complete. When        transmission is complete  Bit 31 of TDES3 is reset in the last        descriptor  and the specific packet status information is updated in the        descriptor. Access restriction applies. Self set to 1 on internal event. Setting 1        clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn ti(
            self,
        ) -> crate::common::RegisterFieldBool<0, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<0,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Transmit Process Stopped   TPS. This bit is set when the transmission is stopped. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn tps(
            self,
        ) -> crate::common::RegisterFieldBool<1, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<1,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Transmit Buffer Unavailable   TBU. This bit indicates that the application owns the next descriptor in the        Transmit list  and the DMA cannot acquire it. Transmission is suspended.        The TPS0 field of the DMA Debug Status0 register explains the Transmit        Process state transitions. To resume processing the Transmit descriptors  the application should do        the following  1. Change the ownership of the descriptor by setting Bit 31 of TDES3. 2. Issue a Transmit Poll Demand command. For ring mode  the application should advance the Transmit Descriptor        Tail Pointer register of a channel. Access restriction applies. Self set to 1 on internal event. Setting 1        clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn tbu(
            self,
        ) -> crate::common::RegisterFieldBool<2, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<2,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Interrupt   RI. This bit indicates that the packet reception is complete. When packet        reception is complete  Bit 31 of RDES3 is reset in the last descriptor         and the specific packet status information is updated in the descriptor. The reception remains in the Running state. Access restriction applies. Self set to 1 on internal event. Setting 1        clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn ri(
            self,
        ) -> crate::common::RegisterFieldBool<6, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<6,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Buffer Unavailable   RBU. This bit indicates that the application owns the next descriptor in the Receive list  and the DMA cannot acquire it. The Rx process is suspended. To resume processing Rx descriptors  the application should change the ownership of the descriptor and issue a Receive Poll Demand command. If this command is not issued  the Rx process resumes when the next recognized incoming packet is received. In ring mode  the application should advance the Receive Descriptor Tail Pointer register of a channel. This bit is set only when the DMA owns the previous Rx descriptor. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rbu(
            self,
        ) -> crate::common::RegisterFieldBool<7, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<7,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Process Stopped   RPS. This bit is asserted when the Rx process enters the Stopped state. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rps(
            self,
        ) -> crate::common::RegisterFieldBool<8, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<8,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Watchdog Timeout   RWT. This bit is asserted when a packet with length greater than 2 048 bytes  10 240 bytes when Jumbo Packet mode is enabled  is received. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rwt(
            self,
        ) -> crate::common::RegisterFieldBool<9, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<9,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Early Transmit Interrupt   ETI. This bit indicates that the packet to be transmitted is fully transferred to the MTL Tx FIFO. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn eti(
            self,
        ) -> crate::common::RegisterFieldBool<10, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<10,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Early Receive Interrupt   ERI. This bit indicates that the DMA filled the first data buffer of the packet. The RI bit of this register automatically clears this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn eri(
            self,
        ) -> crate::common::RegisterFieldBool<11, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<11,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Fatal Bus Error   FBE. This bit indicates that a bus error occurred  as described in the EB field . When this bit is set  the corresponding DMA channel engine disables all bus accesses. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn fbe(
            self,
        ) -> crate::common::RegisterFieldBool<12, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<12,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Context Descriptor Error   CDE. This bit indicates that the DMA Tx Rx engine received a descriptor        error  which indicates invalid context in the middle of packet flow         intermediate descriptor  or all one s descriptor in Tx case and on Rx        side it indicates DMA has read a descriptor with either of the buffer        address as ones which is considered to be invalid.Access restriction        applies. Self set to 1 on internal event. Setting 1 clears. Setting 0        has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn cde(
            self,
        ) -> crate::common::RegisterFieldBool<13, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<13,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Abnormal Interrupt Summary   AIS. Abnormal Interrupt Summary bit value is the logical OR of the following when the corresponding interrupt bits are enabled in the DMA CH0 Interrupt Enable register  Bit 1  Transmit Process Stopped Bit 7  Receive Buffer Unavailable Bit 8  Receive Process Stopped Bit 10  Early Transmit Interrupt Bit 12  Fatal Bus Error Bit 13  Context Descriptor Error Only unmasked bits affect the Abnormal Interrupt Summary bit. This is a sticky bit. You must clear this bit  by writing 1 to this bit  each time a corresponding bit  which causes AIS to be set  is cleared. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn ais(
            self,
        ) -> crate::common::RegisterFieldBool<14, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<14,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Normal Interrupt Summary   NIS. Normal Interrupt Summary bit value is the logical OR of the following bits when the corresponding interrupt bits are enabled in the DMA CH0 Interrupt Enable register  Bit 0  Transmit Interrupt Bit 2  Transmit Buffer Unavailable Bit 6  Receive Interrupt Bit 11  Early Receive Interrupt Only unmasked bits  interrupts for which interrupt enable is set in DMA CH0 Interrupt Enable register  affect the Normal Interrupt Summary bit. This is a sticky bit. You must clear this bit  by writing 1 to this bit  each time a corresponding bit which causes NIS to be set is cleared. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn nis(
            self,
        ) -> crate::common::RegisterFieldBool<15, 1, 0, DmaCHiStatus_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<15,1,0,DmaCHiStatus_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Tx DMA Error Bits   TEB. This field indicates the type of error that caused a Bus Error. For example  error response on the AHB or AXI interface. Bit 18 1 B Error during data transfer by Tx DMA 0 B No Error during data transfer by Tx DMA Bit 17 1 B Error during descriptor access 0 B Error during data buffer access Bit 16 1 B Error during read transfer 0 B Error during write transfer This field is valid only when the FBE bit is set. This field does not generate an interrupt. Value After Reset  0x0"]
        #[inline(always)]
        pub fn teb(
            self,
        ) -> crate::common::RegisterField<16, 0x7, 1, 0, u8, DmaCHiStatus_SPEC, crate::common::R>
        {
            crate::common::RegisterField::<16,0x7,1,0,u8, DmaCHiStatus_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "Rx DMA Error Bits   REB. This field indicates the type of error that caused a Bus Error. For example  error response on the AHB or AXI interface. Bit 21 1 B Error during data transfer by Rx DMA 0 B No Error during data transfer by Rx DMA Bit 20 1 B Error during descriptor access 0 B Error during data buffer access Bit 19 1 B Error during read transfer 0 B Error during write transfer This field is valid only when the FBE bit is set. This field does not generate an interrupt. Value After Reset  0x0"]
        #[inline(always)]
        pub fn reb(
            self,
        ) -> crate::common::RegisterField<19, 0x7, 1, 0, u8, DmaCHiStatus_SPEC, crate::common::R>
        {
            crate::common::RegisterField::<19,0x7,1,0,u8, DmaCHiStatus_SPEC,crate::common::R>::from_register(self,0)
        }
    }
    impl core::default::Default for DmaCHiStatus {
        #[inline(always)]
        fn default() -> DmaCHiStatus {
            <crate::RegValueT<DmaCHiStatus_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiTxdescListAddress_SPEC;
    impl crate::sealed::RegSpec for DmaCHiTxdescListAddress_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Transmit Descriptor List Address Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiTxdescListAddress = crate::RegValueT<DmaCHiTxdescListAddress_SPEC>;

    impl DmaCHiTxdescListAddress {
        #[doc = "Start of Transmit List   TDESLA. This field contains the base address of the first descriptor in the Transmit descriptor list. The DMA ignores the LSB bits  1 0  2 0  or 3 0  for 32 bit  64 bit  or 128 bit bus width and internally takes these bits as all zero. Therefore  these LSB bits are read only  RO . The width of this field depends on the configuration  31 2 for 32 bit configuration 31 3 for 64 bit configuration 31 4 for 128 bit configuration Value After Reset  0x0"]
        #[inline(always)]
        pub fn tdesla(
            self,
        ) -> crate::common::RegisterField<
            2,
            0x3fffffff,
            1,
            0,
            u32,
            DmaCHiTxdescListAddress_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                2,
                0x3fffffff,
                1,
                0,
                u32,
                DmaCHiTxdescListAddress_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiTxdescListAddress {
        #[inline(always)]
        fn default() -> DmaCHiTxdescListAddress {
            <crate::RegValueT<DmaCHiTxdescListAddress_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiTxdescRingLength_SPEC;
    impl crate::sealed::RegSpec for DmaCHiTxdescRingLength_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Transmit Descriptor Ring Length Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiTxdescRingLength = crate::RegValueT<DmaCHiTxdescRingLength_SPEC>;

    impl DmaCHiTxdescRingLength {
        #[doc = "Transmit Descriptor Ring Length   TDRL. This field sets the maximum number of Tx descriptors in the circular        descriptor ring. The maximum number of descriptors is limited to 1K        descriptors. Synopsys recommends a minimum ring descriptor length of 4.        For example  You can program any value up to 0x3FF in this field. This        field is 10 bits wide  if you program 0x3FF  you can have 1024        descriptors. If you want to have 10 descriptors  program it to a value        of 0x9. Value After Reset  0x0"]
        #[inline(always)]
        pub fn tdrl(
            self,
        ) -> crate::common::RegisterField<
            0,
            0x3ff,
            1,
            0,
            u16,
            DmaCHiTxdescRingLength_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                0,
                0x3ff,
                1,
                0,
                u16,
                DmaCHiTxdescRingLength_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiTxdescRingLength {
        #[inline(always)]
        fn default() -> DmaCHiTxdescRingLength {
            <crate::RegValueT<DmaCHiTxdescRingLength_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiTxdescTailPointer_SPEC;
    impl crate::sealed::RegSpec for DmaCHiTxdescTailPointer_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Transmit Descriptor Tail Pointer Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiTxdescTailPointer = crate::RegValueT<DmaCHiTxdescTailPointer_SPEC>;

    impl DmaCHiTxdescTailPointer {
        #[doc = "Transmit Descriptor Tail Pointer   TDTP. This field contains the tail pointer for the Tx descriptor ring. The software writes the tail pointer to add more descriptors to the Tx channel. The hardware tries to transmit all packets referenced by the descriptors between the head and the tail pointer registers. The width of this field depends on the configuration  31 2 for 32 bit configuration 31 3 for 64 bit configuration 31 4 for 128 bit configuration Value After Reset  0x0"]
        #[inline(always)]
        pub fn tdtp(
            self,
        ) -> crate::common::RegisterField<
            2,
            0x3fffffff,
            1,
            0,
            u32,
            DmaCHiTxdescTailPointer_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                2,
                0x3fffffff,
                1,
                0,
                u32,
                DmaCHiTxdescTailPointer_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiTxdescTailPointer {
        #[inline(always)]
        fn default() -> DmaCHiTxdescTailPointer {
            <crate::RegValueT<DmaCHiTxdescTailPointer_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaCHiTxControl_SPEC;
    impl crate::sealed::RegSpec for DmaCHiTxControl_SPEC {
        type DataType = u32;
    }
    #[doc = "DMA Channel 0 Transmit Control Register\n resetvalue={Application Reset:0x0}"]
    pub type DmaCHiTxControl = crate::RegValueT<DmaCHiTxControl_SPEC>;

    impl DmaCHiTxControl {
        #[doc = "Start or Stop Transmission Command   ST. When this bit is set  transmission is placed in the Running state. The DMA checks the Transmit list at the current position for a packet to be transmitted. The DMA tries to acquire descriptor from either of the following positions  The current position in the list This is the base address of the Transmit list set by the DMA CH0 TxDesc List Address register. The position at which the transmission was previously stopped If the DMA does not own the current descriptor  the transmission enters the Suspended state and the TBU bit of the DMA CH0 Status register is set. The Start Transmission command is effective only when the transmission is stopped. If the command is issued before setting the DMA CH0 TxDesc List Address register  the DMA behavior is unpredictable. When this bit is reset  the transmission process is placed in the Stopped state after completing the transmission of the current packet. The Next Descriptor position in the Transmit list is saved  and it becomes the current position when the transmission is restarted. To change the list address  you need to program DMA CH0 TxDesc List Address register with a new value when this bit is reset. The new value is considered when this bit is set again. The stop transmission command is effective only when the transmission of the current packet is complete or the transmission is in the Suspended state. Value After Reset  0x0"]
        #[inline(always)]
        pub fn st(
            self,
        ) -> crate::common::RegisterFieldBool<0, 1, 0, DmaCHiTxControl_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<0,1,0,DmaCHiTxControl_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Transmit Channel Weight   TCW. This field indicates the weight assigned to the corresponding Transmit channel. When reset is complete  this field is set to 0 for all channels by default  resulting in equal weights to all channels. Value After Reset  0x0"]
        #[inline(always)]
        pub fn tcw(
            self,
        ) -> crate::common::RegisterField<1, 0x7, 1, 0, u8, DmaCHiTxControl_SPEC, crate::common::RW>
        {
            crate::common::RegisterField::<1,0x7,1,0,u8, DmaCHiTxControl_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Operate on Second Packet   OSF. When this bit is set  it instructs the DMA to process the second packet        of the Transmit data even before the status for the first packet is        obtained. Value After Reset  0x0"]
        #[inline(always)]
        pub fn osf(
            self,
        ) -> crate::common::RegisterFieldBool<4, 1, 0, DmaCHiTxControl_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<4,1,0,DmaCHiTxControl_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Transmit Programmable Burst Length   TxPBL. These bits indicate the maximum number of beats to be transferred in one        DMA block data transfer. The DMA always attempts max burst as specified        in PBL each time it starts a burst transfer on the application bus. You        can program PBL with any of the following values  1  2  4  8  16  or 32.        Any other value results in undefined behavior. To transfer more than 32 beats  perform the following steps  1. Set the 8xPBL mode in DMA CH0 Control register. 2. Set the TxPBL. Note  The maximum value of TxPBL must be less than or equal to half the        Tx Queue size  TQS field of MTL TxQ n  Operation Mode register  in terms        of beats. This is required so that the Tx Queue has space to store at        least another Tx PBL worth of data while the MTL Tx Queue Controller is        transferring data to MAC. For example  in 64 bit data width        configurations the total locations in Tx Queue of size 512 bytes is 64         TxPBL and 8xPBL needs to be programmed to less than or equal to 32.        Value After Reset  0x0"]
        #[inline(always)]
        pub fn txpbl(
            self,
        ) -> crate::common::RegisterField<16, 0x3f, 1, 0, u8, DmaCHiTxControl_SPEC, crate::common::RW>
        {
            crate::common::RegisterField::<
                16,
                0x3f,
                1,
                0,
                u8,
                DmaCHiTxControl_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for DmaCHiTxControl {
        #[inline(always)]
        fn default() -> DmaCHiTxControl {
            <crate::RegValueT<DmaCHiTxControl_SPEC> as RegisterValue<_>>::new(0)
        }
    }
}
#[doc = "MTL Q0"]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlQ0(pub(super) *mut u8);
unsafe impl core::marker::Send for MtlQ0 {}
unsafe impl core::marker::Sync for MtlQ0 {}
impl MtlQ0 {
    #[doc = "MTL Queue 0 Interrupt Control Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_q0_interrupt_control_status(
        &self,
    ) -> crate::common::Reg<mtl_q0::MtlQ0InterruptControlStatus_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(0usize)) }
    }
}
pub mod mtl_q0 {
    #[allow(unused_imports)]
    use crate::common::*;
    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtlQ0InterruptControlStatus_SPEC;
    impl crate::sealed::RegSpec for MtlQ0InterruptControlStatus_SPEC {
        type DataType = u32;
    }
    #[doc = "MTL Queue 0 Interrupt Control Status Register\n resetvalue={Application Reset:0x0}"]
    pub type MtlQ0InterruptControlStatus = crate::RegValueT<MtlQ0InterruptControlStatus_SPEC>;

    impl MtlQ0InterruptControlStatus {
        #[doc = "Transmit Queue Underflow Interrupt Status   TXUNFIS. This bit indicates that the Transmit Queue had an underflow while transmitting the packet. Transmission is suspended and an Underflow Error TDES3 2  is set. This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn txunfis(
            self,
        ) -> crate::common::RegisterFieldBool<
            0,
            1,
            0,
            MtlQ0InterruptControlStatus_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterFieldBool::<
                0,
                1,
                0,
                MtlQ0InterruptControlStatus_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Average Bits Per Slot Interrupt Status   ABPSIS. When set  this bit indicates that the MAC has updated the ABS value. This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn abpsis(
            self,
        ) -> crate::common::RegisterFieldBool<
            1,
            1,
            0,
            MtlQ0InterruptControlStatus_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterFieldBool::<
                1,
                1,
                0,
                MtlQ0InterruptControlStatus_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Transmit Queue Underflow Interrupt Enable   TXUIE. When this bit is set  the Transmit Queue Underflow interrupt is enabled. When this bit is reset  the Transmit Queue Underflow interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn txuie(
            self,
        ) -> crate::common::RegisterFieldBool<
            8,
            1,
            0,
            MtlQ0InterruptControlStatus_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterFieldBool::<
                8,
                1,
                0,
                MtlQ0InterruptControlStatus_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Average Bits Per Slot Interrupt Enable   ABPSIE. When this bit is set  the MAC asserts the sbd intr o or mci intr o interrupt when the average bits per slot status is updated. When this bit is cleared  the interrupt is not asserted for such an event. Value After Reset  0x0"]
        #[inline(always)]
        pub fn abpsie(
            self,
        ) -> crate::common::RegisterFieldBool<
            9,
            1,
            0,
            MtlQ0InterruptControlStatus_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterFieldBool::<
                9,
                1,
                0,
                MtlQ0InterruptControlStatus_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Receive Queue Overflow Interrupt Status   RXOVFIS. This bit indicates that the Receive Queue had an overflow while receiving the packet. If a partial packet is transferred to the application  the overflow status is set in RDES3 21 . This bit is cleared when the application writes 1 to this bit. Access restriction applies. Self set to 1 on internal event. Setting 1 clears. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rxovfis(
            self,
        ) -> crate::common::RegisterFieldBool<
            16,
            1,
            0,
            MtlQ0InterruptControlStatus_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterFieldBool::<
                16,
                1,
                0,
                MtlQ0InterruptControlStatus_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Receive Queue Overflow Interrupt Enable   RXOIE. When this bit is set  the Receive Queue Overflow interrupt is enabled. When this bit is reset  the Receive Queue Overflow interrupt is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rxoie(
            self,
        ) -> crate::common::RegisterFieldBool<
            24,
            1,
            0,
            MtlQ0InterruptControlStatus_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterFieldBool::<
                24,
                1,
                0,
                MtlQ0InterruptControlStatus_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for MtlQ0InterruptControlStatus {
        #[inline(always)]
        fn default() -> MtlQ0InterruptControlStatus {
            <crate::RegValueT<MtlQ0InterruptControlStatus_SPEC> as RegisterValue<_>>::new(0)
        }
    }
}
#[doc = "MTL RXQ0"]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlRxq0(pub(super) *mut u8);
unsafe impl core::marker::Send for MtlRxq0 {}
unsafe impl core::marker::Sync for MtlRxq0 {}
impl MtlRxq0 {
    #[doc = "MTL Queue 0 Receive Control Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq0_control(
        &self,
    ) -> crate::common::Reg<mtl_rxq0::MtlRxq0Control_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(12usize)) }
    }
    #[doc = "MTL Queue 0 Receive Debug Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq0_debug(
        &self,
    ) -> crate::common::Reg<mtl_rxq0::MtlRxq0Debug_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8usize)) }
    }
    #[doc = "MTL Queue 0 Receive Missed Packet and Overflow Counter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq0_missed_packet_overflow_cnt(
        &self,
    ) -> crate::common::Reg<mtl_rxq0::MtlRxq0MissedPacketOverflowCnt_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(4usize)) }
    }
    #[doc = "MTL Queue 0 Receive Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_rxq0_operation_mode(
        &self,
    ) -> crate::common::Reg<mtl_rxq0::MtlRxq0OperationMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(0usize)) }
    }
}
pub mod mtl_rxq0 {
    #[allow(unused_imports)]
    use crate::common::*;
    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtlRxq0Control_SPEC;
    impl crate::sealed::RegSpec for MtlRxq0Control_SPEC {
        type DataType = u32;
    }
    #[doc = "MTL Queue 0 Receive Control Register\n resetvalue={Application Reset:0x0}"]
    pub type MtlRxq0Control = crate::RegValueT<MtlRxq0Control_SPEC>;

    impl MtlRxq0Control {
        #[doc = "Receive Queue Weight   RXQ WEGT. This field indicates the weight assigned to the Rx Queue 0. The weight is used as the number of continuous PBL or packets requests  depending on the RXQ FRM ARBIT  allocated to the queue in one arbitration cycle. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rxq_wegt(
            self,
        ) -> crate::common::RegisterField<0, 0x7, 1, 0, u8, MtlRxq0Control_SPEC, crate::common::RW>
        {
            crate::common::RegisterField::<0,0x7,1,0,u8, MtlRxq0Control_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Queue Packet Arbitration   RXQ FRM ARBIT. When this bit is set  the DWC ether qos drives the packet data to the ARI interface such that the entire packet data of currently selected queue is transmitted before switching to other queue. When this bit is reset  the DWC ether qos drives the packet data to the ARI interface such that the following amount of data of currently selected queue is transmitted before switching to other queue  PBL amount of data  indicated by ari qN pbl i    or Complete data of a packet The status and the timestamp are not a part of the PBL data. Therefore  the DWC ether qos drives the complete status  including timestamp status  during first PBL request for the packet  in store and forward mode  or the last PBL request for the packet  in Threshold mode . Value After Reset  0x0"]
        #[inline(always)]
        pub fn rxq_frm_arbit(
            self,
        ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlRxq0Control_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<3,1,0,MtlRxq0Control_SPEC,crate::common::RW>::from_register(self,0)
        }
    }
    impl core::default::Default for MtlRxq0Control {
        #[inline(always)]
        fn default() -> MtlRxq0Control {
            <crate::RegValueT<MtlRxq0Control_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtlRxq0Debug_SPEC;
    impl crate::sealed::RegSpec for MtlRxq0Debug_SPEC {
        type DataType = u32;
    }
    #[doc = "MTL Queue 0 Receive Debug Register\n resetvalue={Application Reset:0x0}"]
    pub type MtlRxq0Debug = crate::RegValueT<MtlRxq0Debug_SPEC>;

    impl MtlRxq0Debug {
        #[doc = "MTL Rx Queue Write Controller Active Status   RWCSTS. When high  this bit indicates that the MTL Rx queue Write controller is        active  and it is transferring a received packet to the Rx Queue. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rwcsts(
            self,
        ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlRxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterFieldBool::<0,1,0,MtlRxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "MTL Rx Queue Read Controller State   RRCSTS. This field gives the state of the Rx queue Read controller  Value After Reset  0x0"]
        #[inline(always)]
        pub fn rrcsts(
            self,
        ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, MtlRxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterField::<1,0x3,1,0,u8, MtlRxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "MTL Rx Queue Fill Level Status   RXQSTS. This field gives the status of the fill level of the Rx Queue  Value After Reset  0x0"]
        #[inline(always)]
        pub fn rxqsts(
            self,
        ) -> crate::common::RegisterField<4, 0x3, 1, 0, u8, MtlRxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterField::<4,0x3,1,0,u8, MtlRxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "Number of Packets in Receive Queue   PRXQ. This field indicates the current number of packets in the Rx Queue. The theoretical maximum value for this field is 256KB 16B   16K Packets  that is  Max Queue Size Min Packet Size. Value After Reset  0x0"]
        #[inline(always)]
        pub fn prxq(
            self,
        ) -> crate::common::RegisterField<16, 0x3fff, 1, 0, u16, MtlRxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterField::<16,0x3fff,1,0,u16, MtlRxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
    }
    impl core::default::Default for MtlRxq0Debug {
        #[inline(always)]
        fn default() -> MtlRxq0Debug {
            <crate::RegValueT<MtlRxq0Debug_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtlRxq0MissedPacketOverflowCnt_SPEC;
    impl crate::sealed::RegSpec for MtlRxq0MissedPacketOverflowCnt_SPEC {
        type DataType = u32;
    }
    #[doc = "MTL Queue 0 Receive Missed Packet and Overflow Counter Register\n resetvalue={Application Reset:0x0}"]
    pub type MtlRxq0MissedPacketOverflowCnt = crate::RegValueT<MtlRxq0MissedPacketOverflowCnt_SPEC>;

    impl MtlRxq0MissedPacketOverflowCnt {
        #[doc = "Overflow Packet Counter   OVFPKTCNT. This field indicates the number of packets discarded by the DWC ether qos because of Receive queue overflow. This counter is incremented each time the DWC ether qos discards an incoming packet because of overflow. This counter is reset when this register is read with mci be i 0  at 1 b1. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
        #[inline(always)]
        pub fn ovfpktcnt(
            self,
        ) -> crate::common::RegisterField<
            0,
            0x7ff,
            1,
            0,
            u16,
            MtlRxq0MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterField::<
                0,
                0x7ff,
                1,
                0,
                u16,
                MtlRxq0MissedPacketOverflowCnt_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
        #[doc = "Overflow Counter Overflow Bit   OVFCNTOVF. When set  this bit indicates that the Rx Queue Overflow Packet Counter field crossed the maximum limit. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
        #[inline(always)]
        pub fn ovfcntovf(
            self,
        ) -> crate::common::RegisterFieldBool<
            11,
            1,
            0,
            MtlRxq0MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterFieldBool::<
                11,
                1,
                0,
                MtlRxq0MissedPacketOverflowCnt_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
        #[doc = "Missed Packet Counter   MISPKTCNT. This field indicates the number of packets missed by the DWC ether qos because the application asserted ari pkt flush i   for this queue. This counter is reset when this register is read with mci be i 0  at 1b1. This counter is incremented by 1 when the DMA discards the packet because of buffer unavailability. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
        #[inline(always)]
        pub fn mispktcnt(
            self,
        ) -> crate::common::RegisterField<
            16,
            0x7ff,
            1,
            0,
            u16,
            MtlRxq0MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterField::<
                16,
                0x7ff,
                1,
                0,
                u16,
                MtlRxq0MissedPacketOverflowCnt_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
        #[doc = "Missed Packet Counter Overflow Bit   MISCNTOVF. When set  this bit indicates that the Rx Queue Missed Packet Counter crossed the maximum limit. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
        #[inline(always)]
        pub fn miscntovf(
            self,
        ) -> crate::common::RegisterFieldBool<
            27,
            1,
            0,
            MtlRxq0MissedPacketOverflowCnt_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterFieldBool::<
                27,
                1,
                0,
                MtlRxq0MissedPacketOverflowCnt_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for MtlRxq0MissedPacketOverflowCnt {
        #[inline(always)]
        fn default() -> MtlRxq0MissedPacketOverflowCnt {
            <crate::RegValueT<MtlRxq0MissedPacketOverflowCnt_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtlRxq0OperationMode_SPEC;
    impl crate::sealed::RegSpec for MtlRxq0OperationMode_SPEC {
        type DataType = u32;
    }
    #[doc = "MTL Queue 0 Receive Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    pub type MtlRxq0OperationMode = crate::RegValueT<MtlRxq0OperationMode_SPEC>;

    impl MtlRxq0OperationMode {
        #[doc = "Receive Queue Threshold Control   RTC. These bits control the threshold level of the MTL Rx queue  in bytes   The received packet is transferred to the application or DMA when the packet size within the MTL Rx queue is larger than the threshold. In addition  full packets with length less than the threshold are automatically transferred. This field is valid only when the RSF bit is zero. This field is ignored when the RSF bit is set to 1. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rtc(
            self,
        ) -> crate::common::RegisterField<
            0,
            0x3,
            1,
            0,
            u8,
            MtlRxq0OperationMode_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                0,
                0x3,
                1,
                0,
                u8,
                MtlRxq0OperationMode_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Forward Undersized Good Packets   FUP. When this bit is set  the Rx queue forwards the undersized good packets  packets with no error and length less than 64 bytes   including pad bytes and CRC. When this bit is reset  the Rx queue drops all packets of less than 64 bytes  unless a packet is already transferred because of the lower value of Rx Threshold  for example  RTC   01. Value After Reset  0x0"]
        #[inline(always)]
        pub fn fup(
            self,
        ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlRxq0OperationMode_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<3,1,0,MtlRxq0OperationMode_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Forward Error Packets   FEP. When this bit is reset  the Rx queue drops packets with error status  CRC error  GMII ER  watchdog timeout  or overflow . However  if the start byte  write  pointer of a packet is already transferred to the read controller side  in Threshold mode   the packet is not dropped. When this bit is set  all packets except the runt error packets are forwarded to the application or DMA. If the RSF bit is set and the Rx queue overflows when a partial packet is written  the packet is dropped irrespective of the setting of this bit. However  if the RSF bit is reset and the Rx queue overflows when a partial packet is written  a partial packet may be forwarded to the application or DMA. Value After Reset  0x0"]
        #[inline(always)]
        pub fn fep(
            self,
        ) -> crate::common::RegisterFieldBool<4, 1, 0, MtlRxq0OperationMode_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<4,1,0,MtlRxq0OperationMode_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Receive Queue Store and Forward   RSF. When this bit is set  the DWC ether qos reads a packet from the Rx queue only after the complete packet has been written to it  ignoring the RTC field of this register. When this bit is reset  the Rx queue operates in the Threshold  cut through  mode  subject to the threshold specified by the RTC field of this register. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rsf(
            self,
        ) -> crate::common::RegisterFieldBool<5, 1, 0, MtlRxq0OperationMode_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<5,1,0,MtlRxq0OperationMode_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Disable Dropping of TCP IP Checksum Error Packets   DIS TCP EF. When this bit is set  the MAC does not drop the packets which only have the errors detected by the Receive Checksum Offload engine. Such packets have errors only in the encapsulated payload. There are no errors  including FCS error  in the Ethernet packet received by the MAC. When this bit is reset  all error packets are dropped if the FEP bit is reset. Value After Reset  0x0"]
        #[inline(always)]
        pub fn dis_tcp_ef(
            self,
        ) -> crate::common::RegisterFieldBool<6, 1, 0, MtlRxq0OperationMode_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<6,1,0,MtlRxq0OperationMode_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Enable Hardware Flow Control   EHFC. When this bit is set  the flow control signal operation  based on the fill level of Rx queue  is enabled. When reset  the flow control operation is disabled. Value After Reset  0x0"]
        #[inline(always)]
        pub fn ehfc(
            self,
        ) -> crate::common::RegisterFieldBool<7, 1, 0, MtlRxq0OperationMode_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<7,1,0,MtlRxq0OperationMode_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Threshold for Activating Flow Control  in half duplex and full duplex   RFA. These bits control the threshold  fill level of Rx queue  at which the flow control is activated  For more information on encoding for this field  see RFD. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rfa(
            self,
        ) -> crate::common::RegisterField<
            8,
            0xf,
            1,
            0,
            u8,
            MtlRxq0OperationMode_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                8,
                0xf,
                1,
                0,
                u8,
                MtlRxq0OperationMode_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Threshold for Deactivating Flow Control  in half duplex and full duplex modes    RFD. These bits control the threshold  fill level of Rx queue  at which the flow control is de asserted after activation  LOST SEQUENCE DEFINITION The de assertion is effective only after flow control is asserted. Note  The value must be programmed in such a way to make sure that the threshold is a positive number. When the EHFC is set high  these values are applicable only when the Rx queue size determined by the RQS field of this register  is equal to or greater than 4 KB. For a given queue size  the values ranges between 0 and the encoding for FULL minus  QSIZE   0.5 KB  and all other values are illegal. Here the term FULL and QSIZE refers to the queue size determined by the RQS field of this register. The width of this field depends on RX FIFO size selected during the configuration. Remaining bits are reserved and read only. Value After Reset  0x0"]
        #[inline(always)]
        pub fn rfd(
            self,
        ) -> crate::common::RegisterField<
            14,
            0xf,
            1,
            0,
            u8,
            MtlRxq0OperationMode_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                14,
                0xf,
                1,
                0,
                u8,
                MtlRxq0OperationMode_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Receive Queue Size   RQS. This field indicates the size of the allocated Receive queues in blocks        of 256 bytes. The RQS field is read write only if the number of Rx        Queues more than one  the reset value is 0x0 and indicates size of 256        bytes. When the number of Rx Queues is one  the field is read only and the        configured RX FIFO size in blocks of 256 bytes is reflected in the reset        value. The width of this field depends on the Rx memory size selected in your        configuration. For example  if the memory size is 2048  the width of        this field is 3 bits  LOG2 2048 256    LOG2 8    3 bits Value After Reset  0x0"]
        #[inline(always)]
        pub fn rqs(
            self,
        ) -> crate::common::RegisterField<
            20,
            0x1f,
            1,
            0,
            u8,
            MtlRxq0OperationMode_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                20,
                0x1f,
                1,
                0,
                u8,
                MtlRxq0OperationMode_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for MtlRxq0OperationMode {
        #[inline(always)]
        fn default() -> MtlRxq0OperationMode {
            <crate::RegValueT<MtlRxq0OperationMode_SPEC> as RegisterValue<_>>::new(0)
        }
    }
}
#[doc = "MTL TXQ0"]
#[derive(Copy, Clone, Eq, PartialEq)]
pub struct MtlTxq0(pub(super) *mut u8);
unsafe impl core::marker::Send for MtlTxq0 {}
unsafe impl core::marker::Sync for MtlTxq0 {}
impl MtlTxq0 {
    #[doc = "MTL Queue 0 Transmit Debug Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq0_debug(
        &self,
    ) -> crate::common::Reg<mtl_txq0::MtlTxq0Debug_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(8usize)) }
    }
    #[doc = "MTL Queue 0 Transmit Status Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq0_ets_status(
        &self,
    ) -> crate::common::Reg<mtl_txq0::MtlTxq0EtsStatus_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(20usize)) }
    }
    #[doc = "MTL Queue 0 Transmit Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq0_operation_mode(
        &self,
    ) -> crate::common::Reg<mtl_txq0::MtlTxq0OperationMode_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(0usize)) }
    }
    #[doc = "MTL Queue 0 Transmit Quantum or Weights Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq0_quantum_weight(
        &self,
    ) -> crate::common::Reg<mtl_txq0::MtlTxq0QuantumWeight_SPEC, crate::common::RW> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(24usize)) }
    }
    #[doc = "MTL Queue 0 Transmit Underflow Counter Register\n resetvalue={Application Reset:0x0}"]
    #[inline(always)]
    pub const fn mtl_txq0_underflow(
        &self,
    ) -> crate::common::Reg<mtl_txq0::MtlTxq0Underflow_SPEC, crate::common::R> {
        unsafe { crate::common::Reg::from_ptr(self.0.add(4usize)) }
    }
}
pub mod mtl_txq0 {
    #[allow(unused_imports)]
    use crate::common::*;
    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtlTxq0Debug_SPEC;
    impl crate::sealed::RegSpec for MtlTxq0Debug_SPEC {
        type DataType = u32;
    }
    #[doc = "MTL Queue 0 Transmit Debug Register\n resetvalue={Application Reset:0x0}"]
    pub type MtlTxq0Debug = crate::RegValueT<MtlTxq0Debug_SPEC>;

    impl MtlTxq0Debug {
        #[doc = "Transmit Queue in Pause   TXQPAUSED. When this bit is high and the Rx flow control is enabled  it indicates that the Tx Queue is in the Pause condition  in the full duplex only mode  because of the following  Reception of the PFC packet for the priorities assigned to the Tx Queue when PFC is enabled Reception of 802.3x Pause packet when PFC is disabled Value After Reset  0x0"]
        #[inline(always)]
        pub fn txqpaused(
            self,
        ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlTxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterFieldBool::<0,1,0,MtlTxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "MTL Tx Queue Read Controller Status   TRCSTS. This field indicates the state of the Tx Queue Read Controller  Value After Reset  0x0"]
        #[inline(always)]
        pub fn trcsts(
            self,
        ) -> crate::common::RegisterField<1, 0x3, 1, 0, u8, MtlTxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterField::<1,0x3,1,0,u8, MtlTxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "MTL Tx Queue Write Controller Status   TWCSTS. When high  this bit indicates that the MTL Tx Queue Write Controller is active  and it is transferring the data to the Tx Queue. Value After Reset  0x0"]
        #[inline(always)]
        pub fn twcsts(
            self,
        ) -> crate::common::RegisterFieldBool<3, 1, 0, MtlTxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterFieldBool::<3,1,0,MtlTxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "MTL Tx Queue Not Empty Status   TXQSTS. When this bit is high  it indicates that the MTL Tx Queue is not empty and some data is left for transmission. Value After Reset  0x0"]
        #[inline(always)]
        pub fn txqsts(
            self,
        ) -> crate::common::RegisterFieldBool<4, 1, 0, MtlTxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterFieldBool::<4,1,0,MtlTxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "MTL Tx Status FIFO Full Status   TXSTSFSTS. When high  this bit indicates that the MTL Tx Status FIFO is full. Therefore  the MTL cannot accept any more packets for transmission. Value After Reset  0x0"]
        #[inline(always)]
        pub fn txstsfsts(
            self,
        ) -> crate::common::RegisterFieldBool<5, 1, 0, MtlTxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterFieldBool::<5,1,0,MtlTxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "Number of Packets in the Transmit Queue   PTXQ. This field indicates the current number of packets in the Tx Queue. When the DTXSTS bit of MTL Operation Mode register is set to 1  this field does not reflect the number of packets in the Transmit queue. Value After Reset  0x0"]
        #[inline(always)]
        pub fn ptxq(
            self,
        ) -> crate::common::RegisterField<16, 0x7, 1, 0, u8, MtlTxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterField::<16,0x7,1,0,u8, MtlTxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
        #[doc = "Number of Status Words in Tx Status FIFO of Queue   STXSTSF. This field indicates the current number of status in the Tx Status FIFO of this queue. When the DTXSTS bit of MTL Operation Mode register is set to 1  this field does not reflect the number of status words in Tx Status FIFO. Value After Reset  0x0"]
        #[inline(always)]
        pub fn stxstsf(
            self,
        ) -> crate::common::RegisterField<20, 0x7, 1, 0, u8, MtlTxq0Debug_SPEC, crate::common::R>
        {
            crate::common::RegisterField::<20,0x7,1,0,u8, MtlTxq0Debug_SPEC,crate::common::R>::from_register(self,0)
        }
    }
    impl core::default::Default for MtlTxq0Debug {
        #[inline(always)]
        fn default() -> MtlTxq0Debug {
            <crate::RegValueT<MtlTxq0Debug_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtlTxq0EtsStatus_SPEC;
    impl crate::sealed::RegSpec for MtlTxq0EtsStatus_SPEC {
        type DataType = u32;
    }
    #[doc = "MTL Queue 0 Transmit Status Register\n resetvalue={Application Reset:0x0}"]
    pub type MtlTxq0EtsStatus = crate::RegValueT<MtlTxq0EtsStatus_SPEC>;

    impl MtlTxq0EtsStatus {
        #[doc = "Average Bits per Slot This field contains the average transmitted bits per slot.   ABS. When the DCB operation is enabled for Queue 0  this field is computed over every 10 million bit times slot  10 ms in 1000 Mbps  100 ms in 100 Mbps . The maximum value is 0x989680. Value After Reset  0x0"]
        #[inline(always)]
        pub fn abs(
            self,
        ) -> crate::common::RegisterField<
            0,
            0xffffff,
            1,
            0,
            u32,
            MtlTxq0EtsStatus_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterField::<
                0,
                0xffffff,
                1,
                0,
                u32,
                MtlTxq0EtsStatus_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for MtlTxq0EtsStatus {
        #[inline(always)]
        fn default() -> MtlTxq0EtsStatus {
            <crate::RegValueT<MtlTxq0EtsStatus_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtlTxq0OperationMode_SPEC;
    impl crate::sealed::RegSpec for MtlTxq0OperationMode_SPEC {
        type DataType = u32;
    }
    #[doc = "MTL Queue 0 Transmit Operation Mode Register\n resetvalue={Application Reset:0x0}"]
    pub type MtlTxq0OperationMode = crate::RegValueT<MtlTxq0OperationMode_SPEC>;

    impl MtlTxq0OperationMode {
        #[doc = "Flush Transmit Queue   FTQ. When this bit is set  the Tx queue controller logic is reset to its default values. Therefore  all the data in the Tx queue is lost or flushed. This bit is internally reset when the flushing operation is complete. Until this bit is reset  you should not write to the MTL TxQ1 Operation Mode register. The data which is already accepted by the MAC transmitter is not flushed. It is scheduled for transmission and results in underflow and runt packet transmission. Note   The flush operation is complete only when the Tx queue is empty and the application has accepted the pending Tx Status of all transmitted packets. To complete this flush operation  the PHY Tx clock  clk tx i  should be active. Access restriction applies. Setting 1 sets. Self cleared. Setting 0 has no effect. Value After Reset  0x0"]
        #[inline(always)]
        pub fn ftq(
            self,
        ) -> crate::common::RegisterFieldBool<0, 1, 0, MtlTxq0OperationMode_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<0,1,0,MtlTxq0OperationMode_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Transmit Store and Forward   TSF. When this bit is set  the transmission starts when a full packet resides in the MTL Tx queue. When this bit is set  the TTC values specified in Bits 6 4  of this register are ignored. This bit should be changed only when the transmission is stopped. Value After Reset  0x0"]
        #[inline(always)]
        pub fn tsf(
            self,
        ) -> crate::common::RegisterFieldBool<1, 1, 0, MtlTxq0OperationMode_SPEC, crate::common::RW>
        {
            crate::common::RegisterFieldBool::<1,1,0,MtlTxq0OperationMode_SPEC,crate::common::RW>::from_register(self,0)
        }
        #[doc = "Transmit Queue Enable   TXQEN. This field is used to enable disable the transmit queue 0. This field is        Read Only in Single Queue configurations and Read Write in Multiple        Queue configurations. Note   In multiple Tx queues configuration         all the queues are disabled by default. Enable the Tx queue by        programming this field. Value After Reset  0x0"]
        #[inline(always)]
        pub fn txqen(
            self,
        ) -> crate::common::RegisterField<
            2,
            0x3,
            1,
            0,
            u8,
            MtlTxq0OperationMode_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                2,
                0x3,
                1,
                0,
                u8,
                MtlTxq0OperationMode_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Transmit Threshold Control   TTC. These bits control the threshold level of the MTL Tx Queue. The        transmission starts when the packet size within the MTL Tx Queue is        larger than the threshold. In addition  full packets with length less        than the threshold are also transmitted. These bits are used only when        the TSF bit is reset. Value After Reset  0x0"]
        #[inline(always)]
        pub fn ttc(
            self,
        ) -> crate::common::RegisterField<
            4,
            0x7,
            1,
            0,
            u8,
            MtlTxq0OperationMode_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                4,
                0x7,
                1,
                0,
                u8,
                MtlTxq0OperationMode_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
        #[doc = "Transmit Queue Size   TQS. This field indicates the size of the allocated Transmit queues in blocks        of 256 bytes. The TQS field is read write only if the number of Tx        Queues more than one  the reset value is 0x0 and indicates size of 256        bytes. When the number of Tx Queues is one  the field is read only and        the configured TX FIFO size in blocks of 256 bytes is reflected in the        reset value. The width of this field depends on the Tx memory size        selected in your configuration. For example  if the memory size is 2048         the width of this field is 3 bits  LOG2 2048 256    LOG2 8    3 bits Value After Reset  0x0"]
        #[inline(always)]
        pub fn tqs(
            self,
        ) -> crate::common::RegisterField<
            16,
            0xf,
            1,
            0,
            u8,
            MtlTxq0OperationMode_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                16,
                0xf,
                1,
                0,
                u8,
                MtlTxq0OperationMode_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for MtlTxq0OperationMode {
        #[inline(always)]
        fn default() -> MtlTxq0OperationMode {
            <crate::RegValueT<MtlTxq0OperationMode_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtlTxq0QuantumWeight_SPEC;
    impl crate::sealed::RegSpec for MtlTxq0QuantumWeight_SPEC {
        type DataType = u32;
    }
    #[doc = "MTL Queue 0 Transmit Quantum or Weights Register\n resetvalue={Application Reset:0x0}"]
    pub type MtlTxq0QuantumWeight = crate::RegValueT<MtlTxq0QuantumWeight_SPEC>;

    impl MtlTxq0QuantumWeight {
        #[doc = "Quantum or Weights   ISCQW. When the DCB operation is enabled with DWRR algorithm for Queue 0 traffic  this field contains the quantum value in bytes to be added to credit during every queue scanning cycle. The maximum value is 0x1312D0 bytes. When DCB operation is enabled with WFQ algorithm for Queue 0 traffic  this field contains the weight for this queue. The maximum value is 0x3FFF where weight of 0 indicates 100  bandwidth. Bits 20 14  must be written to zero. When DCB operation or generic queueing operation is enabled with WRR algorithm for Queue 0 traffic  this field contains the weight for this queue. The maximum value is 0x64. Bits  20 7  must be written to zero. Value After Reset  0x0"]
        #[inline(always)]
        pub fn iscqw(
            self,
        ) -> crate::common::RegisterField<
            0,
            0x1fffff,
            1,
            0,
            u32,
            MtlTxq0QuantumWeight_SPEC,
            crate::common::RW,
        > {
            crate::common::RegisterField::<
                0,
                0x1fffff,
                1,
                0,
                u32,
                MtlTxq0QuantumWeight_SPEC,
                crate::common::RW,
            >::from_register(self, 0)
        }
    }
    impl core::default::Default for MtlTxq0QuantumWeight {
        #[inline(always)]
        fn default() -> MtlTxq0QuantumWeight {
            <crate::RegValueT<MtlTxq0QuantumWeight_SPEC> as RegisterValue<_>>::new(0)
        }
    }

    #[doc(hidden)]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct MtlTxq0Underflow_SPEC;
    impl crate::sealed::RegSpec for MtlTxq0Underflow_SPEC {
        type DataType = u32;
    }
    #[doc = "MTL Queue 0 Transmit Underflow Counter Register\n resetvalue={Application Reset:0x0}"]
    pub type MtlTxq0Underflow = crate::RegValueT<MtlTxq0Underflow_SPEC>;

    impl MtlTxq0Underflow {
        #[doc = "Underflow Packet Counter   UFFRMCNT. This field indicates the number of packets aborted by the controller because of Tx Queue Underflow. This counter is incremented each time the MAC aborts outgoing packet because of underflow. The counter is cleared when this register is read with mci be i 0  at 1 b1. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
        #[inline(always)]
        pub fn uffrmcnt(
            self,
        ) -> crate::common::RegisterField<
            0,
            0x7ff,
            1,
            0,
            u16,
            MtlTxq0Underflow_SPEC,
            crate::common::R,
        > {
            crate::common::RegisterField::<
                0,
                0x7ff,
                1,
                0,
                u16,
                MtlTxq0Underflow_SPEC,
                crate::common::R,
            >::from_register(self, 0)
        }
        #[doc = "Overflow Bit for Underflow Packet Counter   UFCNTOVF. This bit is set every time the Tx queue Underflow Packet Counter field overflows  that is  it has crossed the maximum count. In such a scenario  the overflow packet counter is reset to all zeros and this bit indicates that the rollover happened. Access restriction applies. Clears on read. Self set to 1 on internal event. Value After Reset  0x0"]
        #[inline(always)]
        pub fn ufcntovf(
            self,
        ) -> crate::common::RegisterFieldBool<11, 1, 0, MtlTxq0Underflow_SPEC, crate::common::R>
        {
            crate::common::RegisterFieldBool::<11,1,0,MtlTxq0Underflow_SPEC,crate::common::R>::from_register(self,0)
        }
    }
    impl core::default::Default for MtlTxq0Underflow {
        #[inline(always)]
        fn default() -> MtlTxq0Underflow {
            <crate::RegValueT<MtlTxq0Underflow_SPEC> as RegisterValue<_>>::new(0)
        }
    }
}
